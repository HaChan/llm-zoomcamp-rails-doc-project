Active Job â Make work happen laterActive Job is a framework for declaring jobs and making them run on a variety of queuing backends. These jobs can be everything from regularly scheduled clean-ups, to billing charges, to mailings â anything that can be chopped up into small units of work and run in parallel.It also serves as the backend for Action Mailerâs deliver_later functionality that makes it easy to turn any mailing into a job for running later. Thatâs one of the most common jobs in a modern web application: sending emails outside the request-response cycle, so the user doesnât have to wait on it.The main point is to ensure that all Rails apps will have a job infrastructure in place, even if itâs in the form of an âimmediate runnerâ. We can then have framework features and other gems build on top of that, without having to worry about API differences between Delayed Job and Resque. Picking your queuing backend becomes more of an operational concern, then. And youâll be able to switch between them without having to rewrite your jobs.You can read more about Active Job in theActive Job Basicsguide.UsageTo learn how to use your preferred queuing backend see its adapter documentation atActiveJob::QueueAdapters.Declare a job like so:class MyJob < ActiveJob::Base
  queue_as :my_jobs

  def perform(record)
    record.do_work
  end
endEnqueue a job like so:MyJob.perform_later record  # Enqueue a job to be performed as soon as the queuing system is free.MyJob.set(wait_until: Date.tomorrow.noon).perform_later(record)  # Enqueue a job to be performed tomorrow at noon.MyJob.set(wait: 1.week).perform_later(record) # Enqueue a job to be performed 1 week from now.Thatâs it!GlobalID supportActive Job supportsGlobalID serializationfor parameters. This makes it possible to pass live Active Record objects to your job instead of class/id pairs, which you then have to manually deserialize. Before, jobs would look like this:class TrashableCleanupJob
  def perform(trashable_class, trashable_id, depth)
    trashable = trashable_class.constantize.find(trashable_id)
    trashable.cleanup(depth)
  end
endNow you can simply do:class TrashableCleanupJob
  def perform(trashable, depth)
    trashable.cleanup(depth)
  end
endThis works with any class that mixes in GlobalID::Identification, which by default has been mixed into Active Record classes.Supported queuing systemsActive Job has built-in adapters for multiple queuing backends (Sidekiq, Resque, Delayed Job and others). To get an up-to-date list of the adapters see the API Documentation forActiveJob::QueueAdapters.Please note:We are not accepting pull requests for new adapters. We encourage library authors to provide anActiveJobadapter as part of their gem, or as a stand-alone gem. For discussion about this see the following PRs:23311,21406, and#32285.Download and installationThe latest version of Active Job can be installed with RubyGems:$ gem install activejobSource code can be downloaded as part of the Rails project on GitHub:github.com/rails/rails/tree/main/activejobLicenseActive Job is released under the MIT license:opensource.org/licenses/MITSupportAPI documentation is at:api.rubyonrails.orgBug reports for the Ruby on Rails project can be filed here:github.com/rails/rails/issuesFeature requests should be discussed on the rails-core mailing list here:discuss.rubyonrails.org/c/rubyonrails-core