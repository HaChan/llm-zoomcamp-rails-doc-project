Active Record PersistenceNamespaceMODULEActiveRecord::Persistence::ClassMethodsMethodsBbecomes,becomes!Ddecrement,decrement!,delete,destroy,destroy!,destroyed?Iincrement,increment!Nnew_record?Ppersisted?,previously_new_record?,previously_persisted?RreloadSsave,save!Ttoggle,toggle!,touchUupdate,update!,update_attribute,update_attribute!,update_column,update_columnsInstance Public methodsbecomes(klass)LinkReturns an instance of the specifiedklasswith the attributes of the current record. This is mostly useful in relation to single table inheritance (STI) structures where you want a subclass to appear as the superclass. This can be used along with record identification in Action Pack to allow, say,Client < Companyto do something like renderpartial: @client.becomes(Company)to render that instance using the companies/company partial instead of clients/client.Note: The new instance will share a link to the same attributes as the original class. Therefore the STI column value will still be the same. Any change to the attributes on either instance will affect both instances. This includes any attribute initialization done by the new instance.If you want to change the STI column as well, usebecomes!instead.Source:show|on GitHub# File activerecord/lib/active_record/persistence.rb, line 489defbecomes(klass)became=klass.allocatebecame.send(:initialize)do|becoming|@attributes.reverse_merge!(becoming.instance_variable_get(:@attributes))becoming.instance_variable_set(:@attributes,@attributes)becoming.instance_variable_set(:@mutations_from_database,@mutations_from_database||=nil)becoming.instance_variable_set(:@new_record,new_record?)becoming.instance_variable_set(:@destroyed,destroyed?)becoming.errors.copy!(errors)endbecameendbecomes!(klass)LinkWrapper aroundbecomesthat also changes the instanceâs STI column value. This is especially useful if you want to persist the changed class in your database.Note: The old instanceâs STI column value will be changed too, as both objects share the same set of attributes.Source:show|on GitHub# File activerecord/lib/active_record/persistence.rb, line 510defbecomes!(klass)became=becomes(klass)sti_type=nilif!klass.descends_from_active_record?sti_type=klass.sti_nameendbecame.public_send("#{klass.inheritance_column}=",sti_type)becameenddecrement(attribute, by = 1)LinkInitializesattributeto zero ifniland subtracts the value passed asby(default is 1). The decrement is performed directly on the underlying attribute, no setter is invoked. Only makes sense for number-based attributes. Returnsself.Source:show|on GitHub# File activerecord/lib/active_record/persistence.rb, line 657defdecrement(attribute,by=1)increment(attribute,-by)enddecrement!(attribute, by = 1, touch: nil)LinkWrapper arounddecrementthat writes the update to the database. Onlyattributeis updated; the record itself is not saved. This means that any other modified attributes will still be dirty.Validationsand callbacks are skipped. Supports thetouchoption fromupdate_counters, see that for more. Returnsself.Source:show|on GitHub# File activerecord/lib/active_record/persistence.rb, line 667defdecrement!(attribute,by=1,touch:nil)increment!(attribute,-by,touch:touch)enddelete()LinkDeletes the record in the database and freezes this instance to reflect that no changes should be made (since they canât be persisted). Returns the frozen instance.The row is simply removed with an SQLDELETEstatement on the recordâs primary key, and no callbacks are executed.Note that this will also delete records marked as#readonly?.To enforce the objectâsbefore_destroyandafter_destroycallbacks or any:dependentassociation options, usedestroy.Source:show|on GitHub# File activerecord/lib/active_record/persistence.rb, line 441defdelete_delete_rowifpersisted?@destroyed=true@previously_new_record=falsefreezeenddestroy()LinkDeletes the record in the database and freezes this instance to reflect that no changes should be made (since they canât be persisted).Thereâs a series of callbacks associated withdestroy. If thebefore_destroycallback throws:abortthe action is cancelled anddestroyreturnsfalse. SeeActiveRecord::Callbacksfor further details.Source:show|on GitHub# File activerecord/lib/active_record/persistence.rb, line 455defdestroy_raise_readonly_record_errorifreadonly?destroy_associations@_trigger_destroy_callback||=persisted?&&destroy_row>0@destroyed=true@previously_new_record=falsefreezeenddestroy!()LinkDeletes the record in the database and freezes this instance to reflect that no changes should be made (since they canât be persisted).Thereâs a series of callbacks associated withdestroy!. If thebefore_destroycallback throws:abortthe action is cancelled anddestroy!raisesActiveRecord::RecordNotDestroyed. SeeActiveRecord::Callbacksfor further details.Source:show|on GitHub# File activerecord/lib/active_record/persistence.rb, line 471defdestroy!destroy||_raise_record_not_destroyedenddestroyed?()LinkReturns true if this object has been destroyed, otherwise returns false.Source:show|on GitHub# File activerecord/lib/active_record/persistence.rb, line 357defdestroyed?@destroyedendincrement(attribute, by = 1)LinkInitializesattributeto zero ifniland adds the value passed asby(default is 1). The increment is performed directly on the underlying attribute, no setter is invoked. Only makes sense for number-based attributes. Returnsself.Source:show|on GitHub# File activerecord/lib/active_record/persistence.rb, line 634defincrement(attribute,by=1)self[attribute]||=0self[attribute]+=byselfendincrement!(attribute, by = 1, touch: nil)LinkWrapper aroundincrementthat writes the update to the database. Onlyattributeis updated; the record itself is not saved. This means that any other modified attributes will still be dirty.Validationsand callbacks are skipped. Supports thetouchoption fromupdate_counters, see that for more. Returnsself.Source:show|on GitHub# File activerecord/lib/active_record/persistence.rb, line 646defincrement!(attribute,by=1,touch:nil)increment(attribute,by)change=public_send(attribute)-(public_send(:"#{attribute}_in_database")||0)self.class.update_counters(id,attribute=>change,touch:touch)public_send(:"clear_#{attribute}_change")selfendnew_record?()LinkReturns true if this object hasnât been saved yet â that is, a record for the object doesnât exist in the database yet; otherwise, returns false.Source:show|on GitHub# File activerecord/lib/active_record/persistence.rb, line 340defnew_record?@new_recordendpersisted?()LinkReturns true if the record is persisted, i.e. itâs not a new record and it was not destroyed, otherwise returns false.Source:show|on GitHub# File activerecord/lib/active_record/persistence.rb, line 363defpersisted?!(@new_record||@destroyed)endpreviously_new_record?()LinkReturns true if this object was just created â that is, prior to the last update or delete, the object didnât exist in the database and new_record? would have returned true.Source:show|on GitHub# File activerecord/lib/active_record/persistence.rb, line 347defpreviously_new_record?@previously_new_recordendpreviously_persisted?()LinkReturns true if this object was previously persisted but now it has been deleted.Source:show|on GitHub# File activerecord/lib/active_record/persistence.rb, line 352defpreviously_persisted?!new_record?&&destroyed?endreload(options = nil)LinkReloads the record from the database.This method finds the record by its primary key (which could be assigned manually) and modifies the receiver in-place:account = Account.new
# => #<Account id: nil, email: nil>
account.id = 1
account.reload
# Account Load (1.2ms)  SELECT "accounts".* FROM "accounts" WHERE "accounts"."id" = $1 LIMIT 1  [["id", 1]]
# => #<Account id: 1, email: 'account@example.com'>Attributesare reloaded from the database, and caches busted, in particular the associations cache and theQueryCache.If the record no longer exists in the databaseActiveRecord::RecordNotFoundis raised. Otherwise, in addition to the in-place modification the method returnsselffor convenience.The optional:lockflag option allows you to lock the reloaded record:reload(lock: true) # reload with pessimistic lockingReloading is commonly used in test suites to test something is actually written to the database, or when some action modifies the corresponding row in the database but not the object in memory:assert account.deposit!(25)
assert_equal 25, account.credit        # check it is updated in memory
assert_equal 25, account.reload.credit # check it is also persistedAnother common use case is optimistic locking handling:def with_optimistic_retry
  begin
    yield
  rescue ActiveRecord::StaleObjectError
    begin
      # Reload lock_version in particular.
      reload
    rescue ActiveRecord::RecordNotFound
      # If the record is gone there is nothing to do.
    else
      retry
    end
  end
endSource:show|on GitHub# File activerecord/lib/active_record/persistence.rb, line 744defreload(options=nil)self.class.connection_pool.clear_query_cachefresh_object=ifapply_scoping?(options)_find_record((options||{}).merge(all_queries:true))elseself.class.unscoped{_find_record(options) }end@association_cache=fresh_object.instance_variable_get(:@association_cache)@association_cache.each_value{|association|association.owner=self}@attributes=fresh_object.instance_variable_get(:@attributes)@new_record=false@previously_new_record=falseselfendsave(**options)LinkSaves the model.If the model is new, a record gets created in the database, otherwise the existing record gets updated.By default, save always runs validations. If any of them fail the action is cancelled andsavereturnsfalse, and the record wonât be saved. However, if you supplyvalidate: false, validations are bypassed altogether. SeeActiveRecord::Validationsfor more information.By default,savealso sets theupdated_at/updated_onattributes to the current time. However, if you supplytouch: false, these timestamps will not be updated.Thereâs a series of callbacks associated withsave. If any of thebefore_*callbacks throws:abortthe action is cancelled andsavereturnsfalse. SeeActiveRecord::Callbacksfor further details.Attributesmarked as readonly are silently ignored if the record is being updated.Source:show|on GitHub# File activerecord/lib/active_record/persistence.rb, line 392defsave(**options,&block)create_or_update(**options,&block)rescueActiveRecord::RecordInvalidfalseendsave!(**options)LinkSaves the model.If the model is new, a record gets created in the database, otherwise the existing record gets updated.By default,save!always runs validations. If any of them failActiveRecord::RecordInvalidgets raised, and the record wonât be saved. However, if you supplyvalidate: false, validations are bypassed altogether. SeeActiveRecord::Validationsfor more information.By default,save!also sets theupdated_at/updated_onattributes to the current time. However, if you supplytouch: false, these timestamps will not be updated.Thereâs a series of callbacks associated withsave!. If any of thebefore_*callbacks throws:abortthe action is cancelled andsave!raisesActiveRecord::RecordNotSaved. SeeActiveRecord::Callbacksfor further details.Attributesmarked as readonly are silently ignored if the record is being updated.Unless an error is raised, returns true.Source:show|on GitHub# File activerecord/lib/active_record/persistence.rb, line 425defsave!(**options,&block)create_or_update(**options,&block)||raise(RecordNotSaved.new("Failed to save the record",self))endtoggle(attribute)LinkAssigns toattributethe boolean opposite ofattribute?. So if the predicate returnstruethe attribute will becomefalse. This method toggles directly the underlying value without calling any setter. Returnsself.Example:user = User.first
user.banned? # => false
user.toggle(:banned)
user.banned? # => trueSource:show|on GitHub# File activerecord/lib/active_record/persistence.rb, line 683deftoggle(attribute)self[attribute] =!public_send("#{attribute}?")selfendtoggle!(attribute)LinkWrapper aroundtogglethat saves the record. This method differs from its non-bang version in the sense that it passes through the attribute setter. Saving is not subjected to validation checks. Returnstrueif the record could be saved.Source:show|on GitHub# File activerecord/lib/active_record/persistence.rb, line 692deftoggle!(attribute)toggle(attribute).update_attribute(attribute,self[attribute])endtouch(*names, time: nil)LinkSaves the record with the updated_at/on attributes set to the current time or the time specified. Please note that no validation is performed and only theafter_touch,after_commitandafter_rollbackcallbacks are executed.This method can be passed attribute names and an optional time argument. If attribute names are passed, they are updated along with updated_at/on attributes. If no time argument is passed, the current time is used as default.product.touch                         # updates updated_at/on with current time
product.touch(time: Time.new(2015, 2, 16, 0, 0, 0)) # updates updated_at/on with specified time
product.touch(:designed_at)           # updates the designed_at attribute and updated_at/on
product.touch(:started_at, :ended_at) # updates started_at, ended_at and updated_at/on attributesIf used along withbelongs_tothentouchwill invoketouchmethod on associated object.class Brake < ActiveRecord::Base
  belongs_to :car, touch: true
end

class Car < ActiveRecord::Base
  belongs_to :corporation, touch: true
end

# triggers @brake.car.touch and @brake.car.corporation.touch
@brake.touchNote thattouchmust be used on a persisted object, or else anActiveRecordErrorwill be thrown. For example:ball = Ball.new
ball.touch(:updated_at)   # => raises ActiveRecordErrorSource:show|on GitHub# File activerecord/lib/active_record/persistence.rb, line 795deftouch(*names,time:nil)_raise_record_not_touched_errorunlesspersisted?_raise_readonly_record_errorifreadonly?attribute_names=timestamp_attributes_for_update_in_modelattribute_names= (attribute_names|names).map!do|name|name=name.to_sname=self.class.attribute_aliases[name]||nameverify_readonly_attribute(name)nameendunlessattribute_names.empty?affected_rows=_touch_row(attribute_names,time)@_trigger_update_callback=affected_rows==1elsetrueendendupdate(attributes)LinkUpdates the attributes of the model from the passed-in hash and saves the record, all wrapped in a transaction. If the object is invalid, the saving will fail and false will be returned.Source:show|on GitHub# File activerecord/lib/active_record/persistence.rb, line 565defupdate(attributes)# The following transaction covers any possible database side-effects of the# attributes assignment. For example, setting the IDs of a child collection.with_transaction_returning_statusdoassign_attributes(attributes)saveendendupdate!(attributes)LinkUpdates its receiver just likeupdatebut callssave!instead ofsave, so an exception is raised if the record is invalid and saving will fail.Source:show|on GitHub# File activerecord/lib/active_record/persistence.rb, line 576defupdate!(attributes)# The following transaction covers any possible database side-effects of the# attributes assignment. For example, setting the IDs of a child collection.with_transaction_returning_statusdoassign_attributes(attributes)save!endendupdate_attribute(name, value)LinkUpdates a single attribute and saves the record. This is especially useful for boolean flags on existing records. Also note thatValidation is skipped.Callbacks are invoked.updated_at/updated_on column is updated if that column is available.Updates all the attributes that are dirty in this object.This method raises anActiveRecord::ActiveRecordErrorif the attribute is marked as readonly.Also seeupdate_column.Source:show|on GitHub# File activerecord/lib/active_record/persistence.rb, line 532defupdate_attribute(name,value)name=name.to_sverify_readonly_attribute(name)public_send("#{name}=",value)save(validate:false)endupdate_attribute!(name, value)LinkUpdates a single attribute and saves the record. This is especially useful for boolean flags on existing records. Also note thatValidation is skipped.Callbacks are invoked.updated_at/updated_on column is updated if that column is available.Updates all the attributes that are dirty in this object.This method raises anActiveRecord::ActiveRecordErrorif the attribute is marked as readonly.If any of thebefore_*callbacks throws:abortthe action is cancelled andupdate_attribute!raisesActiveRecord::RecordNotSaved. SeeActiveRecord::Callbacksfor further details.Source:show|on GitHub# File activerecord/lib/active_record/persistence.rb, line 554defupdate_attribute!(name,value)name=name.to_sverify_readonly_attribute(name)public_send("#{name}=",value)save!(validate:false)endupdate_column(name, value)LinkEquivalent toupdate_columns(name => value).Source:show|on GitHub# File activerecord/lib/active_record/persistence.rb, line 586defupdate_column(name,value)update_columns(name=>value)endupdate_columns(attributes)LinkUpdates the attributes directly in the database issuing an UPDATE SQL statement and sets them in the receiver:user.update_columns(last_request_at: Time.current)This is the fastest way to update attributes because it goes straight to the database, but take into account that in consequence the regular update procedures are totally bypassed. In particular:Validations are skipped.Callbacks are skipped.updated_at/updated_onare not updated.However, attributes are serialized with the same rules asActiveRecord::Relation#update_allThis method raises anActiveRecord::ActiveRecordErrorwhen called on new objects, or when at least one of the attributes is marked as readonly.Source:show|on GitHub# File activerecord/lib/active_record/persistence.rb, line 606defupdate_columns(attributes)raiseActiveRecordError,"cannot update a new record"ifnew_record?raiseActiveRecordError,"cannot update a destroyed record"ifdestroyed?_raise_readonly_record_errorifreadonly?attributes=attributes.transform_keysdo|key|name=key.to_sname=self.class.attribute_aliases[name]||nameverify_readonly_attribute(name)||nameendupdate_constraints=_query_constraints_hashattributes=attributes.each_with_object({})do|(k,v),h|h[k] =@attributes.write_cast_value(k,v)clear_attribute_change(k)endaffected_rows=self.class._update_record(attributes,update_constraints)affected_rows==1end