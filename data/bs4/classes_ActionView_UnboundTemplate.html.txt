MethodsBbind_localsNnewAttributes[R]details[R]virtual_pathClass Public methodsnew(source, identifier, details:, virtual_path:)LinkSource:show|on GitHub# File actionview/lib/action_view/unbound_template.rb, line 10definitialize(source,identifier,details:,virtual_path:)@source=source@identifier=identifier@details=details@virtual_path=virtual_path@templates=Concurrent::Map.new(initial_capacity:2)@write_lock=Mutex.newendInstance Public methodsbind_locals(locals)LinkSource:show|on GitHub# File actionview/lib/action_view/unbound_template.rb, line 20defbind_locals(locals)unlesstemplate=@templates[locals]@write_lock.synchronizedonormalized_locals=normalize_locals(locals)# We need ||=, both to dedup on the normalized locals and to check# while holding the lock.template= (@templates[normalized_locals]||=build_template(normalized_locals))iftemplate.strict_locals?# Under strict locals, we only need one template.# This replaces the @templates Concurrent::Map with a hash which# returns this template for every key.@templates=Hash.new(template).freezeelse# This may have already been assigned, but we've already de-dup'd so# reassignment is fine.@templates[locals.dup] =templateendendendtemplateend