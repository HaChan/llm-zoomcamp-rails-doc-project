NamespaceCLASSActiveRecord::ConnectionAdapters::TransactionInstrumenter::InstrumentationAlreadyStartedErrorCLASSActiveRecord::ConnectionAdapters::TransactionInstrumenter::InstrumentationNotStartedErrorMethodsFfinishNnewSstartClass Public methodsnew(payload = {})LinkSource:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/transaction.rb, line 80definitialize(payload= {})@handle=nil@started=false@payload=nil@base_payload=payloadendInstance Public methodsfinish(outcome)LinkSource:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/transaction.rb, line 101deffinish(outcome)raiseInstrumentationNotStartedError.new("Called finish on a transaction that hasn't started")unless@started@started=false@payload[:outcome] =outcome@handle.finishendstart()LinkSource:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/transaction.rb, line 90defstartraiseInstrumentationAlreadyStartedError.new("Called start on an already started transaction")if@started@started=trueActiveSupport::Notifications.instrument("start_transaction.active_record",@base_payload)@payload=@base_payload.dup# We dup because the payload for a given event is mutated later to add the outcome.@handle=ActiveSupport::Notifications.instrumenter.build_handle("transaction.active_record",@payload)@handle.startend