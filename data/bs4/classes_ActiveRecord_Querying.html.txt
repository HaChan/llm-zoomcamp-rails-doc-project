MethodsAasync_count_by_sql,async_find_by_sqlCcount_by_sqlFfind_by_sqlInstance Public methodsasync_count_by_sql(sql)LinkSame as#count_by_sqlbut perform the query asynchronously and returns anActiveRecord::Promise.Source:show|on GitHub# File activerecord/lib/active_record/querying.rb, line 116defasync_count_by_sql(sql)with_connectiondo|c|c.select_value(sanitize_sql(sql),"#{name} Count",async:true).then(&:to_i)endendasync_find_by_sql(sql, binds = [], preparable: nil, &block)LinkSame as#find_by_sqlbut perform the query asynchronously and returns anActiveRecord::Promise.Source:show|on GitHub# File activerecord/lib/active_record/querying.rb, line 59defasync_find_by_sql(sql,binds= [],preparable:nil,&block)result=with_connectiondo|c|_query_by_sql(c,sql,binds,preparable:preparable,async:true)endresult.thendo|result|_load_from_sql(result,&block)endendcount_by_sql(sql)LinkReturns the result of an SQL statement that should only include a COUNT(*) in the SELECT part. The use of this method should be restricted to complicated SQL queries that canât be executed using theActiveRecord::Calculationsclass methods. Look into those before using this method, as it could lock you into a specific database engine or require a code change to switch database engines.Product.count_by_sql "SELECT COUNT(*) FROM sales s, customers c WHERE s.customer_id = c.id"
# => 12Parameterssql- An SQL statement which should return a count query from the database, see the example above.Source:show|on GitHub# File activerecord/lib/active_record/querying.rb, line 109defcount_by_sql(sql)with_connectiondo|c|c.select_value(sanitize_sql(sql),"#{name} Count").to_iendendfind_by_sql(sql, binds = [], preparable: nil, allow_retry: false, &block)LinkExecutes a custom SQL query against your database and returns all the results. The results will be returned as an array, with the requested columns encapsulated as attributes of the model you call this method from. For example, if you callProduct.find_by_sql, then the results will be returned in aProductobject with the attributes you specified in the SQL query.If you call a complicated SQL query which spans multiple tables, the columns specified by the SELECT will be attributes of the model, whether or not they are columns of the corresponding table.Thesqlparameter is a full SQL query as a string. It will be called as is; there will be no database agnostic conversions performed. This should be a last resort because using database-specific terms will lock you into using that particular database engine, or require you to change your call if you switch engines.# A simple SQL query spanning multiple tables
Post.find_by_sql "SELECT p.title, c.author FROM posts p, comments c WHERE p.id = c.post_id"
# => [#<Post:0x36bff9c @attributes={"title"=>"Ruby Meetup", "author"=>"Quentin"}>, ...]You can use the same string replacement techniques as you can withActiveRecord::QueryMethods#where:Post.find_by_sql ["SELECT title FROM posts WHERE author = ? AND created > ?", author_id, start_date]
Post.find_by_sql ["SELECT body FROM comments WHERE author = :user_id OR approved_by = :user_id", { :user_id => user_id }]Note that building your own SQL query string from user input may expose your application to injection attacks (guides.rubyonrails.org/security.html#sql-injection).Source:show|on GitHub# File activerecord/lib/active_record/querying.rb, line 51deffind_by_sql(sql,binds= [],preparable:nil,allow_retry:false,&block)result=with_connectiondo|c|_query_by_sql(c,sql,binds,preparable:preparable,allow_retry:allow_retry)end_load_from_sql(result,&block)end