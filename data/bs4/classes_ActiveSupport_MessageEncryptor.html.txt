Active Support Message EncryptorMessageEncryptoris a simple way to encrypt values which get stored somewhere you donât trust.The cipher text and initialization vector are base64 encoded and returned to you.This can be used in situations similar to theMessageVerifier, but where you donât want users to be able to determine the value of the payload.len   = ActiveSupport::MessageEncryptor.key_len
salt  = SecureRandom.random_bytes(len)
key   = ActiveSupport::KeyGenerator.new('password').generate_key(salt, len) # => "\x89\xE0\x156\xAC..."
crypt = ActiveSupport::MessageEncryptor.new(key)                            # => #<ActiveSupport::MessageEncryptor ...>
encrypted_data = crypt.encrypt_and_sign('my secret data')                   # => "NlFBTTMwOUV5UlA1QlNEN2xkY2d6eThYWWh..."
crypt.decrypt_and_verify(encrypted_data)                                    # => "my secret data"Thedecrypt_and_verifymethod will raise anActiveSupport::MessageEncryptor::InvalidMessageexception if the data provided cannot be decrypted or verified.crypt.decrypt_and_verify('not encrypted data') # => ActiveSupport::MessageEncryptor::InvalidMessageConfining messages to a specific purposeBy default any message can be used throughout your app. But they can also be confined to a specific:purpose.token = crypt.encrypt_and_sign("this is the chair", purpose: :login)Then that same purpose must be passed when verifying to get the data back out:crypt.decrypt_and_verify(token, purpose: :login)    # => "this is the chair"
crypt.decrypt_and_verify(token, purpose: :shipping) # => nil
crypt.decrypt_and_verify(token)                     # => nilLikewise, if a message has no purpose it wonât be returned when verifying with a specific purpose.token = crypt.encrypt_and_sign("the conversation is lively")
crypt.decrypt_and_verify(token, purpose: :scare_tactics) # => nil
crypt.decrypt_and_verify(token)                          # => "the conversation is lively"Making messages expireBy default messages last forever and verifying one year from now will still return the original value. But messages can be set to expire at a given time with:expires_inor:expires_at.crypt.encrypt_and_sign(parcel, expires_in: 1.month)
crypt.encrypt_and_sign(doowad, expires_at: Time.now.end_of_year)Then the messages can be verified and returned up to the expire time. Thereafter, verifying returnsnil.Rotating keysMessageEncryptoralso supports rotating out old configurations by falling back to a stack of encryptors. Callrotateto build and add an encryptor sodecrypt_and_verifywill also try the fallback.By default any rotated encryptors use the values of the primary encryptor unless specified otherwise.Youâd give your encryptor the new defaults:crypt = ActiveSupport::MessageEncryptor.new(@secret, cipher: "aes-256-gcm")Then gradually rotate the old values out by adding them as fallbacks. Any message generated with the old values will then work until the rotation is removed.crypt.rotate old_secret            # Fallback to an old secret instead of @secret.
crypt.rotate cipher: "aes-256-cbc" # Fallback to an old cipher instead of aes-256-gcm.Though if both the secret and the cipher was changed at the same time, the above should be combined into:crypt.rotate old_secret, cipher: "aes-256-cbc"NamespaceCLASSActiveSupport::MessageEncryptor::InvalidMessageMethodsDdecrypt_and_verifyEencrypt_and_signKkey_lenNnewConstantsOpenSSLCipherError=OpenSSL::Cipher::CipherErrorClass Public methodskey_len(cipher = default_cipher)LinkGiven a cipher, returns the key length of the cipher to help generate the key of desired sizeSource:show|on GitHub# File activesupport/lib/active_support/message_encryptor.rb, line 252defself.key_len(cipher=default_cipher)OpenSSL::Cipher.new(cipher).key_lenendnew(secret, sign_secret = nil, **options)LinkInitialize a newMessageEncryptor.secretmust be at least as long as the cipher key size. For the default âaes-256-gcmâ cipher, this is 256 bits. If you are using a user-entered secret, you can generate a suitable key by usingActiveSupport::KeyGeneratoror a similar key derivation function.The first additional parameter is used as the signature key forMessageVerifier. This allows you to specify keys to encrypt and sign data. Ignored when using an AEAD cipher like âaes-256-gcmâ.ActiveSupport::MessageEncryptor.new('secret', 'signature_secret')Options:cipherCipher to use. Can be any cipher returned byOpenSSL::Cipher.ciphers. Default is âaes-256-gcmâ.:digestDigestused for signing. Ignored when using an AEAD cipher like âaes-256-gcmâ.:serializerThe serializer used to serialize message data. You can specify any object that responds todumpandload, or you can choose from several preconfigured serializers::marshal,:json_allow_marshal,:json,:message_pack_allow_marshal,:message_pack.The preconfigured serializers include a fallback mechanism to support multiple deserialization formats. For example, the:marshalserializer will serialize usingMarshal, but can deserialize usingMarshal,ActiveSupport::JSON, orActiveSupport::MessagePack. This makes it easy to migrate between serializers.The:marshal,:json_allow_marshal, and:message_pack_allow_marshalserializers support deserializing usingMarshal, but the others do not. Beware thatMarshalis a potential vector for deserialization attacks in cases where a message signing secret has been leaked.If possible, choose a serializer that does not supportMarshal.The:message_packand:message_pack_allow_marshalserializers useActiveSupport::MessagePack, which can roundtrip some Ruby types that are not supported byJSON, and may provide improved performance. However, these require themsgpackgem.When using Rails, the default depends onconfig.active_support.message_serializer. Otherwise, the default is:marshal.:url_safeBy default,MessageEncryptorgenerates RFC 4648 compliant strings which are not URL-safe. In other words, they can contain â+â and â/â. If you want to generate URL-safe strings (in compliance with âBase 64 Encoding with URL and Filename Safe Alphabetâ in RFC 4648), you can passtrue.:force_legacy_metadata_serializerWhether to use the legacy metadata serializer, which serializes the message first, then wraps it in an envelope which is also serialized. This was the default in Rails 7.0 and below.If you donât pass a truthy value, the default is set usingconfig.active_support.use_message_serializer_for_metadata.Source:show|on GitHub# File activesupport/lib/active_support/message_encryptor.rb, line 183definitialize(secret,sign_secret=nil,**options)super(**options)@secret=secret@cipher=options[:cipher]||self.class.default_cipher@aead_mode=new_cipher.authenticated?@verifier=if!@aead_modeMessageVerifier.new(sign_secret||secret,**options,serializer:NullSerializer)endendInstance Public methodsdecrypt_and_verify(message, **options)LinkDecrypt and verify a message. We need to verify the message in order to avoid padding attacks. Reference:www.limited-entropy.com/padding-oracle-attacks/.Options:purposeThe purpose that the message was generated with. If the purpose does not match,decrypt_and_verifywill returnnil.message = encryptor.encrypt_and_sign("hello", purpose: "greeting")
encryptor.decrypt_and_verify(message, purpose: "greeting") # => "hello"
encryptor.decrypt_and_verify(message)                      # => nil

message = encryptor.encrypt_and_sign("bye")
encryptor.decrypt_and_verify(message)                      # => "bye"
encryptor.decrypt_and_verify(message, purpose: "greeting") # => nilSource:show|on GitHub# File activesupport/lib/active_support/message_encryptor.rb, line 241defdecrypt_and_verify(message,**options)catch_and_raise:invalid_message_format,as:InvalidMessagedocatch_and_raise:invalid_message_serialization,as:InvalidMessagedocatch_and_ignore:invalid_message_contentdoread_message(message,**options)endendendendencrypt_and_sign(value, **options)LinkEncrypt and sign a message. We need to sign the message in order to avoid padding attacks. Reference:www.limited-entropy.com/padding-oracle-attacks/.Options:expires_atThe datetime at which the message expires. After this datetime, verification of the message will fail.message = encryptor.encrypt_and_sign("hello", expires_at: Time.now.tomorrow)
encryptor.decrypt_and_verify(message) # => "hello"
# 24 hours later...
encryptor.decrypt_and_verify(message) # => nil:expires_inThe duration for which the message is valid. After this duration has elapsed, verification of the message will fail.message = encryptor.encrypt_and_sign("hello", expires_in: 24.hours)
encryptor.decrypt_and_verify(message) # => "hello"
# 24 hours later...
encryptor.decrypt_and_verify(message) # => nil:purposeThe purpose of the message. If specified, the same purpose must be specified when verifying the message; otherwise, verification will fail. (Seedecrypt_and_verify.)Source:show|on GitHub# File activesupport/lib/active_support/message_encryptor.rb, line 220defencrypt_and_sign(value,**options)create_message(value,**options)end