NamespaceMODULEActionDispatch::Routing::Mapper::BaseMODULEActionDispatch::Routing::Mapper::ConcernsMODULEActionDispatch::Routing::Mapper::CustomUrlsMODULEActionDispatch::Routing::Mapper::HttpHelpersMODULEActionDispatch::Routing::Mapper::ResourcesMODULEActionDispatch::Routing::Mapper::ScopingMethodsNnormalize_name,normalize_pathIncluded ModulesActionDispatch::Routing::Mapper::BaseActionDispatch::Routing::Mapper::HttpHelpersActionDispatch::Routing::RedirectionActionDispatch::Routing::Mapper::ScopingActionDispatch::Routing::Mapper::ConcernsActionDispatch::Routing::Mapper::ResourcesActionDispatch::Routing::Mapper::CustomUrlsConstantsURL_OPTIONS=[:protocol, :subdomain, :domain, :host, :port]Class Public methodsnormalize_name(name)LinkSource:show|on GitHub# File actionpack/lib/action_dispatch/routing/mapper.rb, line 429defself.normalize_name(name)normalize_path(name)[1..-1].tr("/","_")endnormalize_path(path)LinkInvokes Journey::Router::Utils.normalize_path, then ensures that /(:locale) becomes (/:locale). Except for root cases, where the former is the correct one.Source:show|on GitHub# File actionpack/lib/action_dispatch/routing/mapper.rb, line 414defself.normalize_path(path)path=Journey::Router::Utils.normalize_path(path)# the path for a root URL at this point can be something like# "/(/:locale)(/:platform)/(:browser)", and we would want# "/(:locale)(/:platform)(/:browser)" reverse "/(", "/((" etc to "(/", "((/" etcpath.gsub!(%r{/(\(+)/?},'\1/')# if a path is all optional segments, change the leading "(/" back to "/(" so it# evaluates to "/" when interpreted with no options. Unless, however, at least# one secondary segment consists of a static part, ex.# "(/:locale)(/pages/:page)"path.sub!(%r{^(\(+)/},'/\1')if%r{^(\(+[^)]+\))(\(+/:[^)]+\))*$}.match?(path)pathend