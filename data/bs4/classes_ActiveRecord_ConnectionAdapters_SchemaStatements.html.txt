MethodsAadd_belongs_to,add_check_constraint,add_column,add_foreign_key,add_index,add_reference,add_timestamps,assume_migrated_upto_versionBbuild_create_table_definitionCchange_column,change_column_comment,change_column_default,change_column_null,change_table,change_table_comment,check_constraint_exists?,check_constraints,column_exists?,columns,create_join_table,create_tableDdata_source_exists?,data_sources,drop_join_table,drop_tableFforeign_key_exists?,foreign_keysIindex_exists?,index_name_exists?,indexesMmax_index_name_sizeNnative_database_typesOoptions_include_default?Pprimary_keyRremove_belongs_to,remove_check_constraint,remove_column,remove_columns,remove_foreign_key,remove_index,remove_reference,remove_timestamps,rename_column,rename_index,rename_tableTtable_alias_for,table_comment,table_exists?,table_options,tablesUuse_foreign_keys?Vview_exists?,viewsInstance Public methodsadd_belongs_to(table_name, ref_name, **options)LinkAlias for:add_referenceadd_check_constraint(table_name, expression, if_not_exists: false, **options)LinkAdds a new check constraint to the table.expressionis aStringrepresentation of verifiable boolean condition.add_check_constraint :products, "price > 0", name: "price_check"generates:ALTER TABLE "products" ADD CONSTRAINT price_check CHECK (price > 0)Theoptionshash can include the following keys::nameThe constraint name. Defaults tochk_rails_<identifier>.:if_not_existsSilently ignore if the constraint already exists, rather than raise an error.:validate(PostgreSQL only) Specify whether or not the constraint should be validated. Defaults totrue.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1272defadd_check_constraint(table_name,expression,if_not_exists:false,**options)returnunlesssupports_check_constraints?options=check_constraint_options(table_name,expression,options)returnifif_not_exists&&check_constraint_exists?(table_name,**options)at=create_alter_table(table_name)at.add_check_constraint(expression,options)executeschema_creation.accept(at)endadd_column(table_name, column_name, type, **options)LinkAdd a newtypecolumn namedcolumn_nametotable_name.SeeActiveRecord::ConnectionAdapters::TableDefinition.column.Thetypeparameter is normally one of the migrations native types, which is one of the following::primary_key,:string,:text,:integer,:bigint,:float,:decimal,:numeric,:datetime,:time,:date,:binary,:blob,:boolean.You may use a type not in this list as long as it is supported by your database (for example, âpolygonâ inMySQL), but this will not be database agnostic and should usually be avoided.Available options are (none of these exists by default)::comment- Specifies the comment for the column. This option is ignored by some backends.:collation- Specifies the collation for a:stringor:textcolumn. If not specified, the column will have the same collation as the table.:default- The columnâs default value. UsenilforNULL.:limit- Requests a maximum column length. This is the number of characters for a:stringcolumn and number of bytes for:text,:binary,:blob, and:integercolumns. This option is ignored by some backends.:null- Allows or disallowsNULLvalues in the column.:precision- Specifies the precision for the:decimal,:numeric,:datetime, and:timecolumns.:scale- Specifies the scale for the:decimaland:numericcolumns.:if_not_exists- Specifies if the column already exists to not try to re-add it. This will avoid duplicate column errors.Note: The precision is the total number of significant digits, and the scale is the number of digits that can be stored following the decimal point. For example, the number 123.45 has a precision of 5 and a scale of 2. A decimal with a precision of 5 and a scale of 2 can range from -999.99 to 999.99.Please be aware of different RDBMS implementations behavior with:decimalcolumns:The SQL standard says the default scale should be 0,:scale<=:precision, and makes no comments about the requirements of:precision.MySQL::precision[1..65],:scale[0..30]. Default is (10,0).PostgreSQL::precision[1..infinity],:scale[0..infinity]. No default.SQLite3: No restrictions on:precisionand:scale, but the maximum supported:precisionis 16. No default.Oracle::precision[1..38],:scale[-84..127]. Default is (38,0).SqlServer::precision[1..38],:scale[0..38]. Default (38,0).Examplesadd_column(:users, :picture, :binary, limit: 2.megabytes)
# ALTER TABLE "users" ADD "picture" blob(2097152)

add_column(:articles, :status, :string, limit: 20, default: 'draft', null: false)
# ALTER TABLE "articles" ADD "status" varchar(20) DEFAULT 'draft' NOT NULL

add_column(:answers, :bill_gates_money, :decimal, precision: 15, scale: 2)
# ALTER TABLE "answers" ADD "bill_gates_money" decimal(15,2)

add_column(:measurements, :sensor_reading, :decimal, precision: 30, scale: 20)
# ALTER TABLE "measurements" ADD "sensor_reading" decimal(30,20)

# While :scale defaults to zero on most databases, it
# probably wouldn't hurt to include it.
add_column(:measurements, :huge_integer, :decimal, precision: 30)
# ALTER TABLE "measurements" ADD "huge_integer" decimal(30)

# Defines a column that stores an array of a type.
add_column(:users, :skills, :text, array: true)
# ALTER TABLE "users" ADD "skills" text[]

# Defines a column with a database-specific type.
add_column(:shapes, :triangle, 'polygon')
# ALTER TABLE "shapes" ADD "triangle" polygon

# Ignores the method call if the column exists
add_column(:shapes, :triangle, 'polygon', if_not_exists: true)Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 625defadd_column(table_name,column_name,type,**options)add_column_def=build_add_column_definition(table_name,column_name,type,**options)returnunlessadd_column_defexecuteschema_creation.accept(add_column_def)endadd_foreign_key(from_table, to_table, **options)LinkAdds a new foreign key.from_tableis the table with the key column,to_tablecontains the referenced primary key.The foreign key will be named after the following pattern:fk_rails_<identifier>.identifieris a 10 character long string which is deterministically generated from thefrom_tableandcolumn. A custom name can be specified with the:nameoption.Creating a simple foreign keyadd_foreign_key :articles, :authorsgenerates:ALTER TABLE "articles" ADD CONSTRAINT fk_rails_e74ce85cbc FOREIGN KEY ("author_id") REFERENCES "authors" ("id")Creating a foreign key, ignoring method call if the foreign key existsadd_foreign_key(:articles, :authors, if_not_exists: true)Creating a foreign key on a specific columnadd_foreign_key :articles, :users, column: :author_id, primary_key: "lng_id"generates:ALTER TABLE "articles" ADD CONSTRAINT fk_rails_58ca3d3a82 FOREIGN KEY ("author_id") REFERENCES "users" ("lng_id")Creating a composite foreign keyAssuming "carts" table has "(shop_id, user_id)" as a primary key.

add_foreign_key :orders, :carts, primary_key: [:shop_id, :user_id]generates:ALTER TABLE "orders" ADD CONSTRAINT fk_rails_6f5e4cb3a4 FOREIGN KEY ("cart_shop_id", "cart_user_id") REFERENCES "carts" ("shop_id", "user_id")Creating a cascading foreign keyadd_foreign_key :articles, :authors, on_delete: :cascadegenerates:ALTER TABLE "articles" ADD CONSTRAINT fk_rails_e74ce85cbc FOREIGN KEY ("author_id") REFERENCES "authors" ("id") ON DELETE CASCADETheoptionshash can include the following keys::columnThe foreign key column name onfrom_table. Defaults toto_table.singularize + "_id". Pass an array to create a composite foreign key.:primary_keyThe primary key column name onto_table. Defaults toid. Pass an array to create a composite foreign key.:nameThe constraint name. Defaults tofk_rails_<identifier>.:on_deleteAction that happensON DELETE. Valid values are:nullify,:cascade, and:restrict:on_updateAction that happensON UPDATE. Valid values are:nullify,:cascade, and:restrict:if_not_existsSpecifies if the foreign key already exists to not try to re-add it. This will avoid duplicate column errors.:validate(PostgreSQL only) Specify whether or not the constraint should be validated. Defaults totrue.:deferrable(PostgreSQL only) Specify whether or not the foreign key should be deferrable. Valid values are booleans or:deferredor:immediateto specify the default behavior. Defaults tofalse.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1152defadd_foreign_key(from_table,to_table,**options)returnunlessuse_foreign_keys?returnifoptions[:if_not_exists]==true&&foreign_key_exists?(from_table,to_table,**options.slice(:column))options=foreign_key_options(from_table,to_table,options)at=create_alter_tablefrom_tableat.add_foreign_keyto_table,optionsexecuteschema_creation.accept(at)endadd_index(table_name, column_name, **options)LinkAdds a new index to the table.column_namecan be a singleSymbol, or anArrayof Symbols.The index will be named after the table and the column name(s), unless you pass:nameas an option.Creating a simple indexadd_index(:suppliers, :name)generates:CREATE INDEX index_suppliers_on_name ON suppliers(name)Creating a index which already existsadd_index(:suppliers, :name, if_not_exists: true)generates:CREATE INDEX IF NOT EXISTS index_suppliers_on_name ON suppliers(name)Note: Not supported byMySQL.Creating a unique indexadd_index(:accounts, [:branch_id, :party_id], unique: true)generates:CREATE UNIQUE INDEX index_accounts_on_branch_id_and_party_id ON accounts(branch_id, party_id)Creating a named indexadd_index(:accounts, [:branch_id, :party_id], unique: true, name: 'by_branch_party')generates:CREATE UNIQUE INDEX by_branch_party ON accounts(branch_id, party_id)Creating an index with specific key lengthadd_index(:accounts, :name, name: 'by_name', length: 10)generates:CREATE INDEX by_name ON accounts(name(10))Creating an index with specific key lengths for multiple keysadd_index(:accounts, [:name, :surname], name: 'by_name_surname', length: {name: 10, surname: 15})generates:CREATE INDEX by_name_surname ON accounts(name(10), surname(15))Note: only supported byMySQLCreating an index with a sort order (desc or asc, asc is the default)add_index(:accounts, [:branch_id, :party_id, :surname], name: 'by_branch_desc_party', order: {branch_id: :desc, party_id: :asc})generates:CREATE INDEX by_branch_desc_party ON accounts(branch_id DESC, party_id ASC, surname)Note:MySQLonly supports index order from 8.0.1 onwards (earlier versions accepted the syntax but ignored it).Creating a partial indexadd_index(:accounts, [:branch_id, :party_id], unique: true, where: "active")generates:CREATE UNIQUE INDEX index_accounts_on_branch_id_and_party_id ON accounts(branch_id, party_id) WHERE activeNote: Partial indexes are only supported for PostgreSQL and SQLite.Creating an index that includes additional columnsadd_index(:accounts, :branch_id,  include: :party_id)generates:CREATE INDEX index_accounts_on_branch_id ON accounts USING btree(branch_id) INCLUDE (party_id)Note: only supported by PostgreSQL.Creating an index with a specific methodadd_index(:developers, :name, using: 'btree')generates:CREATE INDEX index_developers_on_name ON developers USING btree (name) -- PostgreSQL
CREATE INDEX index_developers_on_name USING btree ON developers (name) -- MySQLNote: only supported by PostgreSQL andMySQLCreating an index with a specific operator classadd_index(:developers, :name, using: 'gist', opclass: :gist_trgm_ops)
# CREATE INDEX developers_on_name ON developers USING gist (name gist_trgm_ops) -- PostgreSQL

add_index(:developers, [:name, :city], using: 'gist', opclass: { city: :gist_trgm_ops })
# CREATE INDEX developers_on_name_and_city ON developers USING gist (name, city gist_trgm_ops) -- PostgreSQL

add_index(:developers, [:name, :city], using: 'gist', opclass: :gist_trgm_ops)
# CREATE INDEX developers_on_name_and_city ON developers USING gist (name gist_trgm_ops, city gist_trgm_ops) -- PostgreSQLNote: only supported by PostgreSQLCreating an index with a specific typeadd_index(:developers, :name, type: :fulltext)generates:CREATE FULLTEXT INDEX index_developers_on_name ON developers (name) -- MySQLNote: only supported byMySQL.Creating an index with a specific algorithmadd_index(:developers, :name, algorithm: :concurrently)
# CREATE INDEX CONCURRENTLY developers_on_name on developers (name) -- PostgreSQL

add_index(:developers, :name, algorithm: :inplace)
# CREATE INDEX `index_developers_on_name` ON `developers` (`name`) ALGORITHM = INPLACE -- MySQLNote: only supported by PostgreSQL andMySQL.Concurrently adding an index is not supported in a transaction.For more information see theâTransactional Migrationsâ section.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 894defadd_index(table_name,column_name,**options)create_index=build_create_index_definition(table_name,column_name,**options)executeschema_creation.accept(create_index)endadd_reference(table_name, ref_name, **options)LinkAdds a reference. The reference column is a bigint by default, the:typeoption can be used to specify a different type. Optionally adds a_typecolumn, if:polymorphicoption is provided.Theoptionshash can include the following keys::typeThe reference column type. Defaults to:bigint.:indexAdd an appropriate index. Defaults to true. Seeadd_indexfor usage of this option.:foreign_keyAdd an appropriate foreign key constraint. Defaults to false, pass true to add. In case the join table canât be inferred from the association pass:to_tablewith the appropriate table name.:polymorphicWhether an additional_typecolumn should be added. Defaults to false.:nullWhether the column allows nulls. Defaults to true.Create a user_id bigint column without an indexadd_reference(:products, :user, index: false)Create a user_id string columnadd_reference(:products, :user, type: :string)Create supplier_id, supplier_type columnsadd_reference(:products, :supplier, polymorphic: true)Create a supplier_id column with a unique indexadd_reference(:products, :supplier, index: { unique: true })Create a supplier_id column with a named indexadd_reference(:products, :supplier, index: { name: "my_supplier_index" })Create a supplier_id column and appropriate foreign keyadd_reference(:products, :supplier, foreign_key: true)Create a supplier_id column and a foreign key to the firms tableadd_reference(:products, :supplier, foreign_key: { to_table: :firms })Also aliased as:add_belongs_toSource:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1042defadd_reference(table_name,ref_name,**options)ReferenceDefinition.new(ref_name,**options).add(table_name,self)endadd_timestamps(table_name, **options)LinkAdds timestamps (created_atandupdated_at) columns totable_name. Additional options (like:null) are forwarded toadd_column.add_timestamps(:suppliers, null: true)Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1432defadd_timestamps(table_name,**options)fragments=add_timestamps_for_alter(table_name,**options)execute"ALTER TABLE #{quote_table_name(table_name)} #{fragments.join(', ')}"endassume_migrated_upto_version(version)LinkSource:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1337defassume_migrated_upto_version(version)version=version.to_ism_table=quote_table_name(pool.schema_migration.table_name)migration_context=pool.migration_contextmigrated=migration_context.get_all_versionsversions=migration_context.migrations.map(&:version)unlessmigrated.include?(version)execute"INSERT INTO #{sm_table} (version) VALUES (#{quote(version)})"endinserting= (versions-migrated).select{|v|v<version}ifinserting.any?if(duplicate=inserting.detect{|v|inserting.count(v)>1})raise"Duplicate migration #{duplicate}. Please renumber your migrations to resolve the conflict."endexecuteinsert_versions_sql(inserting)endendbuild_create_table_definition(table_name, id: :primary_key, primary_key: nil, force: nil, **options)LinkReturns aTableDefinitionobject containing information about the table that would be created if the same arguments were passed tocreate_table. Seecreate_tablefor information about passing atable_name, and other additional options that can be passed.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 333defbuild_create_table_definition(table_name,id::primary_key,primary_key:nil,force:nil,**options)table_definition=create_table_definition(table_name,**options.extract!(*valid_table_definition_options,:_skip_validate_options))table_definition.set_primary_key(table_name,id,primary_key,**options.extract!(*valid_primary_key_options,:_skip_validate_options))yieldtable_definitionifblock_given?table_definitionendchange_column(table_name, column_name, type, **options)LinkChanges the columnâs definition according to the new options. SeeTableDefinition#columnfor details of the options you can use.change_column(:suppliers, :name, :string, limit: 80)
change_column(:accounts, :description, :text)Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 700defchange_column(table_name,column_name,type,**options)raiseNotImplementedError,"change_column is not implemented"endchange_column_comment(table_name, column_name, comment_or_changes)LinkChanges the comment for a column or removes it ifnil.Passing a hash containing:fromand:towill make this change reversible in migration:change_column_comment(:posts, :state, from: "old_comment", to: "new_comment")Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1510defchange_column_comment(table_name,column_name,comment_or_changes)raiseNotImplementedError,"#{self.class} does not support changing column comments"endchange_column_default(table_name, column_name, default_or_changes)LinkSets a new default value for a column:change_column_default(:suppliers, :qualification, 'new')
change_column_default(:accounts, :authorized, 1)Setting the default tonileffectively drops the default:change_column_default(:users, :email, nil)Passing a hash containing:fromand:towill make this change reversible in migration:change_column_default(:posts, :state, from: nil, to: "draft")Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 718defchange_column_default(table_name,column_name,default_or_changes)raiseNotImplementedError,"change_column_default is not implemented"endchange_column_null(table_name, column_name, null, default = nil)LinkSets or removes aNOT NULLconstraint on a column. Thenullflag indicates whether the value can beNULL. For examplechange_column_null(:users, :nickname, false)says nicknames cannot beNULL(adds the constraint), whereaschange_column_null(:users, :nickname, true)allows them to beNULL(drops the constraint).The method accepts an optional fourth argument to replace existingNULLs with some other value. Use that one when enabling the constraint if needed, since otherwise those rows would not be valid.Please note the fourth argument does not set a columnâs default.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 747defchange_column_null(table_name,column_name,null,default=nil)raiseNotImplementedError,"change_column_null is not implemented"endchange_table(table_name, base = self, **options)LinkA block for changing columns intable.# change_table() yields a Table instance
change_table(:suppliers) do |t|
  t.column :name, :string, limit: 60
  # Other column alterations here
endTheoptionshash can include the following keys::bulkSet this to true to make this a bulk alter query, such asALTER TABLE `users` ADD COLUMN age INT, ADD COLUMN birthdate DATETIME ...Defaults to false.Only supported on theMySQLand PostgreSQL adapter, ignored elsewhere.Add a columnchange_table(:suppliers) do |t|
  t.column :name, :string, limit: 60
endChange type of a columnchange_table(:suppliers) do |t|
  t.change :metadata, :json
endAdd 2 integer columnschange_table(:suppliers) do |t|
  t.integer :width, :height, null: false, default: 0
endAdd created_at/updated_at columnschange_table(:suppliers) do |t|
  t.timestamps
endAdd a foreign key columnchange_table(:suppliers) do |t|
  t.references :company
endCreates acompany_id(bigint)column.Add a polymorphic foreign key columnchange_table(:suppliers) do |t|
  t.belongs_to :company, polymorphic: true
endCreatescompany_type(varchar)andcompany_id(bigint)columns.Remove a columnchange_table(:suppliers) do |t|
  t.remove :company
endRemove several columnschange_table(:suppliers) do |t|
  t.remove :company_id
  t.remove :width, :height
endRemove an indexchange_table(:suppliers) do |t|
  t.remove_index :company_id
endSee alsoTablefor details on all of the various column transformations.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 501defchange_table(table_name,base=self,**options)ifsupports_bulk_alter?&&options[:bulk]recorder=ActiveRecord::Migration::CommandRecorder.new(self)yieldupdate_table_definition(table_name,recorder)bulk_change_table(table_name,recorder.commands)elseyieldupdate_table_definition(table_name,base)endendchange_table_comment(table_name, comment_or_changes)LinkChanges the comment for a table or removes it ifnil.Passing a hash containing:fromand:towill make this change reversible in migration:change_table_comment(:posts, from: "old_comment", to: "new_comment")Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1500defchange_table_comment(table_name,comment_or_changes)raiseNotImplementedError,"#{self.class} does not support changing table comments"endcheck_constraint_exists?(table_name, **options)LinkChecks to see if a check constraint exists on a table for a given check constraint definition.check_constraint_exists?(:products, name: "price_check")Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1321defcheck_constraint_exists?(table_name,**options)if!options.key?(:name)&&!options.key?(:expression)raiseArgumentError,"At least one of :name or :expression must be supplied"endcheck_constraint_for(table_name,**options).present?endcheck_constraints(table_name)LinkReturns an array of check constraints for the given table. The check constraints are represented as CheckConstraintDefinition objects.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1252defcheck_constraints(table_name)raiseNotImplementedErrorendcolumn_exists?(table_name, column_name, type = nil, **options)LinkChecks to see if a column exists in a given table.# Check a column exists
column_exists?(:suppliers, :name)

# Check a column exists of a particular type
#
# This works for standard non-casted types (eg. string) but is unreliable
# for types that may get cast to something else (eg. char, bigint).
column_exists?(:suppliers, :name, :string)

# Check a column exists with a specific definition
column_exists?(:suppliers, :name, :string, limit: 100)
column_exists?(:suppliers, :name, :string, default: 'default')
column_exists?(:suppliers, :name, :string, null: false)
column_exists?(:suppliers, :tax, :decimal, precision: 8, scale: 2)Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 132defcolumn_exists?(table_name,column_name,type=nil,**options)column_name=column_name.to_schecks= []checks<<lambda{|c|c.name==column_name}checks<<lambda{|c|c.type==type.to_symrescuenil}iftypecolumn_options_keys.eachdo|attr|checks<<lambda{|c|c.send(attr)==options[attr] }ifoptions.key?(attr)endcolumns(table_name).any?{|c|checks.all?{|check|check[c] } }endcolumns(table_name)LinkReturns an array ofColumnobjects for the table specified bytable_name.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 107defcolumns(table_name)table_name=table_name.to_sdefinitions=column_definitions(table_name)definitions.mapdo|field|new_column_from_field(table_name,field,definitions)endendcreate_join_table(table_1, table_2, column_options: {}, **options)LinkCreates a new join table with the name created using the lexical order of the first two arguments. These arguments can be aStringor aSymbol.# Creates a table called 'assemblies_parts' with no id.
create_join_table(:assemblies, :parts)You can pass anoptionshash which can include the following keys::table_nameSets the table name, overriding the default.:column_optionsAny extra options you want appended to the columns definition.:optionsAny extra options you want appended to the table definition.:temporaryMake a temporary table.:forceSet to true to drop the table before creating it. Defaults to false.Note thatcreate_join_tabledoes not create any indices by default; you can use its block form to do so yourself:create_join_table :products, :categories do |t|
  t.index :product_id
  t.index :category_id
endAdd a backend specific option to the generated SQL (MySQL)create_join_table(:assemblies, :parts, options: 'ENGINE=InnoDB DEFAULT CHARSET=utf8')generates:CREATE TABLE assemblies_parts (
  assembly_id bigint NOT NULL,
  part_id bigint NOT NULL,
) ENGINE=InnoDB DEFAULT CHARSET=utf8Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 380defcreate_join_table(table_1,table_2,column_options:{},**options)join_table_name=find_join_table_name(table_1,table_2,options)column_options.reverse_merge!(null:false,index:false)t1_ref,t2_ref= [table_1,table_2].map{|t|reference_name_for_table(t) }create_table(join_table_name,**options.merge!(id:false))do|td|td.referencest1_ref,**column_optionstd.referencest2_ref,**column_optionsyieldtdifblock_given?endendcreate_table(table_name, id: :primary_key, primary_key: nil, force: nil, **options, &block)LinkCreates a new table with the nametable_name.table_namemay either be aStringor aSymbol.There are two ways to work withcreate_table. You can use the block form or the regular form, like this:Block form# create_table() passes a TableDefinition object to the block.
# This form will not only create the table, but also columns for the
# table.

create_table(:suppliers) do |t|
  t.column :name, :string, limit: 60
  # Other fields here
endBlock form, with shorthand# You can also use the column types as method calls, rather than calling the column method.
create_table(:suppliers) do |t|
  t.string :name, limit: 60
  # Other fields here
endRegular form# Creates a table called 'suppliers' with no columns.
create_table(:suppliers)
# Add a column to 'suppliers'.
add_column(:suppliers, :name, :string, {limit: 60})Theoptionshash can include the following keys::idWhether to automatically add a primary key column. Defaults to true. Join tables forActiveRecord::Base.has_and_belongs_to_manyshould set it to false.ASymbolcan be used to specify the type of the generated primary key column.:primary_keyThe name of the primary key, if one is to be added automatically. Defaults toid. If:idis false, then this option is ignored.If an array is passed, a composite primary key will be created.Note that Active Record models will automatically detect their primary key. This can be avoided by usingself.primary_key=on the model to define the key explicitly.:optionsAny extra options you want appended to the table definition.:temporaryMake a temporary table.:forceSet to true to drop the table before creating it. Set to:cascadeto drop dependent objects as well. Defaults to false.:if_not_existsSet to true to avoid raising an error when the table already exists. Defaults to false.:asSQL to use to generate the table. When this option is used, the block is ignored, as are the:idand:primary_keyoptions.Add a backend specific option to the generated SQL (MySQL)create_table(:suppliers, options: 'ENGINE=InnoDB DEFAULT CHARSET=utf8mb4')generates:CREATE TABLE suppliers (
  id bigint auto_increment PRIMARY KEY
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4Rename the primary key columncreate_table(:objects, primary_key: 'guid') do |t|
  t.column :name, :string, limit: 80
endgenerates:CREATE TABLE objects (
  guid bigint auto_increment PRIMARY KEY,
  name varchar(80)
)Change the primary key column typecreate_table(:tags, id: :string) do |t|
  t.column :label, :string
endgenerates:CREATE TABLE tags (
  id varchar PRIMARY KEY,
  label varchar
)Create a composite primary keycreate_table(:orders, primary_key: [:product_id, :client_id]) do |t|
  t.belongs_to :product
  t.belongs_to :client
endgenerates:CREATE TABLE orders (
    product_id bigint NOT NULL,
    client_id bigint NOT NULL
);

ALTER TABLE ONLY "orders"
  ADD CONSTRAINT orders_pkey PRIMARY KEY (product_id, client_id);Do not add a primary key columncreate_table(:categories_suppliers, id: false) do |t|
  t.column :category_id, :bigint
  t.column :supplier_id, :bigint
endgenerates:CREATE TABLE categories_suppliers (
  category_id bigint,
  supplier_id bigint
)Create a temporary table based on a querycreate_table(:long_query, temporary: true,
  as: "SELECT * FROM orders INNER JOIN line_items ON order_id=orders.id")generates:CREATE TEMPORARY TABLE long_query AS
  SELECT * FROM orders INNER JOIN line_items ON order_id=orders.idSee alsoTableDefinition#columnfor details on how to create columns.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 293defcreate_table(table_name,id::primary_key,primary_key:nil,force:nil,**options,&block)validate_create_table_options!(options)validate_table_length!(table_name)unlessoptions[:_uses_legacy_table_name]ifforce&&options.key?(:if_not_exists)raiseArgumentError,"Options `:force` and `:if_not_exists` cannot be used simultaneously."endtd=build_create_table_definition(table_name,id:id,primary_key:primary_key,force:force,**options,&block)ifforcedrop_table(table_name,force:force,if_exists:true)elseschema_cache.clear_data_source_cache!(table_name.to_s)endresult=executeschema_creation.accept(td)unlesssupports_indexes_in_create?td.indexes.eachdo|column_name,index_options|add_index(table_name,column_name,**index_options,if_not_exists:td.if_not_exists)endendifsupports_comments?&&!supports_comments_in_create?iftable_comment=td.comment.presencechange_table_comment(table_name,table_comment)endtd.columns.eachdo|column|change_column_comment(table_name,column.name,column.comment)ifcolumn.comment.present?endendresultenddata_source_exists?(name)LinkChecks to see if the data sourcenameexists on the database.data_source_exists?(:ebooks)Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 44defdata_source_exists?(name)query_values(data_source_sql(name),"SCHEMA").any?ifname.present?rescueNotImplementedErrordata_sources.include?(name.to_s)enddata_sources()LinkReturns the relation names usable to back Active Record models. For most adapters this means alltablesandviews.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 34defdata_sourcesquery_values(data_source_sql,"SCHEMA")rescueNotImplementedErrortables|viewsenddrop_join_table(table_1, table_2, **options)LinkDrops the join table specified by the given arguments. Seecreate_join_tableanddrop_tablefor details.Although this command ignores the block if one is given, it can be helpful to provide one in a migrationâschangemethod so it can be reverted. In that case, the block will be used bycreate_join_table.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 418defdrop_join_table(table_1,table_2,**options)join_table_name=find_join_table_name(table_1,table_2,options)drop_table(join_table_name,**options)enddrop_table(table_name, **options)LinkDrops a table from the database.:forceSet to:cascadeto drop dependent objects as well. Defaults to false.:if_existsSet totrueto only drop the table if it exists. Defaults to false.Although this command ignores mostoptionsand the block if one is given, it can be helpful to provide these in a migrationâschangemethod so it can be reverted. In that case,optionsand the block will be used bycreate_table.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 531defdrop_table(table_name,**options)schema_cache.clear_data_source_cache!(table_name.to_s)execute"DROP TABLE#{' IF EXISTS' if options[:if_exists]} #{quote_table_name(table_name)}"endforeign_key_exists?(from_table, to_table = nil, **options)LinkChecks to see if a foreign key exists on a table for a given foreign key definition.# Checks to see if a foreign key exists.
foreign_key_exists?(:accounts, :branches)

# Checks to see if a foreign key on a specified column exists.
foreign_key_exists?(:accounts, column: :owner_id)

# Checks to see if a foreign key with a custom name exists.
foreign_key_exists?(:accounts, name: "special_fk_name")Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1216defforeign_key_exists?(from_table,to_table=nil,**options)foreign_key_for(from_table,to_table:to_table,**options).present?endforeign_keys(table_name)LinkReturns an array of foreign keys for the given table. The foreign keys are represented as ForeignKeyDefinition objects.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1082defforeign_keys(table_name)raiseNotImplementedError,"foreign_keys is not implemented"endindex_exists?(table_name, column_name, **options)LinkChecks to see if an index exists on a table for a given index definition.# Check an index exists
index_exists?(:suppliers, :company_id)

# Check an index on multiple columns exists
index_exists?(:suppliers, [:company_id, :company_type])

# Check a unique index exists
index_exists?(:suppliers, :company_id, unique: true)

# Check an index with a custom name exists
index_exists?(:suppliers, :company_id, name: "idx_company_id")

# Check a valid index exists (PostgreSQL only)
index_exists?(:suppliers, :company_id, valid: true)Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 102defindex_exists?(table_name,column_name,**options)indexes(table_name).any?{|i|i.defined_for?(column_name,**options) }endindex_name_exists?(table_name, index_name)LinkVerifies the existence of an index with a given name.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 990defindex_name_exists?(table_name,index_name)index_name=index_name.to_sindexes(table_name).detect{|i|i.name==index_name}endindexes(table_name)LinkReturns an array of indexes for the given table.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 81defindexes(table_name)raiseNotImplementedError,"#indexes is not implemented"endmax_index_name_size()LinkReturns the maximum length of an index name in bytes.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1566defmax_index_name_size62endnative_database_types()LinkReturns a hash of mappings from the abstract data types to the native database types. SeeTableDefinition#columnfor details on the recognized abstract data types.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 14defnative_database_types{}endoptions_include_default?(options)LinkSource:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1490defoptions_include_default?(options)options.include?(:default)&&!(options[:null]==false&&options[:default].nil?)endprimary_key(table_name)LinkReturns just a tableâs primary keySource:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 145defprimary_key(table_name)pk=primary_keys(table_name)pk=pk.firstunlesspk.size>1pkendremove_belongs_to(table_name, ref_name, foreign_key: false, polymorphic: false, **options)LinkAlias for:remove_referenceremove_check_constraint(table_name, expression = nil, if_exists: false, **options)LinkRemoves the given check constraint from the table. Removing a check constraint that does not exist will raise an error.remove_check_constraint :products, name: "price_check"To silently ignore a non-existent check constraint rather than raise an error, use theif_existsoption.remove_check_constraint :products, name: "price_check", if_exists: trueTheexpressionparameter will be ignored if present. It can be helpful to provide this in a migrationâschangemethod so it can be reverted. In that case,expressionwill be used byadd_check_constraint.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1303defremove_check_constraint(table_name,expression=nil,if_exists:false,**options)returnunlesssupports_check_constraints?returnifif_exists&&!check_constraint_exists?(table_name,**options)chk_name_to_delete=check_constraint_for!(table_name,expression:expression,**options).nameat=create_alter_table(table_name)at.drop_check_constraint(chk_name_to_delete)executeschema_creation.accept(at)endremove_column(table_name, column_name, type = nil, **options)LinkRemoves the column from the table definition.remove_column(:suppliers, :qualification)Thetypeandoptionsparameters will be ignored if present. It can be helpful to provide these in a migrationâschangemethod so it can be reverted. In that case,typeandoptionswill be used byadd_column. Depending on the database youâre using, indexes using this column may be automatically removed or modified to remove this column from the index.If the options provided include anif_existskey, it will be used to check if the column does not exist. This will silently ignore the migration rather than raising if the column was already used.remove_column(:suppliers, :qualification, if_exists: true)Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 688defremove_column(table_name,column_name,type=nil,**options)returnifoptions[:if_exists]==true&&!column_exists?(table_name,column_name)execute"ALTER TABLE #{quote_table_name(table_name)} #{remove_column_for_alter(table_name, column_name, type, **options)}"endremove_columns(table_name, *column_names, type: nil, **options)LinkRemoves the given columns from the table definition.remove_columns(:suppliers, :qualification, :experience)typeand other column options can be passed to make migration reversible.remove_columns(:suppliers, :qualification, :experience, type: :string, null: false)Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 664defremove_columns(table_name,*column_names,type:nil,**options)ifcolumn_names.empty?raiseArgumentError.new("You must specify at least one column name. Example: remove_columns(:people, :first_name)")endremove_column_fragments=remove_columns_for_alter(table_name,*column_names,type:type,**options)execute"ALTER TABLE #{quote_table_name(table_name)} #{remove_column_fragments.join(', ')}"endremove_foreign_key(from_table, to_table = nil, **options)LinkRemoves the given foreign key from the table. Any option parameters provided will be used to re-add the foreign key in case of a migration rollback. It is recommended that you provide any options used when creating the foreign key so that the migration can be reverted properly.Removes the foreign key onaccounts.branch_id.remove_foreign_key :accounts, :branchesRemoves the foreign key onaccounts.owner_id.remove_foreign_key :accounts, column: :owner_idRemoves the foreign key onaccounts.owner_id.remove_foreign_key :accounts, to_table: :ownersRemoves the foreign key namedspecial_fk_nameon theaccountstable.remove_foreign_key :accounts, name: :special_fk_nameChecks if the foreign key exists before trying to remove it. Will silently ignore indexes that donât exist.remove_foreign_key :accounts, :branches, if_exists: trueTheoptionshash accepts the same keys asSchemaStatements#add_foreign_keywith an addition of:to_tableThe name of the table that contains the referenced primary key.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1193defremove_foreign_key(from_table,to_table=nil,**options)returnunlessuse_foreign_keys?returnifoptions.delete(:if_exists)==true&&!foreign_key_exists?(from_table,to_table)fk_name_to_delete=foreign_key_for!(from_table,to_table:to_table,**options).nameat=create_alter_tablefrom_tableat.drop_foreign_keyfk_name_to_deleteexecuteschema_creation.accept(at)endremove_index(table_name, column_name = nil, **options)LinkRemoves the given index from the table.Removes the index onbranch_idin theaccountstable if exactly one such index exists.remove_index :accounts, :branch_idRemoves the index onbranch_idin theaccountstable if exactly one such index exists.remove_index :accounts, column: :branch_idRemoves the index onbranch_idandparty_idin theaccountstable if exactly one such index exists.remove_index :accounts, column: [:branch_id, :party_id]Removes the index namedby_branch_partyin theaccountstable.remove_index :accounts, name: :by_branch_partyRemoves the index onbranch_idnamedby_branch_partyin theaccountstable.remove_index :accounts, :branch_id, name: :by_branch_partyChecks if the index exists before trying to remove it. Will silently ignore indexes that donât exist.remove_index :accounts, if_exists: trueRemoves the index namedby_branch_partyin theaccountstableconcurrently.remove_index :accounts, name: :by_branch_party, algorithm: :concurrentlyNote: only supported by PostgreSQL.Concurrently removing an index is not supported in a transaction.For more information see theâTransactional Migrationsâ section.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 945defremove_index(table_name,column_name=nil,**options)returnifoptions[:if_exists]&&!index_exists?(table_name,column_name,**options)index_name=index_name_for_remove(table_name,column_name,options)execute"DROP INDEX #{quote_column_name(index_name)} ON #{quote_table_name(table_name)}"endremove_reference(table_name, ref_name, foreign_key: false, polymorphic: false, **options)LinkRemoves the reference(s). Also removes atypecolumn if one exists.Remove the referenceremove_reference(:products, :user, index: false)Remove polymorphic referenceremove_reference(:products, :supplier, polymorphic: true)Remove the reference with a foreign keyremove_reference(:products, :user, foreign_key: true)Also aliased as:remove_belongs_toSource:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1061defremove_reference(table_name,ref_name,foreign_key:false,polymorphic:false,**options)conditional_options=options.slice(:if_exists,:if_not_exists)ifforeign_keyreference_name=Base.pluralize_table_names?ref_name.to_s.pluralize:ref_nameifforeign_key.is_a?(Hash)foreign_key_options=foreign_key.merge(conditional_options)elseforeign_key_options= {to_table:reference_name,**conditional_options}endforeign_key_options[:column]||="#{ref_name}_id"remove_foreign_key(table_name,**foreign_key_options)endremove_column(table_name,"#{ref_name}_id",**conditional_options)remove_column(table_name,"#{ref_name}_type",**conditional_options)ifpolymorphicendremove_timestamps(table_name, **options)LinkRemoves the timestamp columns (created_atandupdated_at) from the table definition.remove_timestamps(:suppliers)Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1441defremove_timestamps(table_name,**options)remove_columnstable_name,:updated_at,:created_atendrename_column(table_name, column_name, new_column_name)LinkRenames a column.rename_column(:suppliers, :description, :name)Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 755defrename_column(table_name,column_name,new_column_name)raiseNotImplementedError,"rename_column is not implemented"endrename_index(table_name, old_name, new_name)LinkRenames an index.Rename theindex_people_on_last_nameindex toindex_users_on_last_name:rename_index :people, 'index_people_on_last_name', 'index_users_on_last_name'Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 959defrename_index(table_name,old_name,new_name)old_name=old_name.to_snew_name=new_name.to_svalidate_index_length!(table_name,new_name)# this is a naive implementation; some DBs may support this more efficiently (PostgreSQL, for instance)old_index_def=indexes(table_name).detect{|i|i.name==old_name}returnunlessold_index_defadd_index(table_name,old_index_def.columns,name:new_name,unique:old_index_def.unique)remove_index(table_name,name:old_name)endrename_table(table_name, new_name, **)LinkRenames a table.rename_table('octopuses', 'octopi')Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 515defrename_table(table_name,new_name,**)raiseNotImplementedError,"rename_table is not implemented"endtable_alias_for(table_name)LinkTruncates a table alias according to the limits of the current adapter.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 28deftable_alias_for(table_name)table_name[0...table_alias_length].tr(".","_")endtable_comment(table_name)LinkReturns the table comment thatâs stored in database metadata.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 23deftable_comment(table_name)nilendtable_exists?(table_name)LinkChecks to see if the tabletable_nameexists on the database.table_exists?(:developers)Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 59deftable_exists?(table_name)query_values(data_source_sql(table_name,type:"BASE TABLE"),"SCHEMA").any?iftable_name.present?rescueNotImplementedErrortables.include?(table_name.to_s)endtable_options(table_name)LinkSource:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 18deftable_options(table_name)nilendtables()LinkReturns an array of table names defined in the database.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 51deftablesquery_values(data_source_sql(type:"BASE TABLE"),"SCHEMA")enduse_foreign_keys?()LinkSource:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1518defuse_foreign_keys?supports_foreign_keys?&&foreign_keys_enabled?endview_exists?(view_name)LinkChecks to see if the viewview_nameexists on the database.view_exists?(:ebooks)Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 74defview_exists?(view_name)query_values(data_source_sql(view_name,type:"VIEW"),"SCHEMA").any?ifview_name.present?rescueNotImplementedErrorviews.include?(view_name.to_s)endviews()LinkReturns an array of view names defined in the database.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 66defviewsquery_values(data_source_sql(type:"VIEW"),"SCHEMA")end