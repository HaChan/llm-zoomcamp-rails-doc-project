Active Support InflectionsA singleton instance of this class is yielded byInflector.inflections, which can then be used to specify additional inflection rules. If passed an optional locale, rules for other languages can be specified. The default locale is:en. Only rules for English are provided.ActiveSupport::Inflector.inflections(:en) do |inflect|
  inflect.plural /^(ox)$/i, '\1\2en'
  inflect.singular /^(ox)en/i, '\1'

  inflect.irregular 'cactus', 'cacti'

  inflect.uncountable 'equipment'
endNew rules are added at the top. So in the example above, the irregular rule for cactus will now be the first of the pluralization and singularization rules that is runs. This guarantees that your rules run before any of the rules that may already have been loaded.NamespaceCLASSActiveSupport::Inflector::Inflections::UncountablesMethodsAacronymCclearHhumanIinstance,instance_or_fallback,irregularNnewPpluralSsingularUuncountableAttributes[R]acronyms[R]humans[R]plurals[R]singulars[R]uncountablesClass Public methodsinstance(locale = :en)LinkSource:show|on GitHub# File activesupport/lib/active_support/inflector/inflections.rb, line 65defself.instance(locale=:en)@__instance__[locale]||=newendinstance_or_fallback(locale)LinkSource:show|on GitHub# File activesupport/lib/active_support/inflector/inflections.rb, line 69defself.instance_or_fallback(locale)I18n.fallbacks[locale].eachdo|k|return@__instance__[k]if@__instance__.key?(k)endinstance(locale)endnew()LinkSource:show|on GitHub# File activesupport/lib/active_support/inflector/inflections.rb, line 80definitialize@plurals,@singulars,@uncountables,@humans,@acronyms= [], [],Uncountables.new, [], {}define_acronym_regex_patternsendInstance Public methodsacronym(word)LinkSpecifies a new acronym. An acronym must be specified as it will appear in a camelized string. An underscore string that contains the acronym will retain the acronym when passed tocamelize,humanize, ortitleize. A camelized string that contains the acronym will maintain the acronym when titleized or humanized, and will convert the acronym into a non-delimited single lowercase word when passed tounderscore.acronym 'HTML'
titleize 'html'     # => 'HTML'
camelize 'html'     # => 'HTML'
underscore 'MyHTML' # => 'my_html'The acronym, however, must occur as a delimited unit and not be part of another word for conversions to recognize it:acronym 'HTTP'
camelize 'my_http_delimited' # => 'MyHTTPDelimited'
camelize 'https'             # => 'Https', not 'HTTPs'
underscore 'HTTPS'           # => 'http_s', not 'https'

acronym 'HTTPS'
camelize 'https'   # => 'HTTPS'
underscore 'HTTPS' # => 'https'Note: Acronyms that are passed topluralizewill no longer be recognized, since the acronym will not occur as a delimited unit in the pluralized result. To work around this, you must specify the pluralized form as an acronym as well:acronym 'API'
camelize(pluralize('api')) # => 'Apis'

acronym 'APIs'
camelize(pluralize('api')) # => 'APIs'acronymmay be used to specify any word that contains an acronym or otherwise needs to maintain a non-standard capitalization. The only restriction is that the word must begin with a capital letter.acronym 'RESTful'
underscore 'RESTful'           # => 'restful'
underscore 'RESTfulController' # => 'restful_controller'
titleize 'RESTfulController'   # => 'RESTful Controller'
camelize 'restful'             # => 'RESTful'
camelize 'restful_controller'  # => 'RESTfulController'

acronym 'McDonald'
underscore 'McDonald' # => 'mcdonald'
camelize 'mcdonald'   # => 'McDonald'Source:show|on GitHub# File activesupport/lib/active_support/inflector/inflections.rb, line 142defacronym(word)@acronyms[word.downcase] =worddefine_acronym_regex_patternsendclear(scope = :all)LinkClears the loaded inflections within a given scope (default is:all). Give the scope as a symbol of the inflection type, the options are::plurals,:singulars,:uncountables,:humans,:acronyms.clear :all
clear :pluralsSource:show|on GitHub# File activesupport/lib/active_support/inflector/inflections.rb, line 231defclear(scope=:all)casescopewhen:allclear(:acronyms)clear(:plurals)clear(:singulars)clear(:uncountables)clear(:humans)when:acronyms@acronyms= {}define_acronym_regex_patternswhen:uncountables@uncountables=Uncountables.newwhen:plurals,:singulars,:humansinstance_variable_set"@#{scope}", []endendhuman(rule, replacement)LinkSpecifies a humanized form of a string by a regular expression rule or by a string mapping. When using a regular expression based replacement, the normal humanize formatting is called after the replacement. When a string is used, the human form should be specified as desired (example: âThe nameâ, not âthe_nameâ).human /_cnt$/i, '\1_count'
human 'legacy_col_person_name', 'Name'Source:show|on GitHub# File activesupport/lib/active_support/inflector/inflections.rb, line 220defhuman(rule,replacement)@humans.prepend([rule,replacement])endirregular(singular, plural)LinkSpecifies a new irregular that applies to both pluralization and singularization at the same time. This can only be used for strings, not regular expressions. You simply pass the irregular in singular and plural form.irregular 'cactus', 'cacti'
irregular 'person', 'people'Source:show|on GitHub# File activesupport/lib/active_support/inflector/inflections.rb, line 174defirregular(singular,plural)@uncountables.delete(singular)@uncountables.delete(plural)s0=singular[0]srest=singular[1..-1]p0=plural[0]prest=plural[1..-1]ifs0.upcase==p0.upcaseplural(/(#{s0})#{srest}$/i,'\1'+prest)plural(/(#{p0})#{prest}$/i,'\1'+prest)singular(/(#{s0})#{srest}$/i,'\1'+srest)singular(/(#{p0})#{prest}$/i,'\1'+srest)elseplural(/#{s0.upcase}(?i)#{srest}$/,p0.upcase+prest)plural(/#{s0.downcase}(?i)#{srest}$/,p0.downcase+prest)plural(/#{p0.upcase}(?i)#{prest}$/,p0.upcase+prest)plural(/#{p0.downcase}(?i)#{prest}$/,p0.downcase+prest)singular(/#{s0.upcase}(?i)#{srest}$/,s0.upcase+srest)singular(/#{s0.downcase}(?i)#{srest}$/,s0.downcase+srest)singular(/#{p0.upcase}(?i)#{prest}$/,s0.upcase+srest)singular(/#{p0.downcase}(?i)#{prest}$/,s0.downcase+srest)endendplural(rule, replacement)LinkSpecifies a new pluralization rule and its replacement. The rule can either be a string or a regular expression. The replacement should always be a string that may include references to the matched data from the rule.Source:show|on GitHub# File activesupport/lib/active_support/inflector/inflections.rb, line 151defplural(rule,replacement)@uncountables.delete(rule)ifrule.is_a?(String)@uncountables.delete(replacement)@plurals.prepend([rule,replacement])endsingular(rule, replacement)LinkSpecifies a new singularization rule and its replacement. The rule can either be a string or a regular expression. The replacement should always be a string that may include references to the matched data from the rule.Source:show|on GitHub# File activesupport/lib/active_support/inflector/inflections.rb, line 161defsingular(rule,replacement)@uncountables.delete(rule)ifrule.is_a?(String)@uncountables.delete(replacement)@singulars.prepend([rule,replacement])enduncountable(*words)LinkSpecifies words that are uncountable and should not be inflected.uncountable 'money'
uncountable 'money', 'information'
uncountable %w( money information rice )Source:show|on GitHub# File activesupport/lib/active_support/inflector/inflections.rb, line 208defuncountable(*words)@uncountables.add(words)end