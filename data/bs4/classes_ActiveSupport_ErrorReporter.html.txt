Active Support Error ReporterActiveSupport::ErrorReporteris a common interface for error reporting services.To rescue and report any unhandled error, you can use thehandlemethod:Rails.error.handle do
  do_something!
endIf an error is raised, it will be reported and swallowed.Alternatively, if you want to report the error but not swallow it, you can userecord:Rails.error.record do
  do_something!
endBoth methods can be restricted to handle only a specific error class:maybe_tags = Rails.error.handle(Redis::BaseError) { redis.get("tags") }NamespaceMODULEActiveSupport::ErrorReporter::TestHelperMethodsDdisableHhandleNnewRrecord,reportSset_context,subscribeUunexpected,unsubscribeConstantsDEFAULT_RESCUE=[StandardError].freezeDEFAULT_SOURCE="application"SEVERITIES=%i(error warning info)UnexpectedError=Class.new(Exception)Attributes[RW]debug_mode[RW]loggerClass Public methodsnew(*subscribers, logger: nil)LinkSource:show|on GitHub# File activesupport/lib/active_support/error_reporter.rb, line 35definitialize(*subscribers,logger:nil)@subscribers=subscribers.flatten@logger=logger@debug_mode=falseendInstance Public methodsdisable(subscriber)LinkPrevent a subscriber from being notified of errors for the duration of the block. You may pass in the subscriber itself, or its class.This can be helpful for error reporting service integrations, when they wish to handle any errors higher in the stack.Source:show|on GitHub# File activesupport/lib/active_support/error_reporter.rb, line 185defdisable(subscriber)disabled_subscribers= (ActiveSupport::IsolatedExecutionState[self]||=[])disabled_subscribers<<subscriberbeginyieldensuredisabled_subscribers.delete(subscriber)endendhandle(*error_classes, severity: :warning, context: {}, fallback: nil, source: DEFAULT_SOURCE)LinkEvaluates the given block, reporting and swallowing any unhandled error. If no error is raised, returns the return value of the block. Otherwise, returns the result offallback.call, orniliffallbackis not specified.# Will report a TypeError to all subscribers and return nil.
Rails.error.handle do
  1 + '1'
endCan be restricted to handle only specific error classes:maybe_tags = Rails.error.handle(Redis::BaseError) { redis.get("tags") }Options:severity- This value is passed along to subscribers to indicate how important the error report is. Can be:error,:warning, or:info. Defaults to:warning.:context- Extra information that is passed along to subscribers. For example:Rails.error.handle(context: { section: "admin" }) do
  # ...
end:fallback- A callable that provideshandleâs return value when an unhandled error is raised. For example:user = Rails.error.handle(fallback: -> { User.anonymous }) do
  User.find_by(params)
end:source- This value is passed along to subscribers to indicate the source of the error. Subscribers can use this value to ignore certain errors. Defaults to"application".Source:show|on GitHub# File activesupport/lib/active_support/error_reporter.rb, line 78defhandle(*error_classes,severity::warning,context:{},fallback:nil,source:DEFAULT_SOURCE)error_classes=DEFAULT_RESCUEiferror_classes.empty?yieldrescue*error_classes=>errorreport(error,handled:true,severity:severity,context:context,source:source)fallback.calliffallbackendrecord(*error_classes, severity: :error, context: {}, source: DEFAULT_SOURCE)LinkEvaluates the given block, reporting and re-raising any unhandled error. If no error is raised, returns the return value of the block.# Will report a TypeError to all subscribers and re-raise it.
Rails.error.record do
  1 + '1'
endCan be restricted to handle only specific error classes:tags = Rails.error.record(Redis::BaseError) { redis.get("tags") }Options:severity- This value is passed along to subscribers to indicate how important the error report is. Can be:error,:warning, or:info. Defaults to:error.:context- Extra information that is passed along to subscribers. For example:Rails.error.record(context: { section: "admin" }) do
  # ...
end:source- This value is passed along to subscribers to indicate the source of the error. Subscribers can use this value to ignore certain errors. Defaults to"application".Source:show|on GitHub# File activesupport/lib/active_support/error_reporter.rb, line 114defrecord(*error_classes,severity::error,context:{},source:DEFAULT_SOURCE)error_classes=DEFAULT_RESCUEiferror_classes.empty?yieldrescue*error_classes=>errorreport(error,handled:false,severity:severity,context:context,source:source)raiseendreport(error, handled: true, severity: handled ? :warning : :error, context: {}, source: DEFAULT_SOURCE)LinkReport an error directly to subscribers. You can use this method when the block-basedhandleandrecordmethods are not suitable.Rails.error.report(error)Source:show|on GitHub# File activesupport/lib/active_support/error_reporter.rb, line 210defreport(error,handled:true,severity:handled?:warning::error,context:{},source:DEFAULT_SOURCE)returniferror.instance_variable_defined?(:@__rails_error_reported)unlessSEVERITIES.include?(severity)raiseArgumentError,"severity must be one of #{SEVERITIES.map(&:inspect).join(", ")}, got: #{severity.inspect}"endfull_context=ActiveSupport::ExecutionContext.to_h.merge(context)disabled_subscribers=ActiveSupport::IsolatedExecutionState[self]@subscribers.eachdo|subscriber|unlessdisabled_subscribers&.any?{|s|s===subscriber}subscriber.report(error,handled:handled,severity:severity,context:full_context,source:source)endrescue=>subscriber_errorifloggerlogger.fatal("Error subscriber raised an error: #{subscriber_error.message} (#{subscriber_error.class})\n"+subscriber_error.backtrace.join("\n")
      )elseraiseendendunlesserror.frozen?error.instance_variable_set(:@__rails_error_reported,true)endnilendset_context(...)LinkUpdate the execution context that is accessible to error subscribers. Any context passed tohandle,record, orreportwill be merged with the context set here.Rails.error.set_context(section: "checkout", user_id: @user.id)Source:show|on GitHub# File activesupport/lib/active_support/error_reporter.rb, line 201defset_context(...)ActiveSupport::ExecutionContext.set(...)endsubscribe(subscriber)LinkRegister a new error subscriber. The subscriber must respond toreport(Exception, handled: Boolean, severity: (:error OR :warning OR :info), context: Hash, source: String)Thereportmethodshould neverraise an error.Source:show|on GitHub# File activesupport/lib/active_support/error_reporter.rb, line 161defsubscribe(subscriber)unlesssubscriber.respond_to?(:report)raiseArgumentError,"Error subscribers must respond to #report"end@subscribers<<subscriberendunexpected(error, severity: :warning, context: {}, source: DEFAULT_SOURCE)LinkEither report the given error when in production, or raise it when in development or test.When called in production, after the error is reported, this method will return nil and execution will continue.When called in development, the original error is wrapped in a different error class to ensure itâs not being rescued higher in the stack and will be surfaced to the developer.This method is intended for reporting violated assertions about preconditions, or similar cases that can and should be gracefully handled in production, but that arenât supposed to happen.The error can be either an exception instance or aString.example:

  def edit
    if published?
      Rails.error.unexpected("[BUG] Attempting to edit a published article, that shouldn't be possible")
      return false
    end
    # ...
  endSource:show|on GitHub# File activesupport/lib/active_support/error_reporter.rb, line 145defunexpected(error,severity::warning,context:{},source:DEFAULT_SOURCE)error=RuntimeError.new(error)iferror.is_a?(String)error.set_backtrace(caller(1))iferror.backtrace.nil?if@debug_moderaiseUnexpectedError,"#{error.class.name}: #{error.message}",error.backtrace,cause:errorelsereport(error,handled:true,severity:severity,context:context,source:source)endendunsubscribe(subscriber)LinkUnregister an error subscriber. Accepts either a subscriber or a class.subscriber = MyErrorSubscriber.new
Rails.error.subscribe(subscriber)

Rails.error.unsubscribe(subscriber)
# or
Rails.error.unsubscribe(MyErrorSubscriber)Source:show|on GitHub# File activesupport/lib/active_support/error_reporter.rb, line 176defunsubscribe(subscriber)@subscribers.delete_if{|s|subscriber===s}end