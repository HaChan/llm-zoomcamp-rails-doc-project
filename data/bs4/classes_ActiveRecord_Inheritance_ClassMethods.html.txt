MethodsAabstract_class?Bbase_class?Ccompute_typeDdescends_from_active_record?NnewPpolymorphic_class_for,polymorphic_name,primary_abstract_classSsti_class_for,sti_nameAttributes[RW]abstract_classSet this totrueif this is an abstract class (seeabstract_class?). If you are using inheritance with Active Record and donât want a class to be considered as part of the STI hierarchy, you must set this to true.ApplicationRecord, for example, is generated as an abstract class.Consider the following default behavior:Shape = Class.new(ActiveRecord::Base)
Polygon = Class.new(Shape)
Square = Class.new(Polygon)

Shape.table_name   # => "shapes"
Polygon.table_name # => "shapes"
Square.table_name  # => "shapes"
Shape.create!      # => #<Shape id: 1, type: nil>
Polygon.create!    # => #<Polygon id: 2, type: "Polygon">
Square.create!     # => #<Square id: 3, type: "Square">However, when usingabstract_class,Shapeis omitted from the hierarchy:class Shape < ActiveRecord::Base
  self.abstract_class = true
end
Polygon = Class.new(Shape)
Square = Class.new(Polygon)

Shape.table_name   # => nil
Polygon.table_name # => "polygons"
Square.table_name  # => "polygons"
Shape.create!      # => NotImplementedError: Shape is an abstract class and cannot be instantiated.
Polygon.create!    # => #<Polygon id: 1, type: nil>
Square.create!     # => #<Square id: 2, type: "Square">Note that in the above example, to disallow the creation of a plainPolygon, you should usevalidates :type, presence: true, instead of setting it as an abstract class. This way,Polygonwill stay in the hierarchy, and Active Record will continue to correctly derive the table name.[R]base_classReturns the first class in the inheritance hierarchy that descends from either an abstract class or fromActiveRecord::Base.Consider the following behaviour:class ApplicationRecord < ActiveRecord::Base
  self.abstract_class = true
end
class Shape < ApplicationRecord
  self.abstract_class = true
end
Polygon = Class.new(Shape)
Square = Class.new(Polygon)

ApplicationRecord.base_class # => ApplicationRecord
Shape.base_class # => Shape
Polygon.base_class # => Polygon
Square.base_class # => PolygonInstance Public methodsabstract_class?()LinkReturns whether this class is an abstract class or not.Source:show|on GitHub# File activerecord/lib/active_record/inheritance.rb, line 167defabstract_class?@abstract_class==trueendbase_class?()LinkReturns whether the class is a base class. Seebase_classfor more information.Source:show|on GitHub# File activerecord/lib/active_record/inheritance.rb, line 119defbase_class?base_class==selfenddescends_from_active_record?()LinkReturnstrueif this does not need STI type condition. Returnsfalseif STI type condition needs to be applied.Source:show|on GitHub# File activerecord/lib/active_record/inheritance.rb, line 82defdescends_from_active_record?ifself==Basefalseelsifsuperclass.abstract_class?superclass.descends_from_active_record?elsesuperclass==Base||!columns_hash.include?(inheritance_column)endendnew(attributes = nil, &block)LinkDetermines if one of the attributes passed in is the inheritance column, and if the inheritance column is attr accessible, it initializes an instance of the given subclass instead of the base class.Source:show|on GitHub# File activerecord/lib/active_record/inheritance.rb, line 56defnew(attributes=nil,&block)ifabstract_class?||self==BaseraiseNotImplementedError,"#{self} is an abstract class and cannot be instantiated."endif_has_attribute?(inheritance_column)subclass=subclass_from_attributes(attributes)ifsubclass.nil?&&scope_attributes=current_scope&.scope_for_createsubclass=subclass_from_attributes(scope_attributes)endifsubclass.nil?&&base_class?subclass=subclass_from_attributes(column_defaults)endendifsubclass&&subclass!=selfsubclass.new(attributes,&block)elsesuperendendpolymorphic_class_for(name)LinkReturns the class for the providedname.It is used to find the class correspondent to the value stored in the polymorphic type column.Source:show|on GitHub# File activerecord/lib/active_record/inheritance.rb, line 218defpolymorphic_class_for(name)ifstore_full_class_namename.constantizeelsecompute_type(name)endendpolymorphic_name()LinkReturns the value to be stored in the polymorphic type column for PolymorphicAssociations.Source:show|on GitHub# File activerecord/lib/active_record/inheritance.rb, line 211defpolymorphic_namestore_full_class_name?base_class.name:base_class.name.demodulizeendprimary_abstract_class()LinkSets the application record class for Active RecordThis is useful if your application uses a different class than ApplicationRecord for your primary abstract class. This class will share a database connection with Active Record. It is the class that connects to your primary database.Source:show|on GitHub# File activerecord/lib/active_record/inheritance.rb, line 177defprimary_abstract_classifActiveRecord.application_record_class&&ActiveRecord.application_record_class.name!=nameraiseArgumentError,"The `primary_abstract_class` is already set to #{ActiveRecord.application_record_class.inspect}. There can only be one `primary_abstract_class` in an application."endself.abstract_class=trueActiveRecord.application_record_class=selfendsti_class_for(type_name)LinkReturns the class for the providedtype_name.It is used to find the class correspondent to the value stored in the inheritance column.Source:show|on GitHub# File activerecord/lib/active_record/inheritance.rb, line 194defsti_class_for(type_name)ifstore_full_sti_class&&store_full_class_nametype_name.constantizeelsecompute_type(type_name)endrescueNameErrorraiseSubclassNotFound,"The single-table inheritance mechanism failed to locate the subclass: '#{type_name}'. "\"This error is raised because the column '#{inheritance_column}' is reserved for storing the class in case of inheritance. "\"Please rename this column if you didn't intend it to be used for storing the inheritance class "\"or overwrite #{name}.inheritance_column to use another column for that information. "\"If you wish to disable single-table inheritance for #{name} set "\"#{name}.inheritance_column to nil"endsti_name()LinkReturns the value to be stored in the inheritance column for STI.Source:show|on GitHub# File activerecord/lib/active_record/inheritance.rb, line 187defsti_namestore_full_sti_class&&store_full_class_name?name:name.demodulizeendInstance Protected methodscompute_type(type_name)LinkReturns the class type of the record using the current module as a prefix. So descendants of MyApp::Business::Account would appear as MyApp::Business::AccountSubclass.Source:show|on GitHub# File activerecord/lib/active_record/inheritance.rb, line 242defcompute_type(type_name)iftype_name.start_with?("::")# If the type is prefixed with a scope operator then we assume that# the type_name is an absolute reference.type_name.constantizeelsetype_candidate=@_type_candidates_cache[type_name]iftype_candidate&&type_constant=type_candidate.safe_constantizereturntype_constantend# Build a list of candidates to search forcandidates= []name.scan(/::|$/) {candidates.unshift"#{$`}::#{type_name}"}candidates<<type_namecandidates.eachdo|candidate|constant=candidate.safe_constantizeifcandidate==constant.to_s@_type_candidates_cache[type_name] =candidatereturnconstantendendraiseNameError.new("uninitialized constant #{candidates.first}",candidates.first)endend