NamespaceCLASSActionDispatch::Http::MimeNegotiation::InvalidTypeMethodsAacceptsCcontent_mime_typeFformat,format=,formats,formats=Nnegotiate_mimeSshould_apply_vary_header?Vvariant,variant=ConstantsBROWSER_LIKE_ACCEPTS=/,\s*\*\/\*|\*\/\*\s*,/We use normal content negotiation unless you include/in your list, in which case we assume youâre a browser and send HTML.RESCUABLE_MIME_FORMAT_ERRORS=[
ActionController::BadRequest,
ActionDispatch::Http::Parameters::ParseError,
]Instance Public methodsaccepts()LinkReturns the accepted MIME type for the request.Source:show|on GitHub# File actionpack/lib/action_dispatch/http/mime_negotiation.rb, line 42defacceptsfetch_header("action_dispatch.request.accepts")do|k|header=get_header("HTTP_ACCEPT").to_s.stripv=ifheader.empty?[content_mime_type]elseMime::Type.parse(header)endset_headerk,vrescue::Mime::Type::InvalidMimeType=>eraiseInvalidType,e.messageendendcontent_mime_type()LinkThe MIME type of the HTTP request, such asMime.Source:show|on GitHub# File actionpack/lib/action_dispatch/http/mime_negotiation.rb, line 24defcontent_mime_typefetch_header("action_dispatch.request.content_type")do|k|v=ifget_header("CONTENT_TYPE")=~/^([^,;]*)/Mime::Type.lookup($1.strip.downcase)elsenilendset_headerk,vrescue::Mime::Type::InvalidMimeType=>eraiseInvalidType,e.messageendendformat(_view_path = nil)LinkReturns the MIME type for the format used in the request.GET /posts/5.xml   | request.format => Mime[:xml]
GET /posts/5.xhtml | request.format => Mime[:html]
GET /posts/5       | request.format => Mime[:html] or Mime[:js], or request.accepts.firstSource:show|on GitHub# File actionpack/lib/action_dispatch/http/mime_negotiation.rb, line 63defformat(_view_path=nil)formats.first||Mime::NullType.instanceendformat=(extension)LinkSets the format by string extension, which can be used to force custom formats that are not controlled by the extension.class ApplicationController < ActionController::Base
  before_action :adjust_format_for_iphone

  private
    def adjust_format_for_iphone
      request.format = :iphone if request.env["HTTP_USER_AGENT"][/iPhone/]
    end
endSource:show|on GitHub# File actionpack/lib/action_dispatch/http/mime_negotiation.rb, line 115defformat=(extension)parameters[:format] =extension.to_sset_header"action_dispatch.request.formats", [Mime::Type.lookup_by_extension(parameters[:format])]endformats()LinkSource:show|on GitHub# File actionpack/lib/action_dispatch/http/mime_negotiation.rb, line 67defformatsfetch_header("action_dispatch.request.formats")do|k|v=ifparams_readable?Array(Mime[parameters[:format]])elsifuse_accept_header&&valid_accept_headeraccepts.dupelsifextension_format=format_from_path_extension[extension_format]elsifxhr?[Mime[:js]]else[Mime[:html]]endv.select!do|format|format.symbol||format.ref=="*/*"endset_headerk,vendendformats=(extensions)LinkSets the formats by string extensions. This differs fromformat=by allowing you to set multiple, ordered formats, which is useful when you want to have a fallback.In this example, the:iphoneformat will be used if itâs available, otherwise itâll fall back to the:htmlformat.class ApplicationController < ActionController::Base
  before_action :adjust_format_for_iphone_with_html_fallback

  private
    def adjust_format_for_iphone_with_html_fallback
      request.formats = [ :iphone, :html ] if request.env["HTTP_USER_AGENT"][/iPhone/]
    end
endSource:show|on GitHub# File actionpack/lib/action_dispatch/http/mime_negotiation.rb, line 135defformats=(extensions)parameters[:format] =extensions.first.to_sset_header"action_dispatch.request.formats",extensions.collect{|extension|Mime::Type.lookup_by_extension(extension)
  }endnegotiate_mime(order)LinkReturns the first MIME type that matches the provided array of MIME types.Source:show|on GitHub# File actionpack/lib/action_dispatch/http/mime_negotiation.rb, line 143defnegotiate_mime(order)formats.eachdo|priority|ifpriority==Mime::ALLreturnorder.firstelsiforder.include?(priority)returnpriorityendendorder.include?(Mime::ALL)?format:nilendshould_apply_vary_header?()LinkSource:show|on GitHub# File actionpack/lib/action_dispatch/http/mime_negotiation.rb, line 155defshould_apply_vary_header?!params_readable?&&use_accept_header&&valid_accept_headerendvariant()LinkSource:show|on GitHub# File actionpack/lib/action_dispatch/http/mime_negotiation.rb, line 100defvariant@variant||=ActiveSupport::ArrayInquirer.newendvariant=(variant)LinkSets the variant for template.Source:show|on GitHub# File actionpack/lib/action_dispatch/http/mime_negotiation.rb, line 90defvariant=(variant)variant=Array(variant)ifvariant.all?(Symbol)@variant=ActiveSupport::ArrayInquirer.new(variant)elseraiseArgumentError,"request.variant must be set to a Symbol or an Array of Symbols."endend