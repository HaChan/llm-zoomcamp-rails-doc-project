Action CableChannelBaseThe channel provides the basic structure of grouping behavior into logical units when communicating over the WebSocket connection. You can think of a channel like a form of controller, but one thatâs capable of pushing content to the subscriber in addition to simply responding to the subscriberâs direct requests.Channelinstances are long-lived. A channel object will be instantiated when the cable consumer becomes a subscriber, and then lives until the consumer disconnects. This may be seconds, minutes, hours, or even days. That means you have to take special care not to do anything silly in a channel that would balloon its memory footprint or whatever. The references are forever, so they wonât be released as is normally the case with a controller instance that gets thrown away after every request.Long-lived channels (and connections) also mean youâre responsible for ensuring that the data is fresh. If you hold a reference to a user record, but the name is changed while that reference is held, you may be sending stale data if you donât take precautions to avoid it.The upside of long-lived channel instances is that you can use instance variables to keep reference to objects that future subscriber requests can interact with. Hereâs a quick example:class ChatChannel < ApplicationCable::Channel
  def subscribed
    @room = Chat::Room[params[:room_number]]
  end

  def speak(data)
    @room.speak data, user: current_user
  end
endThe speak action simply uses the Chat::Room object that was created when the channel was first subscribed to by the consumer when that subscriber wants to say something in the room.Action processingUnlike subclasses ofActionController::Base, channels do not follow a RESTful constraint form for their actions. Instead, Action Cable operates through a remote-procedure call model. You can declare any public method on the channel (optionally taking adataargument), and this method is automatically exposed as callable to the client.Example:class AppearanceChannel < ApplicationCable::Channel
  def subscribed
    @connection_token = generate_connection_token
  end

  def unsubscribed
    current_user.disappear @connection_token
  end

  def appear(data)
    current_user.appear @connection_token, on: data['appearing_on']
  end

  def away
    current_user.away @connection_token
  end

  private
    def generate_connection_token
      SecureRandom.hex(36)
    end
endIn this example, the subscribed and unsubscribed methods are not callable methods, as they were already declared inActionCable::Channel::Base, but#appearand#awayare.#generate_connection_tokenis also not callable, since itâs a private method. Youâll see that appear accepts a data parameter, which it then uses as part of its model call.#awaydoes not, since itâs simply a trigger action.Also note that in this example,current_useris available because it was marked as an identifying attribute on the connection. All such identifiers will automatically create a delegation method of the same name on the channel instance.Rejecting subscription requestsA channel can reject a subscription request in thesubscribedcallback by invoking therejectmethod:class ChatChannel < ApplicationCable::Channel
  def subscribed
    @room = Chat::Room[params[:room_number]]
    reject unless current_user.can_access?(@room)
  end
endIn this example, the subscription will be rejected if thecurrent_userdoes not have access to the chat room. On the client-side, theChannel#rejectedcallback will get invoked when the server rejects the subscription request.MethodsAaction_methodsCclear_action_methods!Ddefer_subscription_confirmation!,defer_subscription_confirmation?Eensure_confirmation_sentMmethod_addedNnewPperform_actionRrejectSsubscribe_to_channel,subscribed,subscription_confirmation_sent?,subscription_rejected?TtransmitUunsubscribedIncluded ModulesActionCable::Channel::CallbacksActionCable::Channel::PeriodicTimersActionCable::Channel::StreamsActionCable::Channel::NamingActionCable::Channel::BroadcastingActiveSupport::RescuableAttributes[R]connection[R]identifier[R]paramsClass Public methodsaction_methods()LinkA list of method names that should be considered actions. This includes all public instance methods on a channel, less any internal methods (defined onBase), adding back in any methods that are internal, but still exist on the class itself.ReturnsSet- A set of all methods that should be considered actions.Source:show|on GitHub# File actioncable/lib/action_cable/channel/base.rb, line 129defaction_methods@action_methods||=begin# All public instance methods of this class, including ancestorsmethods= (public_instance_methods(true)-# Except for public instance methods of Base and its ancestorsActionCable::Channel::Base.public_instance_methods(true)+# Be sure to include shadowed public instance methods of this classpublic_instance_methods(false)).uniq.map(&:to_s)methods.to_setendendnew(connection, identifier, params = {})LinkSource:show|on GitHub# File actioncable/lib/action_cable/channel/base.rb, line 156definitialize(connection,identifier,params= {})@connection=connection@identifier=identifier@params=params# When a channel is streaming via pubsub, we want to delay the confirmation# transmission until pubsub subscription is confirmed.## The counter starts at 1 because it's awaiting a call to #subscribe_to_channel@defer_subscription_confirmation_counter=Concurrent::AtomicFixnum.new(1)@reject_subscription=nil@subscription_confirmation_sent=nildelegate_connection_identifiersendClass Private methodsclear_action_methods!()Linkaction_methodsare cached and there is sometimes need to refresh them.::clear_action_methods!allows you to do that, so next time you runaction_methods, they will be recalculated.Source:show|on GitHub# File actioncable/lib/action_cable/channel/base.rb, line 145defclear_action_methods!# :doc:@action_methods=nilendmethod_added(name)LinkRefresh the cachedaction_methodswhen a new action_method is added.Source:show|on GitHub# File actioncable/lib/action_cable/channel/base.rb, line 150defmethod_added(name)# :doc:superclear_action_methods!endInstance Public methodsperform_action(data)LinkExtract the action name from the passed data and process it via the channel. The process will ensure that the action requested is a public method on the channel declared by the user (so not one of the callbacks likesubscribed).Source:show|on GitHub# File actioncable/lib/action_cable/channel/base.rb, line 176defperform_action(data)action=extract_action(data)ifprocessable_action?(action)payload= {channel_class:self.class.name,action:action,data:data}ActiveSupport::Notifications.instrument("perform_action.action_cable",payload)dodispatch_action(action,data)endelselogger.error"Unable to process #{action_signature(action, data)}"endendsubscribe_to_channel()LinkThis method is called after subscription has been added to the connection and confirms or rejects the subscription.Source:show|on GitHub# File actioncable/lib/action_cable/channel/base.rb, line 191defsubscribe_to_channelrun_callbacks:subscribedosubscribedendreject_subscriptionifsubscription_rejected?ensure_confirmation_sentendInstance Private methodsdefer_subscription_confirmation!()LinkSource:show|on GitHub# File actioncable/lib/action_cable/channel/base.rb, line 245defdefer_subscription_confirmation!# :doc:@defer_subscription_confirmation_counter.incrementenddefer_subscription_confirmation?()LinkSource:show|on GitHub# File actioncable/lib/action_cable/channel/base.rb, line 249defdefer_subscription_confirmation?# :doc:@defer_subscription_confirmation_counter.value>0endensure_confirmation_sent()LinkSource:show|on GitHub# File actioncable/lib/action_cable/channel/base.rb, line 239defensure_confirmation_sent# :doc:returnifsubscription_rejected?@defer_subscription_confirmation_counter.decrementtransmit_subscription_confirmationunlessdefer_subscription_confirmation?endreject()LinkSource:show|on GitHub# File actioncable/lib/action_cable/channel/base.rb, line 257defreject# :doc:@reject_subscription=trueendsubscribed()LinkCalled once a consumer has become a subscriber of the channel. Usually the place to set up any streams you want this channel to be sending to the subscriber.Source:show|on GitHub# File actioncable/lib/action_cable/channel/base.rb, line 213defsubscribed# :doc:# Override in subclassesendsubscription_confirmation_sent?()LinkSource:show|on GitHub# File actioncable/lib/action_cable/channel/base.rb, line 253defsubscription_confirmation_sent?# :doc:@subscription_confirmation_sentendsubscription_rejected?()LinkSource:show|on GitHub# File actioncable/lib/action_cable/channel/base.rb, line 261defsubscription_rejected?# :doc:@reject_subscriptionendtransmit(data, via: nil)LinkTransmit a hash of data to the subscriber. The hash will automatically be wrapped in a JSON envelope with the proper channel identifier marked as the recipient.Source:show|on GitHub# File actioncable/lib/action_cable/channel/base.rb, line 226deftransmit(data,via:nil)# :doc:logger.debugdostatus="#{self.class.name} transmitting #{data.inspect.truncate(300)}"status+=" (via #{via})"ifviastatusendpayload= {channel_class:self.class.name,data:data,via:via}ActiveSupport::Notifications.instrument("transmit.action_cable",payload)doconnection.transmitidentifier:@identifier,message:dataendendunsubscribed()LinkCalled once a consumer has cut its cable connection. Can be used for cleaning up connections or marking users as offline or the like.Source:show|on GitHub# File actioncable/lib/action_cable/channel/base.rb, line 219defunsubscribed# :doc:# Override in subclassesend