Active Record Connection PoolConnection pool base class for managing Active Record database connections.IntroductionA connection pool synchronizes thread access to a limited number of database connections. The basic idea is that each thread checks out a database connection from the pool, uses that connection, and checks the connection back in.ConnectionPoolis completely thread-safe, and will ensure that a connection cannot be used by two threads at the same time, as long as ConnectionPoolâs contract is correctly followed. It will also handle cases in which there are more threads than connections: if all connections have been checked out, and a thread tries to checkout a connection anyway, thenConnectionPoolwill wait until some other thread has checked in a connection, or thecheckout_timeouthas expired.Obtaining (checking out) a connectionConnections can be obtained and used from a connection pool in several ways:Simply useActiveRecord::Base.lease_connection. When youâre done with the connection(s) and wish it to be returned to the pool, you callActiveRecord::Base.connection_handler.clear_active_connections!. This is the default behavior for Active Record when used in conjunction with Action Packâs request handling cycle.Manually check out a connection from the pool withActiveRecord::Base.connection_pool.checkout. You are responsible for returning this connection to the pool when finished by callingActiveRecord::Base.connection_pool.checkin(connection).UseActiveRecord::Base.connection_pool.with_connection(&block), which obtains a connection, yields it as the sole argument to the block, and returns it to the pool after the block completes.Connections in the pool are actuallyAbstractAdapterobjects (or objects compatible with AbstractAdapterâs interface).While a thread has a connection checked out from the pool using one of the above three methods, that connection will automatically be the one used byActiveRecordqueries executing on that thread. It is not required to explicitly pass the checked out connection to Rails models or queries, for example.OptionsThere are several connection-pooling-related options that you can add to your database connection configuration:pool: maximum number of connections the pool may manage (default 5).idle_timeout: number of seconds that a connection will be kept unused in the pool before it is automatically disconnected (default 300 seconds). Set this to zero to keep connections forever.checkout_timeout: number of seconds to wait for a connection to become available before giving up and raising a timeout error (default 5 seconds).NamespaceCLASSActiveRecord::ConnectionAdapters::ConnectionPool::QueueCLASSActiveRecord::ConnectionAdapters::ConnectionPool::ReaperMethodsAactive_connection?Ccheckin,checkout,clear_reloadable_connections,clear_reloadable_connections!,connected?,connection,connectionsDdisconnect,disconnect!Fflush,flush!Llease_connectionNnewRreap,release_connection,removeSschema_cache,schema_reflection=,statWwith_connectionIncluded ModulesMonitorMixinAttributes[R]async_executor[RW]automatic_reconnect[RW]checkout_timeout[R]db_config[R]pool_config[R]reaper[R]role[R]shard[R]sizeClass Public methodsnew(pool_config)LinkCreates a newConnectionPoolobject.pool_configis a PoolConfig object which describes database connection information (e.g. adapter, host name, username, password, etc), as well as the maximum size for thisConnectionPool.The defaultConnectionPoolmaximum size is 5.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 202definitialize(pool_config)super()@pool_config=pool_config@db_config=pool_config.db_config@role=pool_config.role@shard=pool_config.shard@checkout_timeout=db_config.checkout_timeout@idle_timeout=db_config.idle_timeout@size=db_config.pool# This variable tracks the cache of threads mapped to reserved connections, with the# sole purpose of speeding up the +connection+ method. It is not the authoritative# registry of which thread owns which connection. Connection ownership is tracked by# the +connection.owner+ attr on each +connection+ instance.# The invariant works like this: if there is mapping of <tt>thread => conn</tt>,# then that +thread+ does indeed own that +conn+. However, an absence of such# mapping does not mean that the +thread+ doesn't own the said connection. In# that case +conn.owner+ attr should be consulted.# Access and modification of <tt>@leases</tt> does not require# synchronization.@leases=LeaseRegistry.new@connections= []@automatic_reconnect=true# Connection pool allows for concurrent (outside the main +synchronize+ section)# establishment of new connections. This variable tracks the number of threads# currently in the process of independently establishing connections to the DB.@now_connecting=0@threads_blocking_new_connections=0@available=ConnectionLeasingQueue.newself@pinned_connection=nil@pinned_connections_depth=0@async_executor=build_async_executor@schema_cache=nil@reaper=Reaper.new(self,db_config.reaping_frequency)@reaper.runendInstance Public methodsactive_connection?()LinkReturns true if there is an open connection being used for the current thread.This method only works for connections that have been obtained throughlease_connectionorwith_connectionmethods. Connections obtained throughcheckoutwill not be detected byactive_connection?Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 353defactive_connection?connection_lease.connectionendcheckin(conn)LinkCheck-in a database connection back into the pool, indicating that you no longer need this connection.conn: anAbstractAdapterobject, which was obtained by earlier by callingcheckouton this pool.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 547defcheckin(conn)returnif@pinned_connection.equal?(conn)conn.lock.synchronizedosynchronizedoconnection_lease.clear(conn)conn._run_checkin_callbacksdoconn.expireend@available.addconnendendendcheckout(checkout_timeout = @checkout_timeout)LinkCheck-out a database connection from the pool, indicating that you want to use it. You should callcheckinwhen you no longer need this.This is done by either returning and leasing existing connection, or by creating a new connection and leasing it.If all connections are leased and the pool is at capacity (meaning the number of currently leased connections is greater than or equal to the size limit set), anActiveRecord::ConnectionTimeoutErrorexception will be raised.Returns: anAbstractAdapterobject.Raises:ActiveRecord::ConnectionTimeoutErrorno connection can be obtained from the pool.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 524defcheckout(checkout_timeout=@checkout_timeout)if@pinned_connection@pinned_connection.lock.synchronizedosynchronizedo@pinned_connection.verify!# Any leased connection must be in @connections otherwise# some methods like #connected? won't behave correctlyunless@connections.include?(@pinned_connection)@connections<<@pinned_connectionendendend@pinned_connectionelsecheckout_and_verify(acquire_connection(checkout_timeout))endendclear_reloadable_connections(raise_on_acquisition_timeout = true)LinkClears the cache which maps classes and re-connects connections that require reloading.Raises:ActiveRecord::ExclusiveConnectionTimeoutErrorif unable to gain ownership of all connections in the pool within a timeout interval (default duration isspec.db_config.checkout_timeout * 2seconds).Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 482defclear_reloadable_connections(raise_on_acquisition_timeout=true)with_exclusively_acquired_all_connections(raise_on_acquisition_timeout)dosynchronizedo@connections.eachdo|conn|ifconn.in_use?conn.steal!checkinconnendconn.disconnect!ifconn.requires_reloading?end@connections.delete_if(&:requires_reloading?)@available.clearendendendclear_reloadable_connections!()LinkClears the cache which maps classes and re-connects connections that require reloading.The pool first tries to gain ownership of all connections. If unable to do so within a timeout interval (default duration isspec.db_config.checkout_timeout * 2seconds), then the pool forcefully clears the cache and reloads connections without any regard for other connection owning threads.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 506defclear_reloadable_connections!clear_reloadable_connections(false)endconnected?()LinkReturns true if a connection has already been opened.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 404defconnected?synchronize{@connections.any?(&:connected?) }endconnection()LinkSource:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 295defconnectionActiveRecord.deprecator.warn(<<~MSG)ActiveRecord::ConnectionAdapters::ConnectionPool#connection is deprecated
          and will be removed in Rails 8.0. Use #lease_connection instead.MSGlease_connectionendconnections()LinkReturns an array containing the connections currently in the pool. Access to the array does not require synchronization on the pool because the array is newly created and not retained by the pool.However; this method bypasses the ConnectionPoolâs thread-safe connection access pattern. A returned connection may be owned by another thread, unowned, or by happen-stance owned by the calling thread.Calling methods on a connection without ownership is subject to the thread-safety guarantees of the underlying method. Many of the methods on connection adapter classes are inherently multi-thread unsafe.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 419defconnectionssynchronize{@connections.dup}enddisconnect(raise_on_acquisition_timeout = true)LinkDisconnects all connections in the pool, and clears the pool.Raises:ActiveRecord::ExclusiveConnectionTimeoutErrorif unable to gain ownership of all connections in the pool within a timeout interval (default duration isspec.db_config.checkout_timeout * 2seconds).Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 429defdisconnect(raise_on_acquisition_timeout=true)with_exclusively_acquired_all_connections(raise_on_acquisition_timeout)dosynchronizedo@connections.eachdo|conn|ifconn.in_use?conn.steal!checkinconnendconn.disconnect!end@connections= []@leases.clear@available.clearendendenddisconnect!()LinkDisconnects all connections in the pool, and clears the pool.The pool first tries to gain ownership of all connections. If unable to do so within a timeout interval (default duration isspec.db_config.checkout_timeout * 2seconds), then the pool is forcefully disconnected without any regard for other connection owning threads.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 452defdisconnect!disconnect(false)endflush(minimum_idle = @idle_timeout)LinkDisconnect all connections that have been idle for at leastminimum_idleseconds. Connections currently checked out, or that were checked in less thanminimum_idleseconds ago, are unaffected.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 620defflush(minimum_idle=@idle_timeout)returnifminimum_idle.nil?idle_connections=synchronizedoreturnifself.discarded?@connections.selectdo|conn|!conn.in_use?&&conn.seconds_idle>=minimum_idleend.eachdo|conn|conn.lease@available.deleteconn@connections.deleteconnendendidle_connections.eachdo|conn|conn.disconnect!endendflush!()LinkDisconnect all currently idle connections. Connections currently checked out are unaffected.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 642defflush!reapflush(-1)endlease_connection()LinkRetrieve the connection associated with the current thread, or callcheckoutto obtain one if necessary.lease_connectioncan be called any number of times; the connection is held in a cache keyed by a thread.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 285deflease_connectionlease=connection_leaselease.sticky=truelease.connection||=checkoutendreap()LinkRecover lost connections for the pool. A lost connection can occur if a programmer forgets to checkin a connection at the end of a thread or a thread dies unexpectedly.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 597defreapstale_connections=synchronizedoreturnifself.discarded?@connections.selectdo|conn|conn.in_use?&&!conn.owner.alive?end.eachdo|conn|conn.steal!endendstale_connections.eachdo|conn|ifconn.active?conn.reset!checkinconnelseremoveconnendendendrelease_connection(existing_lease = nil)LinkSignal that the thread is finished with the current connection.release_connectionreleases the connection-thread association and returns the connection to the pool.This method only works for connections that have been obtained throughlease_connectionorwith_connectionmethods, connections obtained throughcheckoutwill not be automatically released.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 365defrelease_connection(existing_lease=nil)ifconn=connection_lease.releasecheckinconnreturntrueendfalseendremove(conn)LinkRemove a connection from the connection pool. The connection will remain open and active but will no longer be managed by this pool.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 565defremove(conn)needs_new_connection=falsesynchronizedoremove_connection_from_thread_cacheconn@connections.deleteconn@available.deleteconn# @available.any_waiting? => true means that prior to removing this# conn, the pool was at its max size (@connections.size == @size).# This would mean that any threads stuck waiting in the queue wouldn't# know they could checkout_new_connection, so let's do it for them.# Because condition-wait loop is encapsulated in the Queue class# (that in turn is oblivious to ConnectionPool implementation), threads# that are "stuck" there are helpless. They have no way of creating# new connections and are completely reliant on us feeding available# connections into the Queue.needs_new_connection=@available.any_waiting?end# This is intentionally done outside of the synchronized section as we# would like not to hold the main mutex while checking out new connections.# Thus there is some chance that needs_new_connection information is now# stale, we can live with that (bulk_make_new_connections will make# sure not to exceed the pool's @size limit).bulk_make_new_connections(1)ifneeds_new_connectionendschema_cache()LinkSource:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 255defschema_cache@schema_cache||=BoundSchemaReflection.new(schema_reflection,self)endschema_reflection=(schema_reflection)LinkSource:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 259defschema_reflection=(schema_reflection)pool_config.schema_reflection=schema_reflection@schema_cache=nilendstat()LinkReturns the connection poolâs usage statistic.ActiveRecord::Base.connection_pool.stat # => { size: 15, connections: 1, busy: 1, dead: 0, idle: 0, waiting: 0, checkout_timeout: 5 }Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 654defstatsynchronizedo{size:size,connections:@connections.size,busy:@connections.count{|c|c.in_use?&&c.owner.alive?},dead:@connections.count{|c|c.in_use?&&!c.owner.alive?},idle:@connections.count{|c|!c.in_use?},waiting:num_waiting_in_queue,checkout_timeout:checkout_timeout}endendwith_connection(prevent_permanent_checkout: false)LinkYields a connection from the connection pool to the block. If no connection is already checked out by the current thread, a connection will be checked out from the pool, yielded to the block, and then returned to the pool when the block is finished. If a connection has already been checked out on the current thread, such as vialease_connectionorwith_connection, that existing connection will be the one yielded and it will not be returned to the pool automatically at the end of the block; it is expected that such an existing connection will be properly returned to the pool by the code that checked it out.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb, line 382defwith_connection(prevent_permanent_checkout:false)lease=connection_leasesticky_was=lease.stickylease.sticky=falseifprevent_permanent_checkoutiflease.connectionbeginyieldlease.connectionensurelease.sticky=sticky_wasifprevent_permanent_checkout&&!sticky_wasendelsebeginyieldlease.connection=checkoutensurelease.sticky=sticky_wasifprevent_permanent_checkout&&!sticky_wasrelease_connection(lease)unlesslease.stickyendendend