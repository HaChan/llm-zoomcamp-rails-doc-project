MethodsAadd_transaction_recordBbegin_db_transaction,begin_isolated_db_transactionCcommit_db_transaction,createDdefault_sequence_name,deleteEempty_insert_statement_value,exec_delete,exec_insert,exec_query,exec_update,executeHhigh_precision_current_timestampIinsert,insert_fixture,insert_fixtures_setNnewRreset_sequence!,restart_db_transaction,rollback_db_transaction,rollback_to_savepointSsanitize_limit,select_all,select_one,select_rows,select_value,select_valuesTto_sql,transaction,transaction_isolation_levels,transaction_open?,truncateUupdateWwrite_query?Class Public methodsnew()LinkSource:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb, line 6definitializesuperreset_transactionendInstance Public methodsadd_transaction_record(record, ensure_finalize = true)LinkRegister a record with the current transaction so that its after_commit and after_rollback callbacks can be called.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb, line 407defadd_transaction_record(record,ensure_finalize=true)current_transaction.add_record(record,ensure_finalize)endbegin_db_transaction()LinkBegins the transaction (and turns off auto-committing).Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb, line 412defbegin_db_transaction()endbegin_isolated_db_transaction(isolation)LinkBegins the transaction with the isolation level set. Raises an error by default; adapters that support setting the isolation level should implement this method.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb, line 426defbegin_isolated_db_transaction(isolation)raiseActiveRecord::TransactionIsolationError,"adapter does not support setting transaction isolation"endcommit_db_transaction()LinkCommits the transaction (and turns on auto-committing).Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb, line 431defcommit_db_transaction()endcreate(arel, name = nil, pk = nil, id_value = nil, sequence_name = nil, binds = [], returning: nil)LinkAlias for:insertdefault_sequence_name(table, column)LinkSource:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb, line 453defdefault_sequence_name(table,column)nilenddelete(arel, name = nil, binds = [])LinkExecutes the delete statement and returns the number of rows affected.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb, line 212defdelete(arel,name=nil,binds= [])sql,binds=to_sql_and_binds(arel,binds)exec_delete(sql,name,binds)endempty_insert_statement_value(primary_key = nil)LinkSource:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb, line 485defempty_insert_statement_value(primary_key=nil)"DEFAULT VALUES"endexec_delete(sql, name = nil, binds = [])LinkExecutes deletesqlstatement in the context of this connection usingbindsas the bind substitutes.nameis logged along with the executedsqlstatement.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb, line 165defexec_delete(sql,name=nil,binds= [])internal_exec_query(sql,name,binds)endexec_insert(sql, name = nil, binds = [], pk = nil, sequence_name = nil, returning: nil)LinkExecutes insertsqlstatement in the context of this connection usingbindsas the bind substitutes.nameis logged along with the executedsqlstatement. Some adapters support the âreturning` keyword argument which allows to control the result of the query: `nil` is the default value and maintains default behavior. If an array of column names is passed - the result will contain values of the specified columns from the inserted row.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb, line 157defexec_insert(sql,name=nil,binds= [],pk=nil,sequence_name=nil,returning:nil)sql,binds=sql_for_insert(sql,pk,binds,returning)internal_exec_query(sql,name,binds)endexec_query(sql, name = "SQL", binds = [], prepare: false)LinkExecutessqlstatement in the context of this connection usingbindsas the bind substitutes.nameis logged along with the executedsqlstatement.Note: the query is assumed to have side effects and the query cache will be cleared. If the query is read-only, consider usingselect_allinstead.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb, line 147defexec_query(sql,name="SQL",binds= [],prepare:false)internal_exec_query(sql,name,binds,prepare:prepare)endexec_update(sql, name = nil, binds = [])LinkExecutes updatesqlstatement in the context of this connection usingbindsas the bind substitutes.nameis logged along with the executedsqlstatement.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb, line 172defexec_update(sql,name=nil,binds= [])internal_exec_query(sql,name,binds)endexecute(sql, name = nil, allow_retry: false)LinkExecutes the SQL statement in the context of this connection and returns the raw result from the connection adapter.Settingallow_retryto true causes the db to reconnect and retry executing the SQL statement in case of a connection-related exception. This option should only be enabled for known idempotent queries.Note: the query is assumed to have side effects and the query cache will be cleared. If the query is read-only, consider usingselect_allinstead.Note: depending on your database connector, the result returned by this method may be manually memory managed. Consider usingexec_querywrapper instead.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb, line 136defexecute(sql,name=nil,allow_retry:false)internal_execute(sql,name,allow_retry:allow_retry)endhigh_precision_current_timestamp()LinkReturns anArelSQL literal for the CURRENT_TIMESTAMP for usage with arbitrary precision date/time columns.Adapters supporting datetime with precision should override this to provide as much precision as is available.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb, line 523defhigh_precision_current_timestampHIGH_PRECISION_CURRENT_TIMESTAMPendinsert(arel, name = nil, pk = nil, id_value = nil, sequence_name = nil, binds = [], returning: nil)LinkExecutes an INSERT query and returns the new recordâs IDid_valuewill be returned unless the value isnil, in which case the database will attempt to calculate the last inserted id and return that value.If the next id was calculated in advance (as in Oracle), it should be passed in asid_value. Some adapters support the âreturning` keyword argument which allows defining the return value of the method: `nil` is the default value and maintains default behavior. If an array of column names is passed - an array of is returned from the method representing values of the specified columns from the inserted row.Also aliased as:createSource:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb, line 195definsert(arel,name=nil,pk=nil,id_value=nil,sequence_name=nil,binds= [],returning:nil)sql,binds=to_sql_and_binds(arel,binds)value=exec_insert(sql,name,binds,pk,sequence_name,returning:returning)returnreturning_column_values(value)unlessreturning.nil?id_value||last_inserted_id(value)endinsert_fixture(fixture, table_name)LinkInserts the given fixture into the table. Overridden in adapters that require something beyond a simple insert (e.g. Oracle). Most of adapters should implementinsert_fixtures_setthat leverages bulk SQL insert. We keep this method to provide fallback for databases like SQLite that do not support bulk inserts.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb, line 467definsert_fixture(fixture,table_name)execute(build_fixture_sql(Array.wrap(fixture),table_name),"Fixture Insert")endinsert_fixtures_set(fixture_set, tables_to_delete = [])LinkSource:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb, line 471definsert_fixtures_set(fixture_set,tables_to_delete= [])fixture_inserts=build_fixture_statements(fixture_set)table_deletes=tables_to_delete.map{|table|"DELETE FROM #{quote_table_name(table)}"}statements=table_deletes+fixture_insertswith_multi_statementsdotransaction(requires_new:true)dodisable_referential_integritydoexecute_batch(statements,"Fixtures Load")endendendendreset_sequence!(table, column, sequence = nil)LinkSet the sequence to the max value of the tableâs column.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb, line 458defreset_sequence!(table,column,sequence=nil)# Do nothing by default. Implement for PostgreSQL, Oracle, ...endrestart_db_transaction()LinkSource:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb, line 443defrestart_db_transactionexec_restart_db_transactionendrollback_db_transaction()LinkRolls back the transaction (and turns on auto-committing). Must be done if the transaction block raises an exception or returns false.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb, line 435defrollback_db_transactionexec_rollback_db_transactionrescueActiveRecord::ConnectionNotEstablished,ActiveRecord::ConnectionFailed# Connection's gone; that counts as a rollbackendrollback_to_savepoint(name = nil)LinkSource:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb, line 449defrollback_to_savepoint(name=nil)exec_rollback_to_savepoint(name)endsanitize_limit(limit)LinkSanitizes the given LIMIT parameter in order to prevent SQL injection.Thelimitmay be anything that can evaluate to a string via to_s. It should look like an integer, or anArelSQL literal.ReturnsIntegerand Arel::Nodes::SqlLiteral limits as is.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb, line 495defsanitize_limit(limit)iflimit.is_a?(Integer)||limit.is_a?(Arel::Nodes::SqlLiteral)limitelseInteger(limit)endendselect_all(arel, name = nil, binds = [], preparable: nil, async: false, allow_retry: false)LinkReturns anActiveRecord::Resultinstance.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb, line 69defselect_all(arel,name=nil,binds= [],preparable:nil,async:false,allow_retry:false)arel=arel_from_relation(arel)sql,binds,preparable,allow_retry=to_sql_and_binds(arel,binds,preparable,allow_retry)select(sql,name,binds,prepare:prepared_statements&&preparable,async:async&&FutureResult::SelectAll,allow_retry:allow_retry)rescue::RangeErrorActiveRecord::Result.empty(async:async)endselect_one(arel, name = nil, binds = [], async: false)LinkReturns a record hash with the column names as keys and column values as values.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb, line 84defselect_one(arel,name=nil,binds= [],async:false)select_all(arel,name,binds,async:async).then(&:first)endselect_rows(arel, name = nil, binds = [], async: false)LinkReturns an array of arrays containing the field values. Order is the same as that returned bycolumns.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb, line 101defselect_rows(arel,name=nil,binds= [],async:false)select_all(arel,name,binds,async:async).then(&:rows)endselect_value(arel, name = nil, binds = [], async: false)LinkReturns a single value from a recordSource:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb, line 89defselect_value(arel,name=nil,binds= [],async:false)select_rows(arel,name,binds,async:async).then{|rows|single_value_from_rows(rows) }endselect_values(arel, name = nil, binds = [])LinkReturns an array of the values of the first column in a select:select_values("SELECT id FROM companies LIMIT 3") => [1,2,3]Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb, line 95defselect_values(arel,name=nil,binds= [])select_rows(arel,name,binds).map(&:first)endto_sql(arel_or_sql_string, binds = [])LinkConverts an arel AST to SQLSource:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb, line 12defto_sql(arel_or_sql_string,binds= [])sql,_=to_sql_and_binds(arel_or_sql_string,binds)sqlendtransaction(requires_new: nil, isolation: nil, &block)LinkRuns the given block in a database transaction, and returns the result of the block.Transactioncallbackstransactionyields anActiveRecord::Transactionobject on which it is possible to register callback:ActiveRecord::Base.transaction do |transaction|
  transaction.before_commit { puts "before commit!" }
  transaction.after_commit { puts "after commit!" }
  transaction.after_rollback { puts "after rollback!" }
endNested transactions supporttransactioncalls can be nested. By default, this makes all database statements in the nested transaction block become part of the parent transaction. For example, the following behavior may be surprising:ActiveRecord::Base.transaction do
  Post.create(title: 'first')
  ActiveRecord::Base.transaction do
    Post.create(title: 'second')
    raise ActiveRecord::Rollback
  end
endThis creates both âfirstâ and âsecondâ posts. Reason is theActiveRecord::Rollbackexception in the nested block does not issue a ROLLBACK. Since these exceptions are captured in transaction blocks, the parent block does not see it and the real transaction is committed.Most databases donât support true nested transactions. At the time of writing, the only database that supports true nested transactions that weâre aware of, is MS-SQL.In order to get around this problem,transactionwill emulate the effect of nested transactions, by using savepoints:dev.mysql.com/doc/refman/en/savepoint.html.It is safe to call this method if a database transaction is already open, i.e. iftransactionis called within anothertransactionblock. In case of a nested call,transactionwill behave as follows:The block will be run without doing anything. All database statements that happen within the block are effectively appended to the already open database transaction.However, if:requires_newis set, the block will be wrapped in a database savepoint acting as a sub-transaction.In order to get a ROLLBACK for the nested transaction you may ask for a real sub-transaction by passingrequires_new: true. If anything goes wrong, the database rolls back to the beginning of the sub-transaction without rolling back the parent transaction. If we add it to the previous example:ActiveRecord::Base.transaction do
  Post.create(title: 'first')
  ActiveRecord::Base.transaction(requires_new: true) do
    Post.create(title: 'second')
    raise ActiveRecord::Rollback
  end
endonly post with title âfirstâ is created.SeeActiveRecord::Transactionsto learn more.CaveatsMySQLdoesnât support DDL transactions. If you perform a DDL operation, then any created savepoints will be automatically released. For example, if youâve created a savepoint, then you execute a CREATE TABLE statement, then the savepoint that was created will be automatically released.This means that, onMySQL, you shouldnât execute DDL operations inside atransactioncall that you know might create a savepoint. Otherwise,transactionwill raise exceptions when it tries to release the already-automatically-released savepoints:Model.lease_connection.transaction do  # BEGIN
  Model.lease_connection.transaction(requires_new: true) do  # CREATE SAVEPOINT active_record_1
    Model.lease_connection.create_table(...)
    # active_record_1 now automatically released
  end  # RELEASE SAVEPOINT active_record_1  <--- BOOM! database error!
endTransactionisolationIf your database supports setting the isolation level for a transaction, you can set it like so:Post.transaction(isolation: :serializable) do
  # ...
endValid isolation levels are::read_uncommitted:read_committed:repeatable_read:serializableYou should consult the documentation for your database to understand the semantics of these different levels:www.postgresql.org/docs/current/static/transaction-iso.htmldev.mysql.com/doc/refman/en/set-transaction.htmlAnActiveRecord::TransactionIsolationErrorwill be raised if:The adapter does not support setting the isolation levelYou are joining an existing open transactionYou are creating a nested (savepoint) transactionThe mysql2, trilogy, and postgresql adapters support setting the transaction isolation level.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb, line 354deftransaction(requires_new:nil,isolation:nil,joinable:true,&block)if!requires_new&&current_transaction.joinable?ifisolationraiseActiveRecord::TransactionIsolationError,"cannot set isolation when joining a transaction"endyieldcurrent_transaction.user_transactionelsetransaction_manager.within_new_transaction(isolation:isolation,joinable:joinable,&block)endrescueActiveRecord::Rollback# rollbacks are silently swallowedendtransaction_isolation_levels()LinkSource:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb, line 414deftransaction_isolation_levels{read_uncommitted:"READ UNCOMMITTED",read_committed:"READ COMMITTED",repeatable_read:"REPEATABLE READ",serializable:"SERIALIZABLE"}endtransaction_open?()LinkSource:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb, line 381deftransaction_open?current_transaction.open?endtruncate(table_name, name = nil)LinkExecutes the truncate statement.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb, line 218deftruncate(table_name,name=nil)execute(build_truncate_statement(table_name),name)endupdate(arel, name = nil, binds = [])LinkExecutes the update statement and returns the number of rows affected.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb, line 206defupdate(arel,name=nil,binds= [])sql,binds=to_sql_and_binds(arel,binds)exec_update(sql,name,binds)endwrite_query?(sql)LinkDetermines whether the SQL statement is a write query.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb, line 118defwrite_query?(sql)raiseNotImplementedErrorend