Active Storage BlobA blob is a record that contains the metadata about a file and a key for where that file resides on the service. Blobs can be created in two ways:Ahead of the file being uploaded server-side to the service, viacreate_and_upload!. A rewindableiowith the file contents must be available at the server for this operation.Ahead of the file being directly uploaded client-side to the service, viacreate_before_direct_upload!.The first option doesnât require any client-side JavaScript integration, and can be used by any other back-end service that deals with files. The second option is faster, since youâre not using your own server as a staging point for uploads, and can work with deployments like Heroku that do not provide large amounts of disk space.Blobs are intended to be immutable in as-so-far as their reference to a specific file goes. Youâre allowed to update a blobâs metadata on a subsequent pass, but you should not update the key or change the uploaded file. If you need to create a derivative or otherwise change the blob, simply create a new blob and purge the old one.NamespaceMODULEActiveStorage::Blob::AnalyzableMODULEActiveStorage::Blob::IdentifiableMODULEActiveStorage::Blob::RepresentableMethodsAattachments,audio?Ccompose,create_and_upload!,create_before_direct_upload!,custom_metadata,custom_metadata=Ddelete,download,download_chunkFfilename,find_signed,find_signed!Ggenerate_unique_secure_tokenIimage?KkeyOopenPpurge,purge_laterSservice,service_headers_for_direct_upload,service_url_for_direct_upload,signed_idTtext?Uunattached,upload,urlVvideo?Included ModulesActiveStorage::Blob::AnalyzableActiveStorage::Blob::IdentifiableActiveStorage::Blob::RepresentableConstantsMINIMUM_TOKEN_LENGTH=28Class Public methodscompose(blobs, key: nil, filename:, content_type: nil, metadata: nil)LinkConcatenate multiple blobs into a single âcomposedâ blob.Source:show|on GitHub# File activestorage/app/models/active_storage/blob.rb, line 145defcompose(blobs,key:nil,filename:,content_type:nil,metadata:nil)raiseActiveRecord::RecordNotSaved,"All blobs must be persisted."ifblobs.any?(&:new_record?)content_type||=blobs.pluck(:content_type).compact.firstnew(key:key,filename:filename,content_type:content_type,metadata:metadata,byte_size:blobs.sum(&:byte_size)).tapdo|combined_blob|combined_blob.compose(blobs.pluck(:key))combined_blob.save!endendcreate_and_upload!(key: nil, io:, filename:, content_type: nil, metadata: nil, service_name: nil, identify: true, record: nil)LinkCreates a new blob instance and then uploads the contents of the givenioto the service. The blob instance is going to be saved before the upload begins to prevent the upload clobbering another due to key collisions. When providing a content type, passidentify: falseto bypass automatic content type inference.Source:show|on GitHub# File activestorage/app/models/active_storage/blob.rb, line 96defcreate_and_upload!(key:nil,io:,filename:,content_type:nil,metadata:nil,service_name:nil,identify:true,record:nil)create_after_unfurling!(key:key,io:io,filename:filename,content_type:content_type,metadata:metadata,service_name:service_name,identify:identify).tapdo|blob|blob.upload_without_unfurling(io)endendcreate_before_direct_upload!(key: nil, filename:, byte_size:, checksum:, content_type: nil, metadata: nil, service_name: nil, record: nil)LinkReturns a saved blobwithoutuploading a file to the service. This blob will point to a key where there is no file yet. Itâs intended to be used together with a client-side upload, which will first create the blob in order to produce the signed URL for uploading. This signed URL points to the key generated by the blob. Once the form using the direct upload is submitted, the blob can be associated with the right record using the signed ID.Source:show|on GitHub# File activestorage/app/models/active_storage/blob.rb, line 107defcreate_before_direct_upload!(key:nil,filename:,byte_size:,checksum:,content_type:nil,metadata:nil,service_name:nil,record:nil)create!key:key,filename:filename,byte_size:byte_size,checksum:checksum,content_type:content_type,metadata:metadata,service_name:service_nameendfind_signed(id, record: nil, purpose: :blob_id)LinkYou can use the signed ID of a blob to refer to it on the client side without fear of tampering. This is particularly helpful for direct uploads where the client-side needs to refer to the blob that was created ahead of the upload itself on form submission.The signed ID is also used to create stable URLs for the blob through the BlobsController.Source:show|on GitHub# File activestorage/app/models/active_storage/blob.rb, line 69deffind_signed(id,record:nil,purpose::blob_id)super(id,purpose:purpose)endfind_signed!(id, record: nil, purpose: :blob_id)LinkWorks likefind_signed, but will raise anActiveSupport::MessageVerifier::InvalidSignatureexception if thesigned_idhas either expired, has a purpose mismatch, is for another record, or has been tampered with. It will also raise anActiveRecord::RecordNotFoundexception if the valid signed id canât find a record.Source:show|on GitHub# File activestorage/app/models/active_storage/blob.rb, line 77deffind_signed!(id,record:nil,purpose::blob_id)super(id,purpose:purpose)endgenerate_unique_secure_token(length: MINIMUM_TOKEN_LENGTH)LinkTo prevent problems with case-insensitive filesystems, especially in combination with databases which treat indices as case-sensitive, all blob keys generated are going to only contain the base-36 character alphabet and will therefore be lowercase. To maintain the same or higher amount of entropy as in the base-58 encoding used byhas_secure_tokenthe number of bytes used is increased to 28 from the standard 24Source:show|on GitHub# File activestorage/app/models/active_storage/blob.rb, line 116defgenerate_unique_secure_token(length:MINIMUM_TOKEN_LENGTH)SecureRandom.base36(length)endunattachedLinkReturns the blobs that arenât attached to any record.Source:show|on GitHub# File activestorage/app/models/active_storage/blob.rb, line 38scope:unattached,->{where.missing(:attachments) }Instance Public methodsattachmentsLinkReturns the associatedActiveStorage::Attachmentinstances.Source:show|on GitHub# File activestorage/app/models/active_storage/blob.rb, line 32has_many:attachmentsaudio?()LinkReturns true if the content_type of this blob is in the audio range, like audio/mpeg.Source:show|on GitHub# File activestorage/app/models/active_storage/blob.rb, line 213defaudio?content_type.start_with?("audio")endcustom_metadata()LinkSource:show|on GitHub# File activestorage/app/models/active_storage/blob.rb, line 199defcustom_metadataself[:metadata][:custom]||{}endcustom_metadata=(metadata)LinkSource:show|on GitHub# File activestorage/app/models/active_storage/blob.rb, line 203defcustom_metadata=(metadata)self[:metadata] =self[:metadata].merge(custom:metadata)enddelete()LinkDeletes the files on the service associated with the blob. This should only be done if the blob is going to be deleted as well or you will essentially have a dead reference. Itâs recommended to usepurgeandpurge_latermethods in most circumstances.Source:show|on GitHub# File activestorage/app/models/active_storage/blob.rb, line 323defdeleteservice.delete(key)service.delete_prefixed("variants/#{key}/")ifimage?enddownload(&block)LinkDownloads the file associated with this blob. If no block is given, the entire file is read into memory and returned. Thatâll use a lot of RAM for very large files. If a block is given, then the download is streamed and yielded in chunks.Source:show|on GitHub# File activestorage/app/models/active_storage/blob.rb, line 283defdownload(&block)service.downloadkey,&blockenddownload_chunk(range)LinkDownloads a part of the file associated with this blob.Source:show|on GitHub# File activestorage/app/models/active_storage/blob.rb, line 288defdownload_chunk(range)service.download_chunkkey,rangeendfilename()LinkReturns anActiveStorage::Filenameinstance of the filename that can be queried for basename, extension, and a sanitized version of the filename thatâs safe to use in URLs.Source:show|on GitHub# File activestorage/app/models/active_storage/blob.rb, line 195deffilenameActiveStorage::Filename.new(self[:filename])endimage?()LinkReturns true if the content_type of this blob is in the image range, like image/png.Source:show|on GitHub# File activestorage/app/models/active_storage/blob.rb, line 208defimage?content_type.start_with?("image")endkey()LinkReturns the key pointing to the file on the service thatâs associated with this blob. The key is the secure-token format from Rails in lower case. So itâll look like: xtapjjcjiudrlk3tmwyjgpuobabd. This key is not intended to be revealed directly to the user. Always refer to blobs using thesigned_idor a verified form of the key.Source:show|on GitHub# File activestorage/app/models/active_storage/blob.rb, line 187defkey# We can't wait until the record is first saved to have a key for itself[:key]||=self.class.generate_unique_secure_token(length:MINIMUM_TOKEN_LENGTH)endopen(tmpdir: nil, &block)LinkDownloads the blob to a tempfile on disk. Yields the tempfile.The tempfileâs name is prefixed withActiveStorage-and the blobâs ID. Its extension matches that of the blob.By default, the tempfile is created inDir.tmpdir. Passtmpdir:to create it in a different directory:blob.open(tmpdir: "/path/to/tmp") do |file|
  # ...
endThe tempfile is automatically closed and unlinked after the given block is executed.RaisesActiveStorage::IntegrityErrorif the downloaded data does not match the blobâs checksum.Source:show|on GitHub# File activestorage/app/models/active_storage/blob.rb, line 305defopen(tmpdir:nil,&block)service.open(key,checksum:checksum,verify:!composed,name:["ActiveStorage-#{id}-",filename.extension_with_delimiter],tmpdir:tmpdir,&block)endpurge()LinkDestroys the blob record and then deletes the file on the service. This is the recommended way to dispose of unwanted blobs. Note, though, that deleting the file off the service will initiate an HTTP connection to the service, which may be slow or prevented, so you should not use this method inside a transaction or in callbacks. Usepurge_laterinstead.Source:show|on GitHub# File activestorage/app/models/active_storage/blob.rb, line 331defpurgedestroydeleteifpreviously_persisted?rescueActiveRecord::InvalidForeignKeyendpurge_later()LinkEnqueues anActiveStorage::PurgeJobto callpurge. This is the recommended way to purge blobs from a transaction, an Active Record callback, or in any other real-time scenario.Source:show|on GitHub# File activestorage/app/models/active_storage/blob.rb, line 339defpurge_laterActiveStorage::PurgeJob.perform_later(self)endservice()LinkReturns an instance of service, which can be configured globally or per attachmentSource:show|on GitHub# File activestorage/app/models/active_storage/blob.rb, line 344defserviceservices.fetch(service_name)endservice_headers_for_direct_upload()LinkReturns aHashof headers forservice_url_for_direct_uploadrequests.Source:show|on GitHub# File activestorage/app/models/active_storage/blob.rb, line 243defservice_headers_for_direct_uploadservice.headers_for_direct_uploadkey,filename:filename,content_type:content_type,content_length:byte_size,checksum:checksum,custom_metadata:custom_metadataendservice_url_for_direct_upload(expires_in: ActiveStorage.service_urls_expire_in)LinkReturns a URL that can be used to directly upload a file for this blob on the service. This URL is intended to be short-lived for security and only generated on-demand by the client-side JavaScript responsible for doing the uploading.Source:show|on GitHub# File activestorage/app/models/active_storage/blob.rb, line 238defservice_url_for_direct_upload(expires_in:ActiveStorage.service_urls_expire_in)service.url_for_direct_uploadkey,expires_in:expires_in,content_type:content_type,content_length:byte_size,checksum:checksum,custom_metadata:custom_metadataendsigned_id(purpose: :blob_id, expires_in: nil, expires_at: nil)LinkReturns a signed ID for this blob thatâs suitable for reference on the client-side without fear of tampering.Source:show|on GitHub# File activestorage/app/models/active_storage/blob.rb, line 179defsigned_id(purpose::blob_id,expires_in:nil,expires_at:nil)superendtext?()LinkReturns true if the content_type of this blob is in the text range, like text/plain.Source:show|on GitHub# File activestorage/app/models/active_storage/blob.rb, line 223deftext?content_type.start_with?("text")endupload(io, identify: true)LinkUploads theioto the service on thekeyfor this blob. Blobs are intended to be immutable, so you shouldnât be using this method after a file has already been uploaded to fit with a blob. If you want to create a derivative blob, you should instead simply create a new blob based on the old one.Prior to uploading, we compute the checksum, which is sent to the service for transit integrity validation. If the checksum does not match what the service receives, an exception will be raised. We also measure the size of theioand store that inbyte_sizeon the blob record. The content type is automatically extracted from theiounless you specify acontent_typeand passidentifyas false.Normally, you do not have to call this method directly at all. Use thecreate_and_upload!class method instead. If you do use this method directly, make sure you are using it on a persistedBlobas otherwise another blobâs data might get overwritten on the service.Source:show|on GitHub# File activestorage/app/models/active_storage/blob.rb, line 260defupload(io,identify:true)unfurlio,identify:identifyupload_without_unfurlingioendurl(expires_in: ActiveStorage.service_urls_expire_in, disposition: :inline, filename: nil, **options)LinkReturns the URL of the blob on the service. This returns a permanent URL for public files, and returns a short-lived URL for private files. Private files are signed, and not for public use. Instead, the URL should only be exposed as a redirect from a stable, possibly authenticated URL. Hiding the URL behind a redirect also allows you to change services without updating all URLs.Source:show|on GitHub# File activestorage/app/models/active_storage/blob.rb, line 231defurl(expires_in:ActiveStorage.service_urls_expire_in,disposition::inline,filename:nil,**options)service.urlkey,expires_in:expires_in,filename:ActiveStorage::Filename.wrap(filename||self.filename),content_type:content_type_for_serving,disposition:forced_disposition_for_serving||disposition,**optionsendvideo?()LinkReturns true if the content_type of this blob is in the video range, like video/mp4.Source:show|on GitHub# File activestorage/app/models/active_storage/blob.rb, line 218defvideo?content_type.start_with?("video")end