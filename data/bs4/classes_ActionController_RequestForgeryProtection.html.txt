Action Controller Request Forgery ProtectionController actions are protected from Cross-Site Request Forgery (CSRF) attacks by including a token in the rendered HTML for your application. This token is stored as a random string in the session, to which an attacker does not have access. When a request reaches your application,Railsverifies the received token with the token in the session. All requests are checked except GET requests as these should be idempotent. Keep in mind that all session-oriented requests are CSRF protected by default, including JavaScript and HTML requests.Since HTML and JavaScript requests are typically made from the browser, we need to ensure to verify request authenticity for the web browser. We can use session-oriented authentication for these types of requests, by using theprotect_from_forgerymethod in our controllers.GET requests are not protected since they donât have side effects like writing to the database and donât leak sensitive information. JavaScript requests are an exception: a third-party site can use a <script> tag to reference a JavaScript URL on your site. When your JavaScript response loads on their site, it executes. With carefully crafted JavaScript on their end, sensitive data in your JavaScript response may be extracted. To prevent this, only XmlHttpRequest (known as XHR or Ajax) requests are allowed to make requests for JavaScript responses.Subclasses ofActionController::Baseare protected by default with the:exceptionstrategy, which raises an ActionController::InvalidAuthenticityToken error on unverified requests.APIs may want to disable this behavior since they are typically designed to be state-less: that is, the requestAPIclient handles the session instead ofRails. One way to achieve this is to use the:null_sessionstrategy instead, which allows unverified requests to be handled, but with an empty session:class ApplicationController < ActionController::Base
  protect_from_forgery with: :null_session
endNote thatAPIonly applications donât include this module or a session middleware by default, and so donât require CSRF protection to be configured.The token parameter is namedauthenticity_tokenby default. The name and value of this token must be added to every layout that renders forms by includingcsrf_meta_tagsin the HTMLhead.Learn more about CSRF attacks and securing your application in theRuby on Rails Security Guide.NamespaceMODULEActionController::RequestForgeryProtection::ClassMethodsMODULEActionController::RequestForgeryProtection::ProtectionMethodsCLASSActionController::RequestForgeryProtection::CookieStoreCLASSActionController::RequestForgeryProtection::SessionStoreMethodsAany_authenticity_token_valid?Ccommit_csrf_token,compare_with_global_token,compare_with_real_token,csrf_token_hmacFform_authenticity_param,form_authenticity_tokenGglobal_csrf_tokenMmark_for_same_origin_verification!,marked_for_same_origin_verification?,mask_tokenNnew,non_xhr_javascript_response?,normalize_action_path,normalize_relative_action_pathPper_form_csrf_token,protect_against_forgery?Rreal_csrf_token,request_authenticity_tokens,reset_csrf_tokenUunmask_tokenVvalid_authenticity_token?,valid_per_form_csrf_token?,valid_request_origin?,verified_request?,verify_authenticity_token,verify_same_origin_requestXxor_byte_stringsIncluded ModulesAbstractController::HelpersAbstractController::CallbacksConstantsAUTHENTICITY_TOKEN_LENGTH=32CSRF_TOKEN="action_controller.csrf_token"NULL_ORIGIN_MESSAGE=<<~MSGClass Public methodsnew(...)LinkSource:show|on GitHub# File actionpack/lib/action_controller/metal/request_forgery_protection.rb, line 364definitialize(...)super@_marked_for_same_origin_verification=nilendInstance Public methodscommit_csrf_token(request)LinkSource:show|on GitHub# File actionpack/lib/action_controller/metal/request_forgery_protection.rb, line 374defcommit_csrf_token(request)# :doc:csrf_token=request.env[CSRF_TOKEN]csrf_token_storage_strategy.store(request,csrf_token)unlesscsrf_token.nil?endreset_csrf_token(request)LinkSource:show|on GitHub# File actionpack/lib/action_controller/metal/request_forgery_protection.rb, line 369defreset_csrf_token(request)# :doc:request.env.delete(CSRF_TOKEN)csrf_token_storage_strategy.reset(request)endInstance Private methodsany_authenticity_token_valid?()LinkChecks if any of the authenticity tokens from the request are valid.Source:show|on GitHub# File actionpack/lib/action_controller/metal/request_forgery_protection.rb, line 467defany_authenticity_token_valid?# :doc:request_authenticity_tokens.any?do|token|valid_authenticity_token?(session,token)endendcompare_with_global_token(token, session = nil)LinkSource:show|on GitHub# File actionpack/lib/action_controller/metal/request_forgery_protection.rb, line 548defcompare_with_global_token(token,session=nil)# :doc:ActiveSupport::SecurityUtils.fixed_length_secure_compare(token,global_csrf_token(session))endcompare_with_real_token(token, session = nil)LinkSource:show|on GitHub# File actionpack/lib/action_controller/metal/request_forgery_protection.rb, line 544defcompare_with_real_token(token,session=nil)# :doc:ActiveSupport::SecurityUtils.fixed_length_secure_compare(token,real_csrf_token(session))endcsrf_token_hmac(session, identifier)LinkSource:show|on GitHub# File actionpack/lib/action_controller/metal/request_forgery_protection.rb, line 585defcsrf_token_hmac(session,identifier)# :doc:OpenSSL::HMAC.digest(OpenSSL::Digest::SHA256.new,real_csrf_token(session),identifier)endform_authenticity_param()LinkThe formâs authenticity parameter. Override to provide your own.Source:show|on GitHub# File actionpack/lib/action_controller/metal/request_forgery_protection.rb, line 605defform_authenticity_param# :doc:params[request_forgery_protection_token]endform_authenticity_token(form_options: {})LinkCreates the authenticity token for the current request.Source:show|on GitHub# File actionpack/lib/action_controller/metal/request_forgery_protection.rb, line 479defform_authenticity_token(form_options:{})# :doc:masked_authenticity_token(form_options:form_options)endglobal_csrf_token(session = nil)LinkSource:show|on GitHub# File actionpack/lib/action_controller/metal/request_forgery_protection.rb, line 581defglobal_csrf_token(session=nil)# :doc:csrf_token_hmac(session,GLOBAL_CSRF_TOKEN_IDENTIFIER)endmark_for_same_origin_verification!()LinkGET requests are checked for cross-origin JavaScript after rendering.Source:show|on GitHub# File actionpack/lib/action_controller/metal/request_forgery_protection.rb, line 437defmark_for_same_origin_verification!# :doc:@_marked_for_same_origin_verification=request.get?endmarked_for_same_origin_verification?()LinkIf theverify_authenticity_tokenbefore_action ran, verify that JavaScript responses are only served to same-origin GET requests.Source:show|on GitHub# File actionpack/lib/action_controller/metal/request_forgery_protection.rb, line 443defmarked_for_same_origin_verification?# :doc:@_marked_for_same_origin_verification||=falseendmask_token(raw_token)LinkSource:show|on GitHub# File actionpack/lib/action_controller/metal/request_forgery_protection.rb, line 537defmask_token(raw_token)# :doc:one_time_pad=SecureRandom.random_bytes(AUTHENTICITY_TOKEN_LENGTH)encrypted_csrf_token=xor_byte_strings(one_time_pad,raw_token)masked_token=one_time_pad+encrypted_csrf_tokenencode_csrf_token(masked_token)endnon_xhr_javascript_response?()LinkCheck for cross-origin JavaScript responses.Source:show|on GitHub# File actionpack/lib/action_controller/metal/request_forgery_protection.rb, line 448defnon_xhr_javascript_response?# :doc:%r(\A(?:text|application)/javascript).match?(media_type)&&!request.xhr?endnormalize_action_path(action_path)LinkSource:show|on GitHub# File actionpack/lib/action_controller/metal/request_forgery_protection.rb, line 635defnormalize_action_path(action_path)# :doc:uri=URI.parse(action_path)ifuri.relative?&&(action_path.blank?||!action_path.start_with?("/"))normalize_relative_action_path(uri.path)elseuri.path.chomp("/")endendnormalize_relative_action_path(rel_action_path)LinkSource:show|on GitHub# File actionpack/lib/action_controller/metal/request_forgery_protection.rb, line 645defnormalize_relative_action_path(rel_action_path)# :doc:uri=URI.parse(request.path)# add the action path to the request.pathuri.path+="/#{rel_action_path}"# relative path with "./path"uri.path.gsub!("/./","/")uri.path.chomp("/")endper_form_csrf_token(session, action_path, method)LinkSource:show|on GitHub# File actionpack/lib/action_controller/metal/request_forgery_protection.rb, line 574defper_form_csrf_token(session,action_path,method)# :doc:csrf_token_hmac(session, [action_path,method.downcase].join("#"))endprotect_against_forgery?()LinkChecks if the controller allows forgery protection.Source:show|on GitHub# File actionpack/lib/action_controller/metal/request_forgery_protection.rb, line 610defprotect_against_forgery?# :doc:allow_forgery_protection&&(!session.respond_to?(:enabled?)||session.enabled?)endreal_csrf_token(_session = nil)LinkSource:show|on GitHub# File actionpack/lib/action_controller/metal/request_forgery_protection.rb, line 566defreal_csrf_token(_session=nil)# :doc:csrf_token=request.env.fetch(CSRF_TOKEN)dorequest.env[CSRF_TOKEN] =csrf_token_storage_strategy.fetch(request)||generate_csrf_tokenenddecode_csrf_token(csrf_token)endrequest_authenticity_tokens()LinkPossible authenticity tokens sent in the request.Source:show|on GitHub# File actionpack/lib/action_controller/metal/request_forgery_protection.rb, line 474defrequest_authenticity_tokens# :doc:[form_authenticity_param,request.x_csrf_token]endunmask_token(masked_token)LinkSource:show|on GitHub# File actionpack/lib/action_controller/metal/request_forgery_protection.rb, line 530defunmask_token(masked_token)# :doc:# Split the token into the one-time pad and the encrypted value and decrypt it.one_time_pad=masked_token[0...AUTHENTICITY_TOKEN_LENGTH]encrypted_csrf_token=masked_token[AUTHENTICITY_TOKEN_LENGTH..-1]xor_byte_strings(one_time_pad,encrypted_csrf_token)endvalid_authenticity_token?(session, encoded_masked_token)LinkChecks the clientâs masked token to see if it matches the session token. Essentially the inverse ofmasked_authenticity_token.Source:show|on GitHub# File actionpack/lib/action_controller/metal/request_forgery_protection.rb, line 500defvalid_authenticity_token?(session,encoded_masked_token)# :doc:ifencoded_masked_token.nil?||encoded_masked_token.empty?||!encoded_masked_token.is_a?(String)returnfalseendbeginmasked_token=decode_csrf_token(encoded_masked_token)rescueArgumentError# encoded_masked_token is invalid Base64returnfalseend# See if it's actually a masked token or not. In order to deploy this code, we# should be able to handle any unmasked tokens that we've issued without error.ifmasked_token.length==AUTHENTICITY_TOKEN_LENGTH# This is actually an unmasked token. This is expected if you have just upgraded# to masked tokens, but should stop happening shortly after installing this gem.compare_with_real_tokenmasked_tokenelsifmasked_token.length==AUTHENTICITY_TOKEN_LENGTH*2csrf_token=unmask_token(masked_token)compare_with_global_token(csrf_token)||compare_with_real_token(csrf_token)||valid_per_form_csrf_token?(csrf_token)elsefalse# Token is malformed.endendvalid_per_form_csrf_token?(token, session = nil)LinkSource:show|on GitHub# File actionpack/lib/action_controller/metal/request_forgery_protection.rb, line 552defvalid_per_form_csrf_token?(token,session=nil)# :doc:ifper_form_csrf_tokenscorrect_token=per_form_csrf_token(session,request.path.chomp("/"),request.request_method)ActiveSupport::SecurityUtils.fixed_length_secure_compare(token,correct_token)elsefalseendendvalid_request_origin?()LinkChecks if the request originated from the same origin by looking at the Origin header.Source:show|on GitHub# File actionpack/lib/action_controller/metal/request_forgery_protection.rb, line 625defvalid_request_origin?# :doc:ifforgery_protection_origin_check# We accept blank origin headers because some user agents don't send it.raiseInvalidAuthenticityToken,NULL_ORIGIN_MESSAGEifrequest.origin=="null"request.origin.nil?||request.origin==request.base_urlelsetrueendendverified_request?()LinkReturns true or false if a request is verified. Checks:Is it a GET or HEAD request? GETs should be safe and idempotentDoes theform_authenticity_tokenmatch the given token value from the params?Does theX-CSRF-Tokenheader match theform_authenticity_token?Source:show|on GitHub# File actionpack/lib/action_controller/metal/request_forgery_protection.rb, line 461defverified_request?# :doc:!protect_against_forgery?||request.get?||request.head?||(valid_request_origin?&&any_authenticity_token_valid?)endverify_authenticity_token()LinkThe actual before_action that is used to verify the CSRF token. Donât override this directly. Provide your own forgery protection strategy instead. If you override, youâll disable same-origin<script>verification.Lean on the protect_from_forgery declaration to mark which actions are due for same-origin request verification. If protect_from_forgery is enabled on an action, this before_action flags its after_action to verify that JavaScript responses are for XHR requests, ensuring they follow the browserâs same-origin policy.Source:show|on GitHub# File actionpack/lib/action_controller/metal/request_forgery_protection.rb, line 389defverify_authenticity_token# :doc:mark_for_same_origin_verification!if!verified_request?logger.warnunverified_request_warning_messageiflogger&&log_warning_on_csrf_failurehandle_unverified_requestendendverify_same_origin_request()LinkIfverify_authenticity_tokenwas run (indicating that we have forgery protection enabled for this request) then also verify that we arenât serving an unauthorized cross-origin response.Source:show|on GitHub# File actionpack/lib/action_controller/metal/request_forgery_protection.rb, line 427defverify_same_origin_request# :doc:ifmarked_for_same_origin_verification?&&non_xhr_javascript_response?iflogger&&log_warning_on_csrf_failurelogger.warnCROSS_ORIGIN_JAVASCRIPT_WARNINGendraiseActionController::InvalidCrossOriginRequest,CROSS_ORIGIN_JAVASCRIPT_WARNINGendendxor_byte_strings(s1, s2)LinkSource:show|on GitHub# File actionpack/lib/action_controller/metal/request_forgery_protection.rb, line 593defxor_byte_strings(s1,s2)# :doc:s2=s2.dupsize=s1.bytesizei=0whilei<sizes2.setbyte(i,s1.getbyte(i)^s2.getbyte(i))i+=1ends2end