Methods#-,<=>,===Aacts_like_time?,advance,ago,at,at_beginning_of_day,at_beginning_of_hour,at_beginning_of_minute,at_end_of_day,at_end_of_hour,at_end_of_minute,at_midday,at_middle_of_day,at_midnight,at_noon,at_with_coercion,at_without_coercionBbeginning_of_day,beginning_of_hour,beginning_of_minuteCchange,compare_with_coercion,compare_without_coercion,currentDdays_in_month,days_in_yearEend_of_day,end_of_hour,end_of_minute,eql?,eql_with_coercion,eql_without_coercionFfind_zone,find_zone!,formatted_offsetIinMmidday,middle_of_day,midnight,minus_with_coercion,minus_without_coercion,minus_without_durationNnext_day,next_month,next_year,noonPprev_day,prev_month,prev_yearRrfc3339Ssec_fraction,seconds_since_midnight,seconds_until_end_of_day,sinceTto_formatted_s,to_fs,to_timeUuse_zoneZzone,zone=Included ModulesDateAndTime::CalculationsDateAndTime::CompatibilityDateAndTime::ZonesConstantsCOMMON_YEAR_DAYS_IN_MONTH=[nil, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]DATE_FORMATS={
db: "%Y-%m-%d %H:%M:%S",
inspect: "%Y-%m-%d %H:%M:%S.%9N %z",
number: "%Y%m%d%H%M%S",
nsec: "%Y%m%d%H%M%S%9N",
usec: "%Y%m%d%H%M%S%6N",
time: "%H:%M",
short: "%d %b %H:%M",
long: "%B %d, %Y %H:%M",
long_ordinal: lambda { |time|
day_format = ActiveSupport::Inflector.ordinalize(time.day)
time.strftime("%B #{day_format}, %Y %H:%M")
},
rfc822: lambda { |time|
offset_format = time.formatted_offset(false)
time.strftime("%a, %d %b %Y %H:%M:%S #{offset_format}")
},
iso8601: lambda { |time| time.iso8601 }
}Attributes[RW]zone_defaultClass Public methods===(other)LinkOverriding case equality method so that it returns true forActiveSupport::TimeWithZoneinstancesSource:show|on GitHub# File activesupport/lib/active_support/core_ext/time/calculations.rb, line 18def===(other)super||(self==Time&&other.is_a?(ActiveSupport::TimeWithZone))endat(time_or_number, *args)LinkAlso aliased as:at_without_coercionAlias for:at_with_coercionat_with_coercion(time_or_number, *args)LinkLayers additional behavior onTime.atso thatActiveSupport::TimeWithZoneandDateTimeinstances can be used when called with a single argumentAlso aliased as:atSource:show|on GitHub# File activesupport/lib/active_support/core_ext/time/calculations.rb, line 45defat_with_coercion(time_or_number,*args)ifargs.empty?iftime_or_number.is_a?(ActiveSupport::TimeWithZone)at_without_coercion(time_or_number.to_r).getlocalelsiftime_or_number.is_a?(DateTime)at_without_coercion(time_or_number.to_f).getlocalelseat_without_coercion(time_or_number)endelseat_without_coercion(time_or_number,*args)endendat_without_coercion(time_or_number, *args)LinkAlias for:atcurrent()LinkReturnsTime.zone.nowwhenTime.zoneorconfig.time_zoneare set, otherwise just returnsTime.now.Source:show|on GitHub# File activesupport/lib/active_support/core_ext/time/calculations.rb, line 39defcurrent::Time.zone?::Time.zone.now:::Time.nowenddays_in_month(month, year = current.year)LinkReturns the number of days in the given month. If no year is specified, it will use the current year.Source:show|on GitHub# File activesupport/lib/active_support/core_ext/time/calculations.rb, line 24defdays_in_month(month,year=current.year)ifmonth==2&&::Date.gregorian_leap?(year)29elseCOMMON_YEAR_DAYS_IN_MONTH[month]endenddays_in_year(year = current.year)LinkReturns the number of days in the given year. If no year is specified, it will use the current year.Source:show|on GitHub# File activesupport/lib/active_support/core_ext/time/calculations.rb, line 34defdays_in_year(year=current.year)days_in_month(2,year)+337endfind_zone(time_zone)LinkReturns a TimeZone instance matching the time zone provided. Accepts the time zone in any format supported byTime.zone=. Returnsnilfor invalid time zones.Time.find_zone "America/New_York" # => #<ActiveSupport::TimeZone @name="America/New_York" ...>
Time.find_zone "NOT-A-TIMEZONE"   # => nilSource:show|on GitHub# File activesupport/lib/active_support/core_ext/time/zones.rb, line 93deffind_zone(time_zone)find_zone!(time_zone)rescuenilendfind_zone!(time_zone)LinkReturns a TimeZone instance matching the time zone provided. Accepts the time zone in any format supported byTime.zone=. Raises anArgumentErrorfor invalid time zones.Time.find_zone! "America/New_York" # => #<ActiveSupport::TimeZone @name="America/New_York" ...>
Time.find_zone! "EST"              # => #<ActiveSupport::TimeZone @name="EST" ...>
Time.find_zone! -5.hours           # => #<ActiveSupport::TimeZone @name="Bogota" ...>
Time.find_zone! nil                # => nil
Time.find_zone! false              # => false
Time.find_zone! "NOT-A-TIMEZONE"   # => ArgumentError: Invalid Timezone: NOT-A-TIMEZONESource:show|on GitHub# File activesupport/lib/active_support/core_ext/time/zones.rb, line 81deffind_zone!(time_zone)returntime_zoneunlesstime_zoneActiveSupport::TimeZone[time_zone]||raise(ArgumentError,"Invalid Timezone: #{time_zone}")endrfc3339(str)LinkCreates aTimeinstance from an RFC 3339 string.Time.rfc3339('1999-12-31T14:00:00-10:00') # => 2000-01-01 00:00:00 -1000If the time or offset components are missing then anArgumentErrorwill be raised.Time.rfc3339('1999-12-31') # => ArgumentError: invalid dateSource:show|on GitHub# File activesupport/lib/active_support/core_ext/time/calculations.rb, line 69defrfc3339(str)parts=Date._rfc3339(str)raiseArgumentError,"invalid date"ifparts.empty?Time.new(parts.fetch(:year),parts.fetch(:mon),parts.fetch(:mday),parts.fetch(:hour),parts.fetch(:min),parts.fetch(:sec)+parts.fetch(:sec_fraction,0),parts.fetch(:offset)
  )enduse_zone(time_zone)LinkAllows override ofTime.zonelocally inside supplied block; resetsTime.zoneto existing value when done.class ApplicationController < ActionController::Base
  around_action :set_time_zone

  private
    def set_time_zone
      Time.use_zone(current_user.timezone) { yield }
    end
endNOTE: This wonât affect anyActiveSupport::TimeWithZoneobjects that have already been created, e.g. any model timestamp attributes that have been read before the block will remain in the applicationâs default timezone.Source:show|on GitHub# File activesupport/lib/active_support/core_ext/time/zones.rb, line 61defuse_zone(time_zone)new_zone=find_zone!(time_zone)beginold_zone,::Time.zone=::Time.zone,new_zoneyieldensure::Time.zone=old_zoneendendzone()LinkReturns the TimeZone for the current request, if this has been set (viaTime.zone=). IfTime.zonehas not been set for the current request, returns the TimeZone specified inconfig.time_zone.Source:show|on GitHub# File activesupport/lib/active_support/core_ext/time/zones.rb, line 14defzone::ActiveSupport::IsolatedExecutionState[:time_zone]||zone_defaultendzone=(time_zone)LinkSetsTime.zoneto a TimeZone object for the current request/thread.This method accepts any of the following:A Rails TimeZone object.An identifier for a Rails TimeZone object (e.g., âEasternTime(US & Canada)â,-5.hours).ATZInfo::Timezoneobject.An identifier for aTZInfo::Timezoneobject (e.g., âAmerica/New_Yorkâ).Hereâs an example of how you might setTime.zoneon a per request basis and reset it when the request is done.current_user.time_zonejust needs to return a string identifying the userâs preferred time zone:class ApplicationController < ActionController::Base
  around_action :set_time_zone

  def set_time_zone
    if logged_in?
      Time.use_zone(current_user.time_zone) { yield }
    else
      yield
    end
  end
endSource:show|on GitHub# File activesupport/lib/active_support/core_ext/time/zones.rb, line 41defzone=(time_zone)::ActiveSupport::IsolatedExecutionState[:time_zone] =find_zone!(time_zone)endInstance Public methods-(other)LinkAlso aliased as:minus_without_duration,minus_without_coercionAlias for:minus_with_coercion<=>(other)LinkAlso aliased as:compare_without_coercionAlias for:compare_with_coercionacts_like_time?()LinkDuck-types as a Time-like class. SeeObject#acts_like?.Source:show|on GitHub# File activesupport/lib/active_support/core_ext/time/acts_like.rb, line 7defacts_like_time?trueendadvance(options)LinkUsesDateto provide preciseTimecalculations for years, months, and days according to the proleptic Gregorian calendar. Theoptionsparameter takes a hash with any of these keys::years,:months,:weeks,:days,:hours,:minutes,:seconds.Time.new(2015, 8, 1, 14, 35, 0).advance(seconds: 1) # => 2015-08-01 14:35:01 -0700
Time.new(2015, 8, 1, 14, 35, 0).advance(minutes: 1) # => 2015-08-01 14:36:00 -0700
Time.new(2015, 8, 1, 14, 35, 0).advance(hours: 1)   # => 2015-08-01 15:35:00 -0700
Time.new(2015, 8, 1, 14, 35, 0).advance(days: 1)    # => 2015-08-02 14:35:00 -0700
Time.new(2015, 8, 1, 14, 35, 0).advance(weeks: 1)   # => 2015-08-08 14:35:00 -0700Just likeDate#advance, increments are applied in order of time units from largest to smallest. This order can affect the result around the end of a month.Source:show|on GitHub# File activesupport/lib/active_support/core_ext/time/calculations.rb, line 187defadvance(options)unlessoptions[:weeks].nil?options[:weeks],partial_weeks=options[:weeks].divmod(1)options[:days] =options.fetch(:days,0)+7*partial_weeksendunlessoptions[:days].nil?options[:days],partial_days=options[:days].divmod(1)options[:hours] =options.fetch(:hours,0)+24*partial_daysendd=to_date.gregorian.advance(options)time_advanced_by_date=change(year:d.year,month:d.month,day:d.day)seconds_to_advance= \options.fetch(:seconds,0)+options.fetch(:minutes,0)*60+options.fetch(:hours,0)*3600ifseconds_to_advance.zero?time_advanced_by_dateelsetime_advanced_by_date.since(seconds_to_advance)endendago(seconds)LinkReturns a newTimerepresenting the time a number of seconds ago, this is basically a wrapper around theNumericextensionSource:show|on GitHub# File activesupport/lib/active_support/core_ext/time/calculations.rb, line 213defago(seconds)since(-seconds)endat_beginning_of_day()LinkAlias for:beginning_of_dayat_beginning_of_hour()LinkAlias for:beginning_of_hourat_beginning_of_minute()LinkAlias for:beginning_of_minuteat_end_of_day()LinkAlias for:end_of_dayat_end_of_hour()LinkAlias for:end_of_hourat_end_of_minute()LinkAlias for:end_of_minuteat_midday()LinkAlias for:middle_of_dayat_middle_of_day()LinkAlias for:middle_of_dayat_midnight()LinkAlias for:beginning_of_dayat_noon()LinkAlias for:middle_of_daybeginning_of_day()LinkReturns a newTimerepresenting the start of the day (0:00)Also aliased as:midnight,at_midnight,at_beginning_of_daySource:show|on GitHub# File activesupport/lib/active_support/core_ext/time/calculations.rb, line 226defbeginning_of_daychange(hour:0)endbeginning_of_hour()LinkReturns a newTimerepresenting the start of the hour (x:00)Also aliased as:at_beginning_of_hourSource:show|on GitHub# File activesupport/lib/active_support/core_ext/time/calculations.rb, line 255defbeginning_of_hourchange(min:0)endbeginning_of_minute()LinkReturns a newTimerepresenting the start of the minute (x:xx:00)Also aliased as:at_beginning_of_minuteSource:show|on GitHub# File activesupport/lib/active_support/core_ext/time/calculations.rb, line 271defbeginning_of_minutechange(sec:0)endchange(options)LinkReturns a newTimewhere one or more of the elements have been changed according to theoptionsparameter. The time options (:hour,:min,:sec,:usec,:nsec) reset cascadingly, so if only the hour is passed, then minute, sec, usec, and nsec is set to 0. If the hour and minute is passed, then sec, usec, and nsec is set to 0. Theoptionsparameter takes a hash with any of these keys::year,:month,:day,:hour,:min,:sec,:usec,:nsec,:offset. Pass either:usecor:nsec, not both.Time.new(2012, 8, 29, 22, 35, 0).change(day: 1)              # => Time.new(2012, 8, 1, 22, 35, 0)
Time.new(2012, 8, 29, 22, 35, 0).change(year: 1981, day: 1)  # => Time.new(1981, 8, 1, 22, 35, 0)
Time.new(2012, 8, 29, 22, 35, 0).change(year: 1981, hour: 0) # => Time.new(1981, 8, 29, 0, 0, 0)Source:show|on GitHub# File activesupport/lib/active_support/core_ext/time/calculations.rb, line 123defchange(options)new_year=options.fetch(:year,year)new_month=options.fetch(:month,month)new_day=options.fetch(:day,day)new_hour=options.fetch(:hour,hour)new_min=options.fetch(:min,options[:hour]?0:min)new_sec=options.fetch(:sec, (options[:hour]||options[:min])?0:sec)new_offset=options.fetch(:offset,nil)ifnew_nsec=options[:nsec]raiseArgumentError,"Can't change both :nsec and :usec at the same time: #{options.inspect}"ifoptions[:usec]new_usec=Rational(new_nsec,1000)elsenew_usec=options.fetch(:usec, (options[:hour]||options[:min]||options[:sec])?0:Rational(nsec,1000))endraiseArgumentError,"argument out of range"ifnew_usec>=1000000new_sec+=Rational(new_usec,1000000)ifnew_offset::Time.new(new_year,new_month,new_day,new_hour,new_min,new_sec,new_offset)elsifutc?::Time.utc(new_year,new_month,new_day,new_hour,new_min,new_sec)elsifzone.respond_to?(:utc_to_local)new_time=::Time.new(new_year,new_month,new_day,new_hour,new_min,new_sec,zone)# When there are two occurrences of a nominal time due to DST ending,# `Time.new` chooses the first chronological occurrence (the one with a# larger UTC offset). However, for `change`, we want to choose the# occurrence that matches this time's UTC offset.## If the new time's UTC offset is larger than this time's UTC offset, the# new time might be a first chronological occurrence. So we add the offset# difference to fast-forward the new time, and check if the result has the# desired UTC offset (i.e. is the second chronological occurrence).offset_difference=new_time.utc_offset-utc_offsetifoffset_difference>0&&(new_time_2=new_time+offset_difference).utc_offset==utc_offsetnew_time_2elsenew_timeendelsifzone::Time.local(new_sec,new_min,new_hour,new_day,new_month,new_year,nil,nil,isdst,nil)else::Time.new(new_year,new_month,new_day,new_hour,new_min,new_sec,utc_offset)endendcompare_with_coercion(other)LinkLayers additional behavior onTime#<=>so thatDateTimeandActiveSupport::TimeWithZoneinstances can be chronologically compared with aTimeAlso aliased as:<=>Source:show|on GitHub# File activesupport/lib/active_support/core_ext/time/calculations.rb, line 317defcompare_with_coercion(other)# we're avoiding Time#to_datetime and Time#to_time because they're expensiveifother.class==Timecompare_without_coercion(other)elsifother.is_a?(Time)# also avoid ActiveSupport::TimeWithZone#to_time before Rails 8.0ifother.respond_to?(:comparable_time)compare_without_coercion(other.comparable_time)elsecompare_without_coercion(other.to_time)endelseto_datetime<=>otherendendcompare_without_coercion(other)LinkAlias for:<=>end_of_day()LinkReturns a newTimerepresenting the end of the day, 23:59:59.999999Also aliased as:at_end_of_daySource:show|on GitHub# File activesupport/lib/active_support/core_ext/time/calculations.rb, line 244defend_of_daychange(hour:23,min:59,sec:59,usec:Rational(999999999,1000)
  )endend_of_hour()LinkReturns a newTimerepresenting the end of the hour, x:59:59.999999Also aliased as:at_end_of_hourSource:show|on GitHub# File activesupport/lib/active_support/core_ext/time/calculations.rb, line 261defend_of_hourchange(min:59,sec:59,usec:Rational(999999999,1000)
  )endend_of_minute()LinkReturns a newTimerepresenting the end of the minute, x:xx:59.999999Also aliased as:at_end_of_minuteSource:show|on GitHub# File activesupport/lib/active_support/core_ext/time/calculations.rb, line 277defend_of_minutechange(sec:59,usec:Rational(999999999,1000)
  )endeql?(other)LinkAlso aliased as:eql_without_coercionAlias for:eql_with_coercioneql_with_coercion(other)LinkLayers additional behavior onTime#eql?so thatActiveSupport::TimeWithZoneinstances can be eql? to an equivalentTimeAlso aliased as:eql?Source:show|on GitHub# File activesupport/lib/active_support/core_ext/time/calculations.rb, line 337defeql_with_coercion(other)# if other is an ActiveSupport::TimeWithZone, coerce a Time instance from it so we can do eql? comparisonother=other.comparable_timeifother.respond_to?(:comparable_time)eql_without_coercion(other)endeql_without_coercion(other)LinkAlias for:eql?formatted_offset(colon = true, alternate_utc_string = nil)LinkReturns a formatted string of the offset from UTC, or an alternative string if the time zone is already UTC.Time.local(2000).formatted_offset        # => "-06:00"
Time.local(2000).formatted_offset(false) # => "-0600"Source:show|on GitHub# File activesupport/lib/active_support/core_ext/time/conversions.rb, line 67defformatted_offset(colon=true,alternate_utc_string=nil)utc?&&alternate_utc_string||ActiveSupport::TimeZone.seconds_to_utc_offset(utc_offset,colon)endin(seconds)LinkAlias for:sincemidday()LinkAlias for:middle_of_daymiddle_of_day()LinkReturns a newTimerepresenting the middle of the day (12:00)Also aliased as:midday,noon,at_midday,at_noon,at_middle_of_daySource:show|on GitHub# File activesupport/lib/active_support/core_ext/time/calculations.rb, line 234defmiddle_of_daychange(hour:12)endmidnight()LinkAlias for:beginning_of_dayminus_with_coercion(other)LinkTime#-can also be used to determine the number of seconds between twoTimeinstances. Weâre layering on additional behavior so thatActiveSupport::TimeWithZoneinstances are coerced into values thatTime#-will recognizeAlso aliased as:-Source:show|on GitHub# File activesupport/lib/active_support/core_ext/time/calculations.rb, line 308defminus_with_coercion(other)other=other.comparable_timeifother.respond_to?(:comparable_time)other.is_a?(DateTime)?to_f-other.to_f:minus_without_coercion(other)endminus_without_coercion(other)LinkAlias for:-minus_without_duration(other)LinkAlias for:-next_day(days = 1)LinkReturns a new time the specified number of days in the future.Source:show|on GitHub# File activesupport/lib/active_support/core_ext/time/calculations.rb, line 351defnext_day(days=1)advance(days:days)endnext_month(months = 1)LinkReturns a new time the specified number of months in the future.Source:show|on GitHub# File activesupport/lib/active_support/core_ext/time/calculations.rb, line 361defnext_month(months=1)advance(months:months)endnext_year(years = 1)LinkReturns a new time the specified number of years in the future.Source:show|on GitHub# File activesupport/lib/active_support/core_ext/time/calculations.rb, line 371defnext_year(years=1)advance(years:years)endnoon()LinkAlias for:middle_of_dayprev_day(days = 1)LinkReturns a new time the specified number of days ago.Source:show|on GitHub# File activesupport/lib/active_support/core_ext/time/calculations.rb, line 346defprev_day(days=1)advance(days:-days)endprev_month(months = 1)LinkReturns a new time the specified number of months ago.Source:show|on GitHub# File activesupport/lib/active_support/core_ext/time/calculations.rb, line 356defprev_month(months=1)advance(months:-months)endprev_year(years = 1)LinkReturns a new time the specified number of years ago.Source:show|on GitHub# File activesupport/lib/active_support/core_ext/time/calculations.rb, line 366defprev_year(years=1)advance(years:-years)endsec_fraction()LinkReturns the fraction of a second as aRationalTime.new(2012, 8, 29, 0, 0, 0.5).sec_fraction # => (1/2)Source:show|on GitHub# File activesupport/lib/active_support/core_ext/time/calculations.rb, line 107defsec_fractionsubsecendseconds_since_midnight()LinkReturns the number of seconds since 00:00:00.Time.new(2012, 8, 29,  0,  0,  0).seconds_since_midnight # => 0.0
Time.new(2012, 8, 29, 12, 34, 56).seconds_since_midnight # => 45296.0
Time.new(2012, 8, 29, 23, 59, 59).seconds_since_midnight # => 86399.0Source:show|on GitHub# File activesupport/lib/active_support/core_ext/time/calculations.rb, line 91defseconds_since_midnightto_i-change(hour:0).to_i+(usec/1.0e+6)endseconds_until_end_of_day()LinkReturns the number of seconds until 23:59:59.Time.new(2012, 8, 29,  0,  0,  0).seconds_until_end_of_day # => 86399
Time.new(2012, 8, 29, 12, 34, 56).seconds_until_end_of_day # => 41103
Time.new(2012, 8, 29, 23, 59, 59).seconds_until_end_of_day # => 0Source:show|on GitHub# File activesupport/lib/active_support/core_ext/time/calculations.rb, line 100defseconds_until_end_of_dayend_of_day.to_i-to_iendsince(seconds)LinkReturns a newTimerepresenting the time a number of seconds since the instance timeAlso aliased as:inSource:show|on GitHub# File activesupport/lib/active_support/core_ext/time/calculations.rb, line 218defsince(seconds)self+secondsrescueto_datetime.since(seconds)endto_formatted_s(format = :default)LinkAlias for:to_fsto_fs(format = :default)LinkConverts to a formatted string. SeeDATE_FORMATSfor built-in formats.This method is aliased toto_formatted_s.time = Time.now                    # => 2007-01-18 06:10:17 -06:00

time.to_fs(:time)                  # => "06:10"
time.to_formatted_s(:time)         # => "06:10"

time.to_fs(:db)           # => "2007-01-18 06:10:17"
time.to_fs(:number)       # => "20070118061017"
time.to_fs(:short)        # => "18 Jan 06:10"
time.to_fs(:long)         # => "January 18, 2007 06:10"
time.to_fs(:long_ordinal) # => "January 18th, 2007 06:10"
time.to_fs(:rfc822)       # => "Thu, 18 Jan 2007 06:10:17 -0600"
time.to_fs(:iso8601)      # => "2007-01-18T06:10:17-06:00"Adding your own time formats toto_fsYou can add your own formats to theTime::DATE_FORMATShash. Use the format name as the hash key and either a strftime string or Proc instance that takes a time argument as the value.# config/initializers/time_formats.rb
Time::DATE_FORMATS[:month_and_year] = '%B %Y'
Time::DATE_FORMATS[:short_ordinal]  = ->(time) { time.strftime("%B #{time.day.ordinalize}") }Also aliased as:to_formatted_sSource:show|on GitHub# File activesupport/lib/active_support/core_ext/time/conversions.rb, line 53defto_fs(format=:default)ifformatter=DATE_FORMATS[format]formatter.respond_to?(:call)?formatter.call(self).to_s:strftime(formatter)elseto_sendendto_time()LinkEither returnselfor the time in the local system timezone depending on the setting ofActiveSupport.to_time_preserves_timezone.Source:show|on GitHub# File activesupport/lib/active_support/core_ext/time/compatibility.rb, line 13defto_timepreserve_timezone?self:getlocalend