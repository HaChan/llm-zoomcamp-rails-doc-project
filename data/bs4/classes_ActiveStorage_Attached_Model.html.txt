Active Storage Attached ModelProvides the class-level DSL for declaring an Active Record modelâs attachments.Methods#*_attachment,*_attachments,*_blob,*_blobsHhas_many_attached,has_one_attachedWwith_attached_*Instance Public methods*_attachmentLinkReturns the attachment for thehas_one_attached.User.last.avatar_attachmentSource:on GitHub# File activestorage/lib/active_storage/attached/model.rb, line 13*_attachmentsLinkReturns the attachments for thehas_many_attached.Gallery.last.photos_attachmentsSource:on GitHub# File activestorage/lib/active_storage/attached/model.rb, line 20*_blobLinkReturns the blob for thehas_one_attachedattachment.User.last.avatar_blobSource:on GitHub# File activestorage/lib/active_storage/attached/model.rb, line 27*_blobsLinkReturns the blobs for thehas_many_attachedattachments.Gallery.last.photos_blobsSource:on GitHub# File activestorage/lib/active_storage/attached/model.rb, line 34has_many_attached(name, dependent: :purge_later, service: nil, strict_loading: false)LinkSpecifies the relation between multiple attachments and the model.class Gallery < ApplicationRecord
  has_many_attached :photos
endThere are no columns defined on the model side, Active Storage takes care of the mapping between your records and the attachments.To avoid N+1 queries, you can include the attached blobs in your query like so:Gallery.where(user: Current.user).with_attached_photosUnder the covers, this relationship is implemented as ahas_manyassociation to aActiveStorage::Attachmentrecord and ahas_many-throughassociation to aActiveStorage::Blobrecord. These associations are available asphotos_attachmentsandphotos_blobs. But you shouldnât need to work with these associations directly in most circumstances.The system has been designed to having you go through theActiveStorage::Attached::Manyproxy that provides the dynamic proxy to the associations and factory methods, like#attach.The:dependentoption defaults to:purge_later. This means the attachments will be purged (i.e. destroyed) in the background whenever the record is destroyed. If an ActiveJob::Backend queue adapter is not set in the application set it topurgeinstead.If you need the attachment to use a service which differs from the globally configured one, pass the:serviceoption. For example:class Gallery < ActiveRecord::Base
  has_many_attached :photos, service: :s3
end:servicecan also be specified as a proc, and it will be called with the model instance:class Gallery < ActiveRecord::Base
  has_many_attached :photos, service: ->(gallery) { gallery.personal? ? :personal_s3 : :s3 }
endIf you need to enablestrict_loadingto prevent lazy loading of attachments, pass the:strict_loadingoption. You can do:class Gallery < ApplicationRecord
  has_many_attached :photos, strict_loading: true
endNote: Active Storage relies on polymorphic associations, which in turn store class names in the database. When renaming classes that usehas_many, make sure to also update the class names in theactive_storage_attachments.record_typepolymorphic type column of the corresponding rows.Source:show|on GitHub# File activestorage/lib/active_storage/attached/model.rb, line 206defhas_many_attached(name,dependent::purge_later,service:nil,strict_loading:false)ActiveStorage::Blob.validate_service_configuration(service,self,name)unlessservice.is_a?(Proc)generated_association_methods.class_eval<<-CODE,__FILE__,__LINE__+1# frozen_string_literal: true
          def #{name}
            @active_storage_attached ||= {}
            @active_storage_attached[:#{name}] ||= ActiveStorage::Attached::Many.new("#{name}", self)
          end

          def #{name}=(attachables)
            attachables = Array(attachables).compact_blank
            pending_uploads = attachment_changes["#{name}"].try(:pending_uploads)

            attachment_changes["#{name}"] = if attachables.none?
              ActiveStorage::Attached::Changes::DeleteMany.new("#{name}", self)
            else
              ActiveStorage::Attached::Changes::CreateMany.new("#{name}", self, attachables, pending_uploads: pending_uploads)
            end
          endCODEhas_many:"#{name}_attachments",->{where(name:name) },as::record,class_name:"ActiveStorage::Attachment",inverse_of::record,dependent::destroy,strict_loading:strict_loadinghas_many:"#{name}_blobs",through::"#{name}_attachments",class_name:"ActiveStorage::Blob",source::blob,strict_loading:strict_loadingscope:"with_attached_#{name}",->{ifActiveStorage.track_variantsincludes("#{name}_attachments":{blob:{variant_records:{image_attachment::blob},preview_image_attachment:{blob:{variant_records:{image_attachment::blob} } }
            } })elseincludes("#{name}_attachments"::blob)end}after_save{attachment_changes[name.to_s]&.save}after_commit(on:%i[ create update ]) {attachment_changes.delete(name.to_s).try(:upload) }reflection=ActiveRecord::Reflection.create(:has_many_attached,name,nil,
          {dependent:dependent,service_name:service},self)yieldreflectionifblock_given?ActiveRecord::Reflection.add_attachment_reflection(self,name,reflection)endhas_one_attached(name, dependent: :purge_later, service: nil, strict_loading: false)LinkSpecifies the relation between a single attachment and the model.class User < ApplicationRecord
  has_one_attached :avatar
endThere is no column defined on the model side, Active Storage takes care of the mapping between your records and the attachment.To avoid N+1 queries, you can include the attached blobs in your query like so:User.with_attached_avatarUnder the covers, this relationship is implemented as ahas_oneassociation to aActiveStorage::Attachmentrecord and ahas_one-throughassociation to aActiveStorage::Blobrecord. These associations are available asavatar_attachmentandavatar_blob. But you shouldnât need to work with these associations directly in most circumstances.The system has been designed to having you go through theActiveStorage::Attached::Oneproxy that provides the dynamic proxy to the associations and factory methods, likeattach.The:dependentoption defaults to:purge_later. This means the attachment will be purged (i.e. destroyed) in the background whenever the record is destroyed. If an ActiveJob::Backend queue adapter is not set in the application set it topurgeinstead.If you need the attachment to use a service which differs from the globally configured one, pass the:serviceoption. For example:class User < ActiveRecord::Base
  has_one_attached :avatar, service: :s3
end:servicecan also be specified as a proc, and it will be called with the model instance:class User < ActiveRecord::Base
  has_one_attached :avatar, service: ->(user) { user.in_europe_region? ? :s3_europe : :s3_usa }
endIf you need to enablestrict_loadingto prevent lazy loading of attachment, pass the:strict_loadingoption. You can do:class User < ApplicationRecord
  has_one_attached :avatar, strict_loading: true
endNote: Active Storage relies on polymorphic associations, which in turn store class names in the database. When renaming classes that usehas_one_attached, make sure to also update the class names in theactive_storage_attachments.record_typepolymorphic type column of the corresponding rows.Source:show|on GitHub# File activestorage/lib/active_storage/attached/model.rb, line 106defhas_one_attached(name,dependent::purge_later,service:nil,strict_loading:false)ActiveStorage::Blob.validate_service_configuration(service,self,name)unlessservice.is_a?(Proc)generated_association_methods.class_eval<<-CODE,__FILE__,__LINE__+1# frozen_string_literal: true
          def #{name}
            @active_storage_attached ||= {}
            @active_storage_attached[:#{name}] ||= ActiveStorage::Attached::One.new("#{name}", self)
          end

          def #{name}=(attachable)
            attachment_changes["#{name}"] =
              if attachable.nil? || attachable == ""
                ActiveStorage::Attached::Changes::DeleteOne.new("#{name}", self)
              else
                ActiveStorage::Attached::Changes::CreateOne.new("#{name}", self, attachable)
              end
          endCODEhas_one:"#{name}_attachment",->{where(name:name) },class_name:"ActiveStorage::Attachment",as::record,inverse_of::record,dependent::destroy,strict_loading:strict_loadinghas_one:"#{name}_blob",through::"#{name}_attachment",class_name:"ActiveStorage::Blob",source::blob,strict_loading:strict_loadingscope:"with_attached_#{name}",->{ifActiveStorage.track_variantsincludes("#{name}_attachment":{blob:{variant_records:{image_attachment::blob},preview_image_attachment:{blob:{variant_records:{image_attachment::blob} } }
            } })elseincludes("#{name}_attachment"::blob)end}after_save{attachment_changes[name.to_s]&.save}after_commit(on:%i[ create update ]) {attachment_changes.delete(name.to_s).try(:upload) }reflection=ActiveRecord::Reflection.create(:has_one_attached,name,nil,
          {dependent:dependent,service_name:service},self)yieldreflectionifblock_given?ActiveRecord::Reflection.add_attachment_reflection(self,name,reflection)endwith_attached_*LinkIncludes the attached blobs in your query to avoid N+1 queries.IfActiveStorage.track_variantsis enabled, it will also include the variants record and their attached blobs.User.with_attached_avatarUse the plural form forhas_many_attached:Gallery.with_attached_photosSource:show|on GitHub# File activestorage/lib/active_storage/attached/model.rb, line 54class_methodsdo# Specifies the relation between a single attachment and the model.##   class User < ApplicationRecord#     has_one_attached :avatar#   end## There is no column defined on the model side, Active Storage takes# care of the mapping between your records and the attachment.## To avoid N+1 queries, you can include the attached blobs in your query like so:##   User.with_attached_avatar## Under the covers, this relationship is implemented as a +has_one+ association to a# ActiveStorage::Attachment record and a +has_one-through+ association to a# ActiveStorage::Blob record. These associations are available as +avatar_attachment+# and +avatar_blob+. But you shouldn't need to work with these associations directly in# most circumstances.## The system has been designed to having you go through the ActiveStorage::Attached::One# proxy that provides the dynamic proxy to the associations and factory methods, like +attach+.## The +:dependent+ option defaults to +:purge_later+. This means the attachment will be# purged (i.e. destroyed) in the background whenever the record is destroyed.# If an ActiveJob::Backend queue adapter is not set in the application set it to# +purge+ instead.## If you need the attachment to use a service which differs from the globally configured one,# pass the +:service+ option. For example:##   class User < ActiveRecord::Base#     has_one_attached :avatar, service: :s3#   end## +:service+ can also be specified as a proc, and it will be called with the model instance:##   class User < ActiveRecord::Base#     has_one_attached :avatar, service: ->(user) { user.in_europe_region? ? :s3_europe : :s3_usa }#   end## If you need to enable +strict_loading+ to prevent lazy loading of attachment,# pass the +:strict_loading+ option. You can do:##   class User < ApplicationRecord#     has_one_attached :avatar, strict_loading: true#   end## Note: Active Storage relies on polymorphic associations, which in turn store class names in the database.# When renaming classes that use <tt>has_one_attached</tt>, make sure to also update the class names in the# <tt>active_storage_attachments.record_type</tt> polymorphic type column of# the corresponding rows.defhas_one_attached(name,dependent::purge_later,service:nil,strict_loading:false)ActiveStorage::Blob.validate_service_configuration(service,self,name)unlessservice.is_a?(Proc)generated_association_methods.class_eval<<-CODE,__FILE__,__LINE__+1# frozen_string_literal: true
          def #{name}
            @active_storage_attached ||= {}
            @active_storage_attached[:#{name}] ||= ActiveStorage::Attached::One.new("#{name}", self)
          end

          def #{name}=(attachable)
            attachment_changes["#{name}"] =
              if attachable.nil? || attachable == ""
                ActiveStorage::Attached::Changes::DeleteOne.new("#{name}", self)
              else
                ActiveStorage::Attached::Changes::CreateOne.new("#{name}", self, attachable)
              end
          endCODEhas_one:"#{name}_attachment",->{where(name:name) },class_name:"ActiveStorage::Attachment",as::record,inverse_of::record,dependent::destroy,strict_loading:strict_loadinghas_one:"#{name}_blob",through::"#{name}_attachment",class_name:"ActiveStorage::Blob",source::blob,strict_loading:strict_loadingscope:"with_attached_#{name}",->{ifActiveStorage.track_variantsincludes("#{name}_attachment":{blob:{variant_records:{image_attachment::blob},preview_image_attachment:{blob:{variant_records:{image_attachment::blob} } }
            } })elseincludes("#{name}_attachment"::blob)end}after_save{attachment_changes[name.to_s]&.save}after_commit(on:%i[ create update ]) {attachment_changes.delete(name.to_s).try(:upload) }reflection=ActiveRecord::Reflection.create(:has_one_attached,name,nil,
          {dependent:dependent,service_name:service},self)yieldreflectionifblock_given?ActiveRecord::Reflection.add_attachment_reflection(self,name,reflection)end# Specifies the relation between multiple attachments and the model.##   class Gallery < ApplicationRecord#     has_many_attached :photos#   end## There are no columns defined on the model side, Active Storage takes# care of the mapping between your records and the attachments.## To avoid N+1 queries, you can include the attached blobs in your query like so:##   Gallery.where(user: Current.user).with_attached_photos## Under the covers, this relationship is implemented as a +has_many+ association to a# ActiveStorage::Attachment record and a +has_many-through+ association to a# ActiveStorage::Blob record. These associations are available as +photos_attachments+# and +photos_blobs+. But you shouldn't need to work with these associations directly in# most circumstances.## The system has been designed to having you go through the ActiveStorage::Attached::Many# proxy that provides the dynamic proxy to the associations and factory methods, like +#attach+.## The +:dependent+ option defaults to +:purge_later+. This means the attachments will be# purged (i.e. destroyed) in the background whenever the record is destroyed.# If an ActiveJob::Backend queue adapter is not set in the application set it to# +purge+ instead.## If you need the attachment to use a service which differs from the globally configured one,# pass the +:service+ option. For example:##   class Gallery < ActiveRecord::Base#     has_many_attached :photos, service: :s3#   end## +:service+ can also be specified as a proc, and it will be called with the model instance:##   class Gallery < ActiveRecord::Base#     has_many_attached :photos, service: ->(gallery) { gallery.personal? ? :personal_s3 : :s3 }#   end## If you need to enable +strict_loading+ to prevent lazy loading of attachments,# pass the +:strict_loading+ option. You can do:##   class Gallery < ApplicationRecord#     has_many_attached :photos, strict_loading: true#   end## Note: Active Storage relies on polymorphic associations, which in turn store class names in the database.# When renaming classes that use <tt>has_many</tt>, make sure to also update the class names in the# <tt>active_storage_attachments.record_type</tt> polymorphic type column of# the corresponding rows.defhas_many_attached(name,dependent::purge_later,service:nil,strict_loading:false)ActiveStorage::Blob.validate_service_configuration(service,self,name)unlessservice.is_a?(Proc)generated_association_methods.class_eval<<-CODE,__FILE__,__LINE__+1# frozen_string_literal: true
          def #{name}
            @active_storage_attached ||= {}
            @active_storage_attached[:#{name}] ||= ActiveStorage::Attached::Many.new("#{name}", self)
          end

          def #{name}=(attachables)
            attachables = Array(attachables).compact_blank
            pending_uploads = attachment_changes["#{name}"].try(:pending_uploads)

            attachment_changes["#{name}"] = if attachables.none?
              ActiveStorage::Attached::Changes::DeleteMany.new("#{name}", self)
            else
              ActiveStorage::Attached::Changes::CreateMany.new("#{name}", self, attachables, pending_uploads: pending_uploads)
            end
          endCODEhas_many:"#{name}_attachments",->{where(name:name) },as::record,class_name:"ActiveStorage::Attachment",inverse_of::record,dependent::destroy,strict_loading:strict_loadinghas_many:"#{name}_blobs",through::"#{name}_attachments",class_name:"ActiveStorage::Blob",source::blob,strict_loading:strict_loadingscope:"with_attached_#{name}",->{ifActiveStorage.track_variantsincludes("#{name}_attachments":{blob:{variant_records:{image_attachment::blob},preview_image_attachment:{blob:{variant_records:{image_attachment::blob} } }
            } })elseincludes("#{name}_attachments"::blob)end}after_save{attachment_changes[name.to_s]&.save}after_commit(on:%i[ create update ]) {attachment_changes.delete(name.to_s).try(:upload) }reflection=ActiveRecord::Reflection.create(:has_many_attached,name,nil,
          {dependent:dependent,service_name:service},self)yieldreflectionifblock_given?ActiveRecord::Reflection.add_attachment_reflection(self,name,reflection)endend