This is a default queue implementation that ships withNotifications. It just pushes events to all registered log subscribers.This class is thread safe. All methods are reentrant.NamespaceMODULEActiveSupport::Notifications::Fanout::SubscribersCLASSActiveSupport::Notifications::Fanout::HandleMethodsAall_listeners_forBbuild_handleFfinishLlisteners_for,listening?NnewPpublish,publish_eventSstart,subscribeUunsubscribeWwaitClass Public methodsnew()LinkSource:show|on GitHub# File activesupport/lib/active_support/notifications/fanout.rb, line 51definitialize@mutex=Mutex.new@string_subscribers=Concurrent::Map.new{|h,k|h.compute_if_absent(k) { [] } }@other_subscribers= []@all_listeners_for=Concurrent::Map.new@groups_for=Concurrent::Map.new@silenceable_groups_for=Concurrent::Map.newendInstance Public methodsall_listeners_for(name)LinkSource:show|on GitHub# File activesupport/lib/active_support/notifications/fanout.rb, line 298defall_listeners_for(name)# this is correctly done double-checked locking (Concurrent::Map's lookups have volatile semantics)@all_listeners_for[name]||@mutex.synchronizedo# use synchronisation when accessing @subscribers@all_listeners_for[name]||=@string_subscribers[name]+@other_subscribers.select{|s|s.subscribed_to?(name) }endendbuild_handle(name, id, payload)LinkSource:show|on GitHub# File activesupport/lib/active_support/notifications/fanout.rb, line 273defbuild_handle(name,id,payload)Handle.new(self,name,id,payload)endfinish(name, id, payload, listeners = nil)LinkSource:show|on GitHub# File activesupport/lib/active_support/notifications/fanout.rb, line 284deffinish(name,id,payload,listeners=nil)handle_stack=IsolatedExecutionState[:_fanout_handle_stack]handle=handle_stack.pophandle.finish_with_values(name,id,payload)endlisteners_for(name)LinkSource:show|on GitHub# File activesupport/lib/active_support/notifications/fanout.rb, line 307deflisteners_for(name)all_listeners_for(name).reject{|s|s.silenced?(name) }endlistening?(name)LinkSource:show|on GitHub# File activesupport/lib/active_support/notifications/fanout.rb, line 311deflistening?(name)all_listeners_for(name).any?{|s|!s.silenced?(name) }endpublish(name, *args)LinkSource:show|on GitHub# File activesupport/lib/active_support/notifications/fanout.rb, line 290defpublish(name,*args)iterate_guarding_exceptions(listeners_for(name)) {|s|s.publish(name,*args) }endpublish_event(event)LinkSource:show|on GitHub# File activesupport/lib/active_support/notifications/fanout.rb, line 294defpublish_event(event)iterate_guarding_exceptions(listeners_for(event.name)) {|s|s.publish_event(event) }endstart(name, id, payload)LinkSource:show|on GitHub# File activesupport/lib/active_support/notifications/fanout.rb, line 277defstart(name,id,payload)handle_stack= (IsolatedExecutionState[:_fanout_handle_stack]||=[])handle=build_handle(name,id,payload)handle_stack<<handlehandle.startendsubscribe(pattern = nil, callable = nil, monotonic: false, &block)LinkSource:show|on GitHub# File activesupport/lib/active_support/notifications/fanout.rb, line 65defsubscribe(pattern=nil,callable=nil,monotonic:false,&block)subscriber=Subscribers.new(pattern,callable||block,monotonic)@mutex.synchronizedocasepatternwhenString@string_subscribers[pattern]<<subscriberclear_cache(pattern)whenNilClass,Regexp@other_subscribers<<subscriberclear_cacheelseraiseArgumentError,"pattern must be specified as a String, Regexp or empty"endendsubscriberendunsubscribe(subscriber_or_name)LinkSource:show|on GitHub# File activesupport/lib/active_support/notifications/fanout.rb, line 82defunsubscribe(subscriber_or_name)@mutex.synchronizedocasesubscriber_or_namewhenString@string_subscribers[subscriber_or_name].clearclear_cache(subscriber_or_name)@other_subscribers.each{|sub|sub.unsubscribe!(subscriber_or_name) }elsepattern=subscriber_or_name.try(:pattern)ifString===pattern@string_subscribers[pattern].delete(subscriber_or_name)clear_cache(pattern)else@other_subscribers.delete(subscriber_or_name)clear_cacheendendendendwait()LinkThis is a sync queue, so there is no waiting.Source:show|on GitHub# File activesupport/lib/active_support/notifications/fanout.rb, line 316defwaitend