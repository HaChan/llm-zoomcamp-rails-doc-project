NamespaceCLASSActionView::Digestor::InjectedCLASSActionView::Digestor::MissingCLASSActionView::Digestor::NodeCLASSActionView::Digestor::NullLoggerCLASSActionView::Digestor::PartialMethodsDdigestLloggerTtreeClass Public methodsdigest(name:, format: nil, finder:, dependencies: nil)LinkSupported options:name-Templatenameformat-Templateformatfinder- An instance ofActionView::LookupContextdependencies- An array of dependent viewsSource:show|on GitHub# File actionview/lib/action_view/digestor.rb, line 16defdigest(name:,format:nil,finder:,dependencies:nil)ifdependencies.nil?||dependencies.empty?cache_key="#{name}.#{format}"elsedependencies_suffix=dependencies.flatten.tap(&:compact!).join(".")cache_key="#{name}.#{format}.#{dependencies_suffix}"end# this is a correctly done double-checked locking idiom# (Concurrent::Map's lookups have volatile semantics)finder.digest_cache[cache_key]||@@digest_mutex.synchronizedofinder.digest_cache.fetch(cache_key)do# re-check under lockpath=TemplatePath.parse(name)root=tree(path.to_s,finder,path.partial?)dependencies.eachdo|injected_dep|root.children<<Injected.new(injected_dep,nil,nil)endifdependenciesfinder.digest_cache[cache_key] =root.digest(finder)endendendlogger()LinkSource:show|on GitHub# File actionview/lib/action_view/digestor.rb, line 38defloggerActionView::Base.logger||NullLoggerendtree(name, finder, partial = false, seen = {})LinkCreate a dependency tree for template namedname.Source:show|on GitHub# File actionview/lib/action_view/digestor.rb, line 43deftree(name,finder,partial=false,seen= {})logical_name=name.gsub(%r|/_|,"/")interpolated=name.include?("#")path=TemplatePath.parse(name)if!interpolated&&(template=find_template(finder,path.name, [path.prefix],partial, []))ifnode=seen[template.identifier]# handle cycles in the treenodeelsenode=seen[template.identifier] =Node.create(name,logical_name,template,partial)deps=DependencyTracker.find_dependencies(name,template,finder.view_paths)deps.uniq{|n|n.gsub(%r|/_|,"/") }.eachdo|dep_file|node.children<<tree(dep_file,finder,true,seen)endnodeendelseunlessinterpolated# Dynamic template partial names can never be trackedlogger.error"  Couldn't find template for digesting: #{name}"endseen[name]||=Missing.new(name,logical_name,nil)endend