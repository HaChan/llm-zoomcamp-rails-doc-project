MethodsAadd_exclusion_constraint,add_foreign_key,add_unique_constraintCclient_min_messages,client_min_messages=,collation,create_database,create_schema,ctype,current_database,current_schemaDdrop_schemaEencoding,exclusion_constraintsFforeign_keys,foreign_table_exists?,foreign_tablesIindex_name_exists?Rremove_exclusion_constraint,remove_unique_constraint,rename_index,rename_tableSschema_exists?,schema_names,schema_search_path,schema_search_path=,serial_sequenceUunique_constraintsVvalidate_check_constraint,validate_constraint,validate_foreign_keyInstance Public methodsadd_exclusion_constraint(table_name, expression, **options)LinkAdds a new exclusion constraint to the table.expressionis aStringrepresentation of a list of exclusion elements and operators.add_exclusion_constraint :products, "price WITH =, availability_range WITH &&", using: :gist, name: "price_check"generates:ALTER TABLE "products" ADD CONSTRAINT price_check EXCLUDE USING gist (price WITH =, availability_range WITH &&)Theoptionshash can include the following keys::nameThe constraint name. Defaults toexcl_rails_<identifier>.:deferrableSpecify whether or not the exclusion constraint should be deferrable. Valid values arefalseor:immediateor:deferredto specify the default behavior. Defaults tofalse.:usingSpecify which index method to use when creating this exclusion constraint (e.g.:btree,:gistetc).:whereSpecify an exclusion constraint on a subset of the table (internally PostgreSQL creates a partial index for this).Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/postgresql/schema_statements.rb, line 697defadd_exclusion_constraint(table_name,expression,**options)options=exclusion_constraint_options(table_name,expression,options)at=create_alter_table(table_name)at.add_exclusion_constraint(expression,options)executeschema_creation.accept(at)endadd_foreign_key(from_table, to_table, **options)LinkSource:show|on GitHub# File activerecord/lib/active_record/connection_adapters/postgresql/schema_statements.rb, line 532defadd_foreign_key(from_table,to_table,**options)assert_valid_deferrable(options[:deferrable])superendadd_unique_constraint(table_name, column_name = nil, **options)LinkAdds a new unique constraint to the table.add_unique_constraint :sections, [:position], deferrable: :deferred, name: "unique_position"generates:ALTER TABLE "sections" ADD CONSTRAINT unique_position UNIQUE (position) DEFERRABLE INITIALLY DEFERREDIf you want to change an existing unique index to deferrable, you can use :using_index to create deferrable unique constraints.add_unique_constraint :sections, deferrable: :deferred, name: "unique_position", using_index: "index_sections_on_position"Theoptionshash can include the following keys::nameThe constraint name. Defaults touniq_rails_<identifier>.:deferrableSpecify whether or not the unique constraint should be deferrable. Valid values arefalseor:immediateor:deferredto specify the default behavior. Defaults tofalse.:using_indexTo specify an existing unique index name. Defaults tonil.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/postgresql/schema_statements.rb, line 748defadd_unique_constraint(table_name,column_name=nil,**options)options=unique_constraint_options(table_name,column_name,options)at=create_alter_table(table_name)at.add_unique_constraint(column_name,options)executeschema_creation.accept(at)endclient_min_messages()LinkReturns the current client message level.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/postgresql/schema_statements.rb, line 247defclient_min_messagesquery_value("SHOW client_min_messages","SCHEMA")endclient_min_messages=(level)LinkSet the client message level.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/postgresql/schema_statements.rb, line 252defclient_min_messages=(level)internal_execute("SET client_min_messages TO '#{level}'")endcollation()LinkReturns the current database collation.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/postgresql/schema_statements.rb, line 191defcollationquery_value("SELECT datcollate FROM pg_database WHERE datname = current_database()","SCHEMA")endcreate_database(name, options = {})LinkCreate a new PostgreSQL database. Options include:owner,:template,:encoding(defaults to utf8),:collation,:ctype,:tablespace, and:connection_limit(note thatMySQLuses:charsetwhile PostgreSQL uses:encoding).Example:create_database config[:database], config
create_database 'foo_development', encoding: 'unicode'Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/postgresql/schema_statements.rb, line 22defcreate_database(name,options= {})options= {encoding:"utf8"}.merge!(options.symbolize_keys)option_string=options.each_with_object(+"")do|(key,value),memo|memo<<casekeywhen:owner" OWNER = \"#{value}\""when:template" TEMPLATE = \"#{value}\""when:encoding" ENCODING = '#{value}'"when:collation" LC_COLLATE = '#{value}'"when:ctype" LC_CTYPE = '#{value}'"when:tablespace" TABLESPACE = \"#{value}\""when:connection_limit" CONNECTION LIMIT = #{value}"else""endendexecute"CREATE DATABASE #{quote_table_name(name)}#{option_string}"endcreate_schema(schema_name, force: nil, if_not_exists: nil)LinkCreates a schema for the given schema name.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/postgresql/schema_statements.rb, line 212defcreate_schema(schema_name,force:nil,if_not_exists:nil)ifforce&&if_not_existsraiseArgumentError,"Options `:force` and `:if_not_exists` cannot be used simultaneously."endifforcedrop_schema(schema_name,if_exists:true)endexecute("CREATE SCHEMA#{' IF NOT EXISTS' if if_not_exists} #{quote_schema_name(schema_name)}")endctype()LinkReturns the current database ctype.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/postgresql/schema_statements.rb, line 196defctypequery_value("SELECT datctype FROM pg_database WHERE datname = current_database()","SCHEMA")endcurrent_database()LinkReturns the current database name.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/postgresql/schema_statements.rb, line 176defcurrent_databasequery_value("SELECT current_database()","SCHEMA")endcurrent_schema()LinkReturns the current schema name.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/postgresql/schema_statements.rb, line 181defcurrent_schemaquery_value("SELECT current_schema","SCHEMA")enddrop_schema(schema_name, **options)LinkDrops the schema for the given schema name.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/postgresql/schema_statements.rb, line 225defdrop_schema(schema_name,**options)execute"DROP SCHEMA#{' IF EXISTS' if options[:if_exists]} #{quote_schema_name(schema_name)} CASCADE"endencoding()LinkReturns the current database encoding format.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/postgresql/schema_statements.rb, line 186defencodingquery_value("SELECT pg_encoding_to_char(encoding) FROM pg_database WHERE datname = current_database()","SCHEMA")endexclusion_constraints(table_name)LinkReturns an array of exclusion constraints for the given table. The exclusion constraints are represented as ExclusionConstraintDefinition objects.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/postgresql/schema_statements.rb, line 617defexclusion_constraints(table_name)scope=quoted_scope(table_name)exclusion_info=internal_exec_query(<<-SQL,"SCHEMA")SELECT conname, pg_get_constraintdef(c.oid) AS constraintdef, c.condeferrable, c.condeferred
            FROM pg_constraint c
            JOIN pg_class t ON c.conrelid = t.oid
            JOIN pg_namespace n ON n.oid = c.connamespace
            WHERE c.contype = 'x'
              AND t.relname = #{scope[:name]}
              AND n.nspname = #{scope[:schema]}SQLexclusion_info.mapdo|row|method_and_elements,predicate=row["constraintdef"].split(" WHERE ")method_and_elements_parts=method_and_elements.match(/EXCLUDE(?: USING (?<using>\S+))? \((?<expression>.+)\)/)predicate.remove!(/ DEFERRABLE(?: INITIALLY (?:IMMEDIATE|DEFERRED))?/)ifpredicatepredicate=predicate.from(2).to(-3)ifpredicate# strip 2 opening and closing parenthesesdeferrable=extract_constraint_deferrable(row["condeferrable"],row["condeferred"])options= {name:row["conname"],using:method_and_elements_parts["using"].to_sym,where:predicate,deferrable:deferrable}ExclusionConstraintDefinition.new(table_name,method_and_elements_parts["expression"],options)endendforeign_keys(table_name)LinkSource:show|on GitHub# File activerecord/lib/active_record/connection_adapters/postgresql/schema_statements.rb, line 538defforeign_keys(table_name)scope=quoted_scope(table_name)fk_info=internal_exec_query(<<~SQL,"SCHEMA",allow_retry:true,materialize_transactions:false)SELECT t2.oid::regclass::text AS to_table, a1.attname AS column, a2.attname AS primary_key, c.conname AS name, c.confupdtype AS on_update, c.confdeltype AS on_delete, c.convalidated AS valid, c.condeferrable AS deferrable, c.condeferred AS deferred, c.conkey, c.confkey, c.conrelid, c.confrelid
            FROM pg_constraint c
            JOIN pg_class t1 ON c.conrelid = t1.oid
            JOIN pg_class t2 ON c.confrelid = t2.oid
            JOIN pg_attribute a1 ON a1.attnum = c.conkey[1] AND a1.attrelid = t1.oid
            JOIN pg_attribute a2 ON a2.attnum = c.confkey[1] AND a2.attrelid = t2.oid
            JOIN pg_namespace t3 ON c.connamespace = t3.oid
            WHERE c.contype = 'f'
              AND t1.relname = #{scope[:name]}
              AND t3.nspname = #{scope[:schema]}
            ORDER BY c.connameSQLfk_info.mapdo|row|to_table=Utils.unquote_identifier(row["to_table"])conkey=row["conkey"].scan(/\d+/).map(&:to_i)confkey=row["confkey"].scan(/\d+/).map(&:to_i)ifconkey.size>1column=column_names_from_column_numbers(row["conrelid"],conkey)primary_key=column_names_from_column_numbers(row["confrelid"],confkey)elsecolumn=Utils.unquote_identifier(row["column"])primary_key=row["primary_key"]endoptions= {column:column,name:row["name"],primary_key:primary_key}options[:on_delete] =extract_foreign_key_action(row["on_delete"])options[:on_update] =extract_foreign_key_action(row["on_update"])options[:deferrable] =extract_constraint_deferrable(row["deferrable"],row["deferred"])options[:validate] =row["valid"]ForeignKeyDefinition.new(table_name,to_table,options)endendforeign_table_exists?(table_name)LinkSource:show|on GitHub# File activerecord/lib/active_record/connection_adapters/postgresql/schema_statements.rb, line 587defforeign_table_exists?(table_name)query_values(data_source_sql(table_name,type:"FOREIGN TABLE"),"SCHEMA").any?iftable_name.present?endforeign_tables()LinkSource:show|on GitHub# File activerecord/lib/active_record/connection_adapters/postgresql/schema_statements.rb, line 583defforeign_tablesquery_values(data_source_sql(type:"FOREIGN TABLE"),"SCHEMA")endindex_name_exists?(table_name, index_name)LinkVerifies existence of an index with a given name.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/postgresql/schema_statements.rb, line 68defindex_name_exists?(table_name,index_name)table=quoted_scope(table_name)index=quoted_scope(index_name)query_value(<<~SQL,"SCHEMA").to_i>0SELECT COUNT(*)
            FROM pg_class t
            INNER JOIN pg_index d ON t.oid = d.indrelid
            INNER JOIN pg_class i ON d.indexrelid = i.oid
            LEFT JOIN pg_namespace n ON n.oid = t.relnamespace
            WHERE i.relkind IN ('i', 'I')
              AND i.relname = #{index[:name]}
              AND t.relname = #{table[:name]}
              AND n.nspname = #{table[:schema]}SQLendremove_exclusion_constraint(table_name, expression = nil, **options)LinkRemoves the given exclusion constraint from the table.remove_exclusion_constraint :products, name: "price_check"Theexpressionparameter will be ignored if present. It can be helpful to provide this in a migrationâschangemethod so it can be reverted. In that case,expressionwill be used byadd_exclusion_constraint.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/postgresql/schema_statements.rb, line 720defremove_exclusion_constraint(table_name,expression=nil,**options)excl_name_to_delete=exclusion_constraint_for!(table_name,expression:expression,**options).nameat=create_alter_table(table_name)at.drop_exclusion_constraint(excl_name_to_delete)executeschema_creation.accept(at)endremove_unique_constraint(table_name, column_name = nil, **options)LinkRemoves the given unique constraint from the table.remove_unique_constraint :sections, name: "unique_position"Thecolumn_nameparameter will be ignored if present. It can be helpful to provide this in a migrationâschangemethod so it can be reverted. In that case,column_namewill be used byadd_unique_constraint.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/postgresql/schema_statements.rb, line 775defremove_unique_constraint(table_name,column_name=nil,**options)unique_name_to_delete=unique_constraint_for!(table_name,column:column_name,**options).nameat=create_alter_table(table_name)at.drop_unique_constraint(unique_name_to_delete)executeschema_creation.accept(at)endrename_index(table_name, old_name, new_name)LinkRenames an index of a table. Raises error if length of new index name is greater than allowed limit.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/postgresql/schema_statements.rb, line 520defrename_index(table_name,old_name,new_name)validate_index_length!(table_name,new_name)schema, =extract_schema_qualified_name(table_name)execute"ALTER INDEX #{quote_table_name(schema) + '.' if schema}#{quote_column_name(old_name)} RENAME TO #{quote_table_name(new_name)}"endrename_table(table_name, new_name, **options)LinkRenames a table. Also renames a tableâs primary key sequence if the sequence name exists and matches the Active Record default.Example:rename_table('octopuses', 'octopi')Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/postgresql/schema_statements.rb, line 388defrename_table(table_name,new_name,**options)validate_table_length!(new_name)unlessoptions[:_uses_legacy_table_name]clear_cache!schema_cache.clear_data_source_cache!(table_name.to_s)schema_cache.clear_data_source_cache!(new_name.to_s)execute"ALTER TABLE #{quote_table_name(table_name)} RENAME TO #{quote_table_name(new_name)}"pk,seq=pk_and_sequence_for(new_name)ifpk# PostgreSQL automatically creates an index for PRIMARY KEY with name consisting of# truncated table name and "_pkey" suffix fitting into max_identifier_length number of characters.max_pkey_prefix=max_identifier_length-"_pkey".sizeidx="#{table_name[0, max_pkey_prefix]}_pkey"new_idx="#{new_name[0, max_pkey_prefix]}_pkey"execute"ALTER INDEX #{quote_table_name(idx)} RENAME TO #{quote_table_name(new_idx)}"# PostgreSQL automatically creates a sequence for PRIMARY KEY with name consisting of# truncated table name and "#{primary_key}_seq" suffix fitting into max_identifier_length number of characters.max_seq_prefix=max_identifier_length-"_#{pk}_seq".sizeifseq&&seq.identifier=="#{table_name[0, max_seq_prefix]}_#{pk}_seq"new_seq="#{new_name[0, max_seq_prefix]}_#{pk}_seq"execute"ALTER TABLE #{seq.quoted} RENAME TO #{quote_table_name(new_seq)}"endendrename_table_indexes(table_name,new_name,**options)endschema_exists?(name)LinkReturns true if schema exists.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/postgresql/schema_statements.rb, line 63defschema_exists?(name)query_value("SELECT COUNT(*) FROM pg_namespace WHERE nspname = #{quote(name)}","SCHEMA").to_i>0endschema_names()LinkReturns an array of schema names.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/postgresql/schema_statements.rb, line 201defschema_namesquery_values(<<~SQL,"SCHEMA")SELECT nspname
              FROM pg_namespace
             WHERE nspname !~ '^pg_.*'
               AND nspname NOT IN ('information_schema')
             ORDER by nspname;SQLendschema_search_path()LinkReturns the active schema search path.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/postgresql/schema_statements.rb, line 242defschema_search_path@schema_search_path||=query_value("SHOW search_path","SCHEMA")endschema_search_path=(schema_csv)LinkSets the schema search path to a string of comma-separated schema names. Names beginning with $ have to be quoted (e.g. $user => â$userâ). See:www.postgresql.org/docs/current/static/ddl-schemas.htmlThis should be not be called manually but set in database.yml.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/postgresql/schema_statements.rb, line 234defschema_search_path=(schema_csv)ifschema_csvinternal_execute("SET search_path TO #{schema_csv}")@schema_search_path=schema_csvendendserial_sequence(table, column)LinkSource:show|on GitHub# File activerecord/lib/active_record/connection_adapters/postgresql/schema_statements.rb, line 265defserial_sequence(table,column)query_value("SELECT pg_get_serial_sequence(#{quote(table)}, #{quote(column)})","SCHEMA")endunique_constraints(table_name)LinkReturns an array of unique constraints for the given table. The unique constraints are represented as UniqueConstraintDefinition objects.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/postgresql/schema_statements.rb, line 651defunique_constraints(table_name)scope=quoted_scope(table_name)unique_info=internal_exec_query(<<~SQL,"SCHEMA",allow_retry:true,materialize_transactions:false)SELECT c.conname, c.conrelid, c.conkey, c.condeferrable, c.condeferred
            FROM pg_constraint c
            JOIN pg_class t ON c.conrelid = t.oid
            JOIN pg_namespace n ON n.oid = c.connamespace
            WHERE c.contype = 'u'
              AND t.relname = #{scope[:name]}
              AND n.nspname = #{scope[:schema]}SQLunique_info.mapdo|row|conkey=row["conkey"].delete("{}").split(",").map(&:to_i)columns=column_names_from_column_numbers(row["conrelid"],conkey)deferrable=extract_constraint_deferrable(row["condeferrable"],row["condeferred"])options= {name:row["conname"],deferrable:deferrable}UniqueConstraintDefinition.new(table_name,columns,options)endendvalidate_check_constraint(table_name, **options)LinkValidates the given check constraint.validate_check_constraint :products, name: "price_check"Theoptionshash accepts the same keys asadd_check_constraint[rdoc-ref:ConnectionAdapters::SchemaStatements#add_check_constraint].Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/postgresql/schema_statements.rb, line 881defvalidate_check_constraint(table_name,**options)chk_name_to_validate=check_constraint_for!(table_name,**options).namevalidate_constrainttable_name,chk_name_to_validateendvalidate_constraint(table_name, constraint_name)LinkValidates the given constraint.Validates the constraint namedconstraint_nameonaccounts.validate_constraint :accounts, :constraint_nameSource:show|on GitHub# File activerecord/lib/active_record/connection_adapters/postgresql/schema_statements.rb, line 848defvalidate_constraint(table_name,constraint_name)at=create_alter_tabletable_nameat.validate_constraintconstraint_nameexecuteschema_creation.accept(at)endvalidate_foreign_key(from_table, to_table = nil, **options)LinkValidates the given foreign key.Validates the foreign key onaccounts.branch_id.validate_foreign_key :accounts, :branchesValidates the foreign key onaccounts.owner_id.validate_foreign_key :accounts, column: :owner_idValidates the foreign key namedspecial_fk_nameon theaccountstable.validate_foreign_key :accounts, name: :special_fk_nameTheoptionshash accepts the same keys asSchemaStatements#add_foreign_key.Source:show|on GitHub# File activerecord/lib/active_record/connection_adapters/postgresql/schema_statements.rb, line 870defvalidate_foreign_key(from_table,to_table=nil,**options)fk_name_to_validate=foreign_key_for!(from_table,to_table:to_table,**options).namevalidate_constraintfrom_table,fk_name_to_validateend