Active Support Cache StoreAn abstract cache store class. There are multiple cache store implementations, each having its own additional features. See the classes under theActiveSupport::Cachemodule, e.g.ActiveSupport::Cache::MemCacheStore.MemCacheStoreis currently the most popular cache store for large production websites.Some implementations may not support all methods beyond the basic cache methods offetch,write,read,exist?, anddelete.ActiveSupport::Cache::Storecan store any Ruby object that is supported by itscoderâsdumpandloadmethods.cache = ActiveSupport::Cache::MemoryStore.new

cache.read('city')   # => nil
cache.write('city', "Duckburgh") # => true
cache.read('city')   # => "Duckburgh"

cache.write('not serializable', Proc.new {}) # => TypeErrorKeys are always translated into Strings and are case sensitive. When an object is specified as a key and has acache_keymethod defined, this method will be called to define the key.  Otherwise, theto_parammethod will be called. Hashes and Arrays can also be used as keys. The elements will be delimited by slashes, and the elements within aHashwill be sorted by key so they are consistent.cache.read('city') == cache.read(:city)   # => trueNil values can be cached.If your cache is on a shared infrastructure, you can define a namespace for your cache entries. If a namespace is defined, it will be prefixed on to every key. The namespace can be either a static value or a Proc. If it is a Proc, it will be invoked when each key is evaluated so that you can use application logic to invalidate keys.cache.namespace = -> { @last_mod_time }  # Set the namespace to a variable
@last_mod_time = Time.now  # Invalidate the entire cache by changing namespaceMethodsCcleanup,clearDdecrement,delete,delete_matched,delete_multiEexist?Ffetch,fetch_multiIincrementKkey_matcherMmuteNnewRread,read_multiSsilence!Wwrite,write_multiAttributes[R]options[R]silence[R]silence?Class Public methodsnew(options = nil)LinkCreates a new cache.Options:namespaceSets the namespace for the cache. This option is especially useful if your application shares a cache with other applications.:serializerThe serializer for cached values. Must respond todumpandload.The default serializer depends on the cache format version (set viaconfig.active_support.cache_format_versionwhen usingRails). The default serializer for each format version includes a fallback mechanism to deserialize values from any format version. This behavior makes it easy to migrate between format versions without invalidating the entire cache.You can also specifyserializer: :message_packto use a preconfigured serializer based onActiveSupport::MessagePack. The:message_packserializer includes the same deserialization fallback mechanism, allowing easy migration from (or to) the default serializer. The:message_packserializer may improve performance, but it requires themsgpackgem.:compressorThe compressor for serialized cache values. Must respond todeflateandinflate.The default compressor isZlib. To define a new custom compressor that also decompresses old cache entries, you can check compressed values for Zlibâs"\x78"signature:module MyCompressor
  def self.deflate(dumped)
    # compression logic... (make sure result does not start with "\x78"!)
  end

  def self.inflate(compressed)
    if compressed.start_with?("\x78")
      Zlib.inflate(compressed)
    else
      # decompression logic...
    end
  end
end

ActiveSupport::Cache.lookup_store(:redis_cache_store, compressor: MyCompressor):coderThe coder for serializing and (optionally) compressing cache entries. Must respond todumpandload.The default coder composes the serializer and compressor, and includes some performance optimizations. If you only need to override the serializer or compressor, you should specify the:serializeror:compressoroptions instead.If the store can handle cache entries directly, you may also specifycoder: nilto omit the serializer, compressor, and coder. For example, if you are usingActiveSupport::Cache::MemoryStoreand can guarantee that cache values will not be mutated, you can specifycoder: nilto avoid the overhead of safeguarding against mutation.The:coderoption is mutally exclusive with the:serializerand:compressoroptions. Specifying them together will raise anArgumentError.Any other specified options are treated as default options for the relevant cache operations, such asread,write, andfetch.Source:show|on GitHub# File activesupport/lib/active_support/cache.rb, line 295definitialize(options=nil)@options=options?validate_options(normalize_options(options)):{}@options[:compress] =trueunless@options.key?(:compress)@options[:compress_threshold]||=DEFAULT_COMPRESS_LIMIT@coder=@options.delete(:coder)dolegacy_serializer=Cache.format_version<7.1&&!@options[:serializer]serializer=@options.delete(:serializer)||default_serializerserializer=Cache::SerializerWithFallback[serializer]ifserializer.is_a?(Symbol)compressor=@options.delete(:compressor) {Zlib}Cache::Coder.new(serializer,compressor,legacy_serializer:legacy_serializer)end@coder||=Cache::SerializerWithFallback[:passthrough]@coder_supports_compression=@coder.respond_to?(:dump_compressed)endInstance Public methodscleanup(options = nil)LinkCleans up the cache by removing expired entries.Options are passed to the underlying cache implementation.Some implementations may not support this method.Source:show|on GitHub# File activesupport/lib/active_support/cache.rb, line 747defcleanup(options=nil)raiseNotImplementedError.new("#{self.class.name} does not support cleanup")endclear(options = nil)LinkClears the entire cache. Be careful with this method since it could affect other processes if shared cache is being used.The options hash is passed to the underlying cache implementation.Some implementations may not support this method.Source:show|on GitHub# File activesupport/lib/active_support/cache.rb, line 757defclear(options=nil)raiseNotImplementedError.new("#{self.class.name} does not support clear")enddecrement(name, amount = 1, options = nil)LinkDecrements an integer value in the cache.Options are passed to the underlying cache implementation.Some implementations may not support this method.Source:show|on GitHub# File activesupport/lib/active_support/cache.rb, line 738defdecrement(name,amount=1,options=nil)raiseNotImplementedError.new("#{self.class.name} does not support decrement")enddelete(name, options = nil)LinkDeletes an entry in the cache. Returnstrueif an entry is deleted andfalseotherwise.Options are passed to the underlying cache implementation.Source:show|on GitHub# File activesupport/lib/active_support/cache.rb, line 674defdelete(name,options=nil)options=merged_options(options)key=normalize_key(name,options)instrument(:delete,key)dodelete_entry(key,**options)endenddelete_matched(matcher, options = nil)LinkDeletes all entries with keys matching the pattern.Options are passed to the underlying cache implementation.Some implementations may not support this method.Source:show|on GitHub# File activesupport/lib/active_support/cache.rb, line 720defdelete_matched(matcher,options=nil)raiseNotImplementedError.new("#{self.class.name} does not support delete_matched")enddelete_multi(names, options = nil)LinkDeletes multiple entries in the cache. Returns the number of deleted entries.Options are passed to the underlying cache implementation.Source:show|on GitHub# File activesupport/lib/active_support/cache.rb, line 687defdelete_multi(names,options=nil)return0ifnames.empty?options=merged_options(options)names.map!{|key|normalize_key(key,options) }instrument_multi:delete_multi,namesdodelete_multi_entries(names,**options)endendexist?(name, options = nil)LinkReturnstrueif the cache contains an entry for the given key.Options are passed to the underlying cache implementation.Source:show|on GitHub# File activesupport/lib/active_support/cache.rb, line 701defexist?(name,options=nil)options=merged_options(options)key=normalize_key(name,options)instrument(:exist?,key)do|payload|entry=read_entry(key,**options,event:payload)
    (entry&&!entry.expired?&&!entry.mismatched?(normalize_version(name,options)))||falseendendfetch(name, options = nil, &block)LinkFetches data from the cache, using the given key. If there is data in the cache with the given key, then that data is returned.If there is no such data in the cache (a cache miss), thennilwill be returned. However, if a block has been passed, that block will be passed the key and executed in the event of a cache miss. The return value of the block will be written to the cache under the given cache key, and that return value will be returned.cache.write('today', 'Monday')
cache.fetch('today')  # => "Monday"

cache.fetch('city')   # => nil
cache.fetch('city') do
  'Duckburgh'
end
cache.fetch('city')   # => "Duckburgh"OptionsInternally,fetchcallsread_entry, and callswrite_entryon a cache miss. Thus,fetchsupports the same options asreadandwrite. Additionally,fetchsupports the following options:force: true- Forces a cache âmiss,â meaning we treat the cache value as missing even if itâs present. Passing a block is required whenforceis true so this always results in a cache write.cache.write('today', 'Monday')
cache.fetch('today', force: true) { 'Tuesday' } # => 'Tuesday'
cache.fetch('today', force: true) # => ArgumentErrorThe:forceoption is useful when youâre calling some other method to ask whether you should force a cache write. Otherwise, itâs clearer to just callwrite.skip_nil: true- Prevents caching a nil result:cache.fetch('foo') { nil }
cache.fetch('bar', skip_nil: true) { nil }
cache.exist?('foo') # => true
cache.exist?('bar') # => false:race_condition_ttl- Specifies the number of seconds during which an expired value can be reused while a new value is being generated. This can be used to prevent race conditions when cache entries expire, by preventing multiple processes from simultaneously regenerating the same entry (also known as the dog pile effect).When a process encounters a cache entry that has expired less than:race_condition_ttlseconds ago, it will bump the expiration time by:race_condition_ttlseconds before generating a new value. During this extended time window, while the process generates a new value, other processes will continue to use the old value. After the first process writes the new value, other processes will then use it.If the first process errors out while generating a new value, another process can try to generate a new value after the extended time window has elapsed.# Set all values to expire after one minute.
cache = ActiveSupport::Cache::MemoryStore.new(expires_in: 1)

cache.write("foo", "original value")
val_1 = nil
val_2 = nil
p cache.read("foo") # => "original value"

sleep 1 # wait until the cache expires

t1 = Thread.new do
  # fetch does the following:
  # 1. gets an recent expired entry
  # 2. extends the expiry by 2 seconds (race_condition_ttl)
  # 3. regenerates the new value
  val_1 = cache.fetch("foo", race_condition_ttl: 2) do
    sleep 1
    "new value 1"
  end
end

# Wait until t1 extends the expiry of the entry
# but before generating the new value
sleep 0.1

val_2 = cache.fetch("foo", race_condition_ttl: 2) do
  # This block won't be executed because t1 extended the expiry
  "new value 2"
end

t1.join

p val_1 # => "new value 1"
p val_2 # => "oritinal value"
p cache.fetch("foo") # => "new value 1"

# The entry requires 3 seconds to expire (expires_in + race_condition_ttl)
# We have waited 2 seconds already (sleep(1) + t1.join) thus we need to wait 1
# more second to see the entry expire.
sleep 1

p cache.fetch("foo") # => nilDynamic OptionsIn some cases it may be necessary to dynamically compute options based on the cached value. To support this, anActiveSupport::Cache::WriteOptionsinstance is passed as the second argument to the block. For example:cache.fetch("authentication-token:#{user.id}") do |key, options|
  token = authenticate_to_service
  options.expires_at = token.expires_at
  token
endSource:show|on GitHub# File activesupport/lib/active_support/cache.rb, line 444deffetch(name,options=nil,&block)ifblock_given?options=merged_options(options)key=normalize_key(name,options)entry=nilunlessoptions[:force]instrument(:read,key,options)do|payload|cached_entry=read_entry(key,**options,event:payload)entry=handle_expired_entry(cached_entry,key,options)ifentryifentry.mismatched?(normalize_version(name,options))entry=nilelsebeginentry.valuerescueDeserializationErrorentry=nilendendendpayload[:super_operation] =:fetchifpayloadpayload[:hit] =!!entryifpayloadendendifentryget_entry_value(entry,name,options)elsesave_block_result_to_cache(name,key,options,&block)endelsifoptions&&options[:force]raiseArgumentError,"Missing block: Calling `Cache#fetch` with `force: true` requires a block."elseread(name,options)endendfetch_multi(*names)LinkFetches data from the cache, using the given keys. If there is data in the cache with the given keys, then that data is returned. Otherwise, the supplied block is called for each key for which there was no data, and the result will be written to the cache and returned. Therefore, you need to pass a block that returns the data to be written to the cache. If you do not want to write the cache when the cache is not found, useread_multi.Returns a hash with the data for each of the names. For example:cache.write("bim", "bam")
cache.fetch_multi("bim", "unknown_key") do |key|
  "Fallback value for key: #{key}"
end
# => { "bim" => "bam",
#      "unknown_key" => "Fallback value for key: unknown_key" }You may also specify additional options via theoptionsargument. Seefetchfor details. Other options are passed to the underlying cache implementation. For example:cache.fetch_multi("fizz", expires_in: 5.seconds) do |key|
  "buzz"
end
# => {"fizz"=>"buzz"}
cache.read("fizz")
# => "buzz"
sleep(6)
cache.read("fizz")
# => nilSource:show|on GitHub# File activesupport/lib/active_support/cache.rb, line 593deffetch_multi(*names)raiseArgumentError,"Missing block: `Cache#fetch_multi` requires a block."unlessblock_given?return{}ifnames.empty?options=names.extract_options!options=merged_options(options)writes= {}ordered=instrument_multi:read_multi,names,optionsdo|payload|ifoptions[:force]reads= {}elsereads=read_multi_entries(names,**options)endordered=names.index_withdo|name|reads.fetch(name) {writes[name] =yield(name) }endwrites.compact!ifoptions[:skip_nil]payload[:hits] =reads.keyspayload[:super_operation] =:fetch_multiorderedendwrite_multi(writes,options)orderedendincrement(name, amount = 1, options = nil)LinkIncrements an integer value in the cache.Options are passed to the underlying cache implementation.Some implementations may not support this method.Source:show|on GitHub# File activesupport/lib/active_support/cache.rb, line 729defincrement(name,amount=1,options=nil)raiseNotImplementedError.new("#{self.class.name} does not support increment")endmute()LinkSilences the logger within a block.Source:show|on GitHub# File activesupport/lib/active_support/cache.rb, line 322defmuteprevious_silence,@silence=@silence,trueyieldensure@silence=previous_silenceendread(name, options = nil)LinkReads data from the cache, using the given key. If there is data in the cache with the given key, then that data is returned. Otherwise,nilis returned.Note, if data was written with the:expires_inor:versionoptions, both of these conditions are applied before the data is returned.Options:namespace- Replace the store namespace for this call.:version- Specifies a version for the cache entry. If the cached version does not match the requested version, the read will be treated as a cache miss. This feature is used to support recyclable cache keys.Other options will be handled by the specific cache store implementation.Source:show|on GitHub# File activesupport/lib/active_support/cache.rb, line 498defread(name,options=nil)options=merged_options(options)key=normalize_key(name,options)version=normalize_version(name,options)instrument(:read,key,options)do|payload|entry=read_entry(key,**options,event:payload)ifentryifentry.expired?delete_entry(key,**options)payload[:hit] =falseifpayloadnilelsifentry.mismatched?(version)payload[:hit] =falseifpayloadnilelsepayload[:hit] =trueifpayloadbeginentry.valuerescueDeserializationErrorpayload[:hit] =falsenilendendelsepayload[:hit] =falseifpayloadnilendendendread_multi(*names)LinkReads multiple values at once from the cache. Options can be passed in the last argument.Some cache implementation may optimize this method.Returns a hash mapping the names provided to the values found.Source:show|on GitHub# File activesupport/lib/active_support/cache.rb, line 536defread_multi(*names)return{}ifnames.empty?options=names.extract_options!options=merged_options(options)instrument_multi:read_multi,names,optionsdo|payload|read_multi_entries(names,**options,event:payload).tapdo|results|payload[:hits] =results.keysendendendsilence!()LinkSilences the logger.Source:show|on GitHub# File activesupport/lib/active_support/cache.rb, line 316defsilence!@silence=trueselfendwrite(name, value, options = nil)LinkWrites the value to the cache with the key. The value must be supported by thecoderâsdumpandloadmethods.Returnstrueif the write succeeded,nilif there was an error talking to the cache backend, orfalseif the write failed for another reason.By default, cache entries larger than 1kB are compressed. Compression allows more data to be stored in the same memory footprint, leading to fewer cache evictions and higher hit rates.Optionscompress: false- Disables compression of the cache entry.:compress_threshold- The compression threshold, specified in bytes. Cache entries larger than this threshold will be compressed. Defaults to1.kilobyte.:expires_in- Sets a relative expiration time for the cache entry, specified in seconds.:expire_inand:expired_inare aliases for:expires_in.cache = ActiveSupport::Cache::MemoryStore.new(expires_in: 5.minutes)
cache.write(key, value, expires_in: 1.minute) # Set a lower value for one entry:expires_at- Sets an absolute expiration time for the cache entry.cache = ActiveSupport::Cache::MemoryStore.new
cache.write(key, value, expires_at: Time.now.at_end_of_hour):version- Specifies a version for the cache entry. When reading from the cache, if the cached version does not match the requested version, the read will be treated as a cache miss. This feature is used to support recyclable cache keys.Other options will be handled by the specific cache store implementation.Source:show|on GitHub# File activesupport/lib/active_support/cache.rb, line 660defwrite(name,value,options=nil)options=merged_options(options)key=normalize_key(name,options)instrument(:write,key,options)doentry=Entry.new(value,**options.merge(version:normalize_version(name,options)))write_entry(key,entry,**options)endendwrite_multi(hash, options = nil)LinkCacheStorage API to write multiple values at once.Source:show|on GitHub# File activesupport/lib/active_support/cache.rb, line 550defwrite_multi(hash,options=nil)returnhashifhash.empty?options=merged_options(options)instrument_multi:write_multi,hash,optionsdo|payload|entries=hash.each_with_object({})do|(name,value),memo|memo[normalize_key(name,options)] =Entry.new(value,**options.merge(version:normalize_version(name,options)))endwrite_multi_entriesentries,**optionsendendInstance Private methodskey_matcher(pattern, options)LinkAdds the namespace defined in the options to a pattern designed to match keys. Implementations that supportdelete_matchedshould call this method to translate a pattern that matches names into one that matches namespaced keys.Source:show|on GitHub# File activesupport/lib/active_support/cache.rb, line 777defkey_matcher(pattern,options)# :doc:prefix=options[:namespace].is_a?(Proc)?options[:namespace].call:options[:namespace]ifprefixsource=pattern.sourceifsource.start_with?("^")source=source[1,source.length]elsesource=".*#{source[0, source.length]}"endRegexp.new("^#{Regexp.escape(prefix)}:#{source}",pattern.options)elsepatternendend