A share/exclusive lock, otherwise known as a read/write lock.en.wikipedia.org/wiki/Readers%E2%80%93writer_lockMethodsEexclusiveNnewSsharing,start_exclusive,start_sharing,stop_exclusive,stop_sharingYyield_sharesIncluded ModulesMonitorMixinClass Public methodsnew()LinkSource:show|on GitHub# File activesupport/lib/active_support/concurrency/share_lock.rb, line 50definitializesuper()@cv=new_cond@sharing=Hash.new(0)@waiting= {}@sleeping= {}@exclusive_thread=nil@exclusive_depth=0endInstance Public methodsexclusive(purpose: nil, compatible: [], after_compatible: [], no_wait: false)LinkExecute the supplied block while holding the Exclusive lock. Ifno_waitis set and the lock is not immediately available, returnsnilwithout yielding. Otherwise, returns the result of the block.Seestart_exclusivefor other options.Source:show|on GitHub# File activesupport/lib/active_support/concurrency/share_lock.rb, line 148defexclusive(purpose:nil,compatible:[],after_compatible:[],no_wait:false)ifstart_exclusive(purpose:purpose,compatible:compatible,no_wait:no_wait)beginyieldensurestop_exclusive(compatible:after_compatible)endendendsharing()LinkExecute the supplied block while holding the Share lock.Source:show|on GitHub# File activesupport/lib/active_support/concurrency/share_lock.rb, line 159defsharingstart_sharingbeginyieldensurestop_sharingendendstart_exclusive(purpose: nil, compatible: [], no_wait: false)LinkReturns false ifno_waitis set and the lock is not immediately available. Otherwise, returns true after the lock has been acquired.purposeandcompatiblework together; while this thread is waiting for the exclusive lock, it will yield its share (if any) to any other attempt whosepurposeappears in this attemptâscompatiblelist. This allows a âlooseâ upgrade, which, being less strict, prevents some classes of deadlocks.For many resources, loose upgrades are sufficient: if a thread is awaiting a lock, it is not running any other code. Withpurposematching, it is possible to yield only to other threads whose activity will not interfere.Source:show|on GitHub# File activesupport/lib/active_support/concurrency/share_lock.rb, line 76defstart_exclusive(purpose:nil,compatible:[],no_wait:false)synchronizedounless@exclusive_thread==Thread.currentifbusy_for_exclusive?(purpose)returnfalseifno_waityield_shares(purpose:purpose,compatible:compatible,block_share:true)dowait_for(:start_exclusive) {busy_for_exclusive?(purpose) }endend@exclusive_thread=Thread.currentend@exclusive_depth+=1trueendendstart_sharing()LinkSource:show|on GitHub# File activesupport/lib/active_support/concurrency/share_lock.rb, line 114defstart_sharingsynchronizedoif@sharing[Thread.current]>0||@exclusive_thread==Thread.current# We already hold a lock; nothing to wait forelsif@waiting[Thread.current]# We're nested inside a +yield_shares+ call: we'll resume as# soon as there isn't an exclusive lock in our waywait_for(:start_sharing) {@exclusive_thread}else# This is an initial / outermost share call: any outstanding# requests for an exclusive lock get to go firstwait_for(:start_sharing) {busy_for_sharing?(false) }end@sharing[Thread.current]+=1endendstop_exclusive(compatible: [])LinkRelinquish the exclusive lock. Must only be called by the thread that calledstart_exclusive(and currently holds the lock).Source:show|on GitHub# File activesupport/lib/active_support/concurrency/share_lock.rb, line 96defstop_exclusive(compatible:[])synchronizedoraise"invalid unlock"if@exclusive_thread!=Thread.current@exclusive_depth-=1if@exclusive_depth==0@exclusive_thread=nilifeligible_waiters?(compatible)yield_shares(compatible:compatible,block_share:true)dowait_for(:stop_exclusive) {@exclusive_thread||eligible_waiters?(compatible) }endend@cv.broadcastendendendstop_sharing()LinkSource:show|on GitHub# File activesupport/lib/active_support/concurrency/share_lock.rb, line 131defstop_sharingsynchronizedoif@sharing[Thread.current]>1@sharing[Thread.current]-=1else@sharing.deleteThread.current@cv.broadcastendendendyield_shares(purpose: nil, compatible: [], block_share: false)LinkTemporarily give up all held Share locks while executing the supplied block, allowing anycompatibleexclusive lock request to proceed.Source:show|on GitHub# File activesupport/lib/active_support/concurrency/share_lock.rb, line 171defyield_shares(purpose:nil,compatible:[],block_share:false)loose_shares=previous_wait=nilsynchronizedoifloose_shares=@sharing.delete(Thread.current)ifprevious_wait=@waiting[Thread.current]purpose=nilunlesspurpose==previous_wait[0]compatible&=previous_wait[1]endcompatible|=[false]unlessblock_share@waiting[Thread.current] = [purpose,compatible]end@cv.broadcastendbeginyieldensuresynchronizedowait_for(:yield_shares) {@exclusive_thread&&@exclusive_thread!=Thread.current}ifprevious_wait@waiting[Thread.current] =previous_waitelse@waiting.deleteThread.currentend@sharing[Thread.current] =loose_sharesifloose_sharesendendend