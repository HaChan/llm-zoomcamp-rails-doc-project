Active Record RelationNamespaceMODULEActiveRecord::Relation::RecordFetchWarningMethods#==Aany?Bblank?,buildCcache_key,cache_key_with_version,cache_version,create,create!,create_or_find_by,create_or_find_by!Ddelete,delete_all,delete_by,destroy,destroy_all,destroy_byEeager_loading?,empty?,encode_with,explainFfind_or_create_by,find_or_create_by!,find_or_initialize_byIinitialize_copy,insert,insert!,insert_all,insert_all!,inspectJjoined_includes_valuesLload,load_async,load_recordsMmany?Nnew,new,none?Oone?Ppretty_printRreload,resetSscheduled?,scope_for_create,scoping,sizeTto_a,to_ary,to_sql,touch_allUupdate_all,update_counters,upsert,upsert_allVvaluesIncluded ModulesEnumerableConstantsCLAUSE_METHODS=[:where, :having, :from]INVALID_METHODS_FOR_DELETE_ALL=[:distinct, :with, :with_recursive]MULTI_VALUE_METHODS=[:includes, :eager_load, :preload, :select, :group,
:order, :joins, :left_outer_joins, :references,
:extending, :unscope, :optimizer_hints, :annotate,
:with]SINGLE_VALUE_METHODS=[:limit, :offset, :lock, :readonly, :reordering, :strict_loading,
:reverse_order, :distinct, :create_with, :skip_query_cache]VALUE_METHODS=MULTI_VALUE_METHODS + SINGLE_VALUE_METHODS + CLAUSE_METHODSAttributes[R]klass[R]loaded[R]loaded?[R]model[R]predicate_builder[RW]skip_preloading_value[R]tableClass Public methodsnew(klass, table: klass.arel_table, predicate_builder: klass.predicate_builder, values: {})LinkSource:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 77definitialize(klass,table:klass.arel_table,predicate_builder:klass.predicate_builder,values:{})@klass=klass@table=table@values=values@loaded=false@predicate_builder=predicate_builder@delegate_to_klass=false@future_result=nil@records=nil@async=false@none=falseendInstance Public methods==(other)LinkCompares two relations for equality.Source:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 1239def==(other)caseotherwhenAssociations::CollectionProxy,AssociationRelationself==other.recordswhenRelationother.to_sql==to_sqlwhenArrayrecords==otherendendany?(*args)LinkReturns true if there are any records.When a pattern argument is given, this method checks whether elements in theEnumerablematch the pattern via the case-equality operator (===).posts.any?(Post) # => true or falseSource:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 384defany?(*args)returnfalseif@nonereturnsuperifargs.present?||block_given?!empty?endblank?()LinkReturns true if relation is blank.Source:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 1260defblank?records.blank?endbuild(attributes = nil, &block)LinkAlias for:newcache_key(timestamp_column = "updated_at")LinkReturns a stable cache key that can be used to identify this query. The cache key is built with a fingerprint of the SQL query.Product.where("name like ?", "%Cosmic Encounter%").cache_key
# => "products/query-1850ab3d302391b85b8693e941286659"IfActiveRecord::Base.collection_cache_versioningis turned off, as it was in Rails 6.0 and earlier, the cache key will also include a version.ActiveRecord::Base.collection_cache_versioning = false
Product.where("name like ?", "%Cosmic Encounter%").cache_key
# => "products/query-1850ab3d302391b85b8693e941286659-1-20150714212553907087000"You can also pass a custom timestamp column to fetch the timestamp of the last updated record.Product.where("name like ?", "%Game%").cache_key(:last_reviewed_at)Source:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 431defcache_key(timestamp_column="updated_at")@cache_keys||={}@cache_keys[timestamp_column]||=klass.collection_cache_key(self,timestamp_column)endcache_key_with_version()LinkReturns a cache key along with the version.Source:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 512defcache_key_with_versionifversion=cache_version"#{cache_key}-#{version}"elsecache_keyendendcache_version(timestamp_column = :updated_at)LinkReturns a cache version that can be used together with the cache key to form a recyclable caching scheme. The cache version is built with the number of records matching the query, and the timestamp of the last updated record. When a new record comes to match the query, or any of the existing records is updated or deleted, the cache version changes.If the collection is loaded, the method will iterate through the records to generate the timestamp, otherwise it will trigger one SQL query like:SELECT COUNT(*), MAX("products"."updated_at") FROM "products" WHERE (name like '%Cosmic Encounter%')Source:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 458defcache_version(timestamp_column=:updated_at)ifcollection_cache_versioning@cache_versions||={}@cache_versions[timestamp_column]||=compute_cache_version(timestamp_column)endendcreate(attributes = nil, &block)LinkTries to create a new record with the same scoped attributes defined in the relation. Returns the initialized object if validation fails.Expects arguments in the same format asActiveRecord::Base.create.Examplesusers = User.where(name: 'Oscar')
users.create # => #<User id: 3, name: "Oscar", ...>

users.create(name: 'fxn')
users.create # => #<User id: 4, name: "fxn", ...>

users.create { |user| user.name = 'tenderlove' }
# => #<User id: 5, name: "tenderlove", ...>

users.create(name: nil) # validation on name
# => #<User id: nil, name: nil, ...>Source:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 147defcreate(attributes=nil,&block)ifattributes.is_a?(Array)attributes.collect{|attr|create(attr,&block) }elseblock=current_scope_restoring_block(&block)scoping{_create(attributes,&block) }endendcreate!(attributes = nil, &block)LinkSimilar tocreate, but callscreate!on the base class. Raises an exception if a validation error occurs.Expects arguments in the same format asActiveRecord::Base.create!.Source:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 162defcreate!(attributes=nil,&block)ifattributes.is_a?(Array)attributes.collect{|attr|create!(attr,&block) }elseblock=current_scope_restoring_block(&block)scoping{_create!(attributes,&block) }endendcreate_or_find_by(attributes, &block)LinkAttempts to create a record with the given attributes in a table that has a unique database constraint on one or several of its columns. If a row already exists with one or several of these unique constraints, the exception such an insertion would normally raise is caught, and the existing record with those attributes is found using find_by!.This is similar tofind_or_create_by, but tries to create the record first. As such it is better suited for cases where the record is most likely not to exist yet.There are several drawbacks tocreate_or_find_by, though:The underlying table must have the relevant columns defined with unique database constraints.A unique constraint violation may be triggered by only one, or at least less than all, of the given attributes. This means that the subsequent find_by! may fail to find a matching record, which will then raise anActiveRecord::RecordNotFoundexception, rather than a record with the given attributes.While we avoid the race condition between SELECT -> INSERT fromfind_or_create_by, we actually have another race condition between INSERT -> SELECT, which can be triggered if a DELETE between those two statements is run by another client. But for most applications, thatâs a significantly less likely condition to hit.It relies on exception handling to handle control flow, which may be marginally slower.The primary key may auto-increment on each create, even if it fails. This can accelerate the problem of running out of integers, if the underlying table is still stuck on a primary key of type int (note: All Rails apps since 5.1+ have defaulted to bigint, which is not liable to this problem).Columns with unique database constraints should not have uniqueness validations defined, otherwisecreatewill fail due to validation errors and find_by will never be called.This method will return a record if all given attributes are covered by unique constraints (unless the INSERT -> DELETE -> SELECT race condition is triggered), but if creation was attempted and failed due to validation errors it wonât be persisted, you get whatcreatereturns in such situation.Source:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 266defcreate_or_find_by(attributes,&block)with_connectiondo|connection|transaction(requires_new:true) {create(attributes,&block) }rescueActiveRecord::RecordNotUniqueifconnection.transaction_open?where(attributes).lock.find_by!(attributes)elsefind_by!(attributes)endendendcreate_or_find_by!(attributes, &block)LinkLikecreate_or_find_by, but callscreate!so an exception is raised if the created record is invalid.Source:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 281defcreate_or_find_by!(attributes,&block)with_connectiondo|connection|transaction(requires_new:true) {create!(attributes,&block) }rescueActiveRecord::RecordNotUniqueifconnection.transaction_open?where(attributes).lock.find_by!(attributes)elsefind_by!(attributes)endendenddelete(id_or_array)LinkDeletes the row with a primary key matching theidargument, using an SQLDELETEstatement, and returns the number of rows deleted. Active Record objects are not instantiated, so the objectâs callbacks are not executed, including any:dependentassociation options.You can delete multiple rows at once by passing anArrayofids.Note: Although it is often much faster than the alternative,destroy, skipping callbacks might bypass business logic in your application that ensures referential integrity or performs other essential jobs.Examples# Delete a single row
Todo.delete(1)

# Delete multiple rows
Todo.delete([2,3,4])Source:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 1050defdelete(id_or_array)return0ifid_or_array.nil?||(id_or_array.is_a?(Array)&&id_or_array.empty?)where(model.primary_key=>id_or_array).delete_allenddelete_all()LinkDeletes the records without instantiating the records first, and hence not calling the#destroymethod nor invoking callbacks. This is a single SQL DELETE statement that goes straight to the database, much more efficient thandestroy_all. Be careful with relations though, in particular:dependentrules defined on associations are not honored. Returns the number of rows affected.Post.where(person_id: 5).where(category: ['Something', 'Else']).delete_allBoth calls delete the affected posts all at once with a single DELETE statement. If you need to destroy dependent associations or call yourbefore_*orafter_destroycallbacks, use thedestroy_allmethod instead.If an invalid method is supplied,delete_allraises an ActiveRecordError:Post.distinct.delete_all
# => ActiveRecord::ActiveRecordError: delete_all doesn't support distinctSource:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 1004defdelete_allreturn0if@noneinvalid_methods=INVALID_METHODS_FOR_DELETE_ALL.selectdo|method|value=@values[method]method==:distinct?value:value&.any?endifinvalid_methods.any?raiseActiveRecordError.new("delete_all doesn't support #{invalid_methods.join(', ')}")endklass.with_connectiondo|c|arel=eager_loading??apply_join_dependency.arel:build_arel(c)arel.source.left=tablegroup_values_arel_columns=arel_columns(group_values.uniq)having_clause_ast=having_clause.astunlesshaving_clause.empty?key=ifklass.composite_primary_key?primary_key.map{|pk|table[pk] }elsetable[primary_key]endstmt=arel.compile_delete(key,having_clause_ast,group_values_arel_columns)c.delete(stmt,"#{klass} Delete All").tap{reset}endenddelete_by(*args)LinkFinds and deletes all records matching the specified conditions. This is short-hand forrelation.where(condition).delete_all. Returns the number of rows affected.If no record is found, returns0as zero rows were affected.Person.delete_by(id: 13)
Person.delete_by(name: 'Spartacus', rating: 4)
Person.delete_by("published_at < ?", 2.weeks.ago)Source:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 1112defdelete_by(*args)where(*args).delete_allenddestroy(id)LinkDestroy an object (or multiple objects) that has the given id. The object is instantiated first, therefore all callbacks and filters are fired off before the object is deleted. This method is less efficient thandeletebut allows cleanup methods and other actions to be run.This essentially finds the object (or multiple objects) with the given id, creates a new object from the attributes, and then calls destroy on it.Parametersid- This should be the id or an array of ids to be destroyed.Examples# Destroy a single object
Todo.destroy(1)

# Destroy multiple objects
todos = [1,2,3]
Todo.destroy(todos)Source:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 1076defdestroy(id)multiple_ids=ifmodel.composite_primary_key?id.first.is_a?(Array)elseid.is_a?(Array)endifmultiple_idsfind(id).each(&:destroy)elsefind(id).destroyendenddestroy_all()LinkDestroys the records by instantiating each record and calling its#destroymethod. Each objectâs callbacks are executed (including:dependentassociation options). Returns the collection of objects that were destroyed; each will be frozen, to reflect that no changes should be made (since they canât be persisted).Note: Instantiation, callback execution, and deletion of each record can be time consuming when youâre removing many records at once. It generates at least one SQLDELETEquery per record (or possibly more, to enforce your callbacks). If you want to delete many rows quickly, without concern for their associations or callbacks, usedelete_allinstead.ExamplesPerson.where(age: 0..18).destroy_allSource:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 982defdestroy_allrecords.each(&:destroy).tap{reset}enddestroy_by(*args)LinkFinds and destroys all records matching the specified conditions. This is short-hand forrelation.where(condition).destroy_all. Returns the collection of objects that were destroyed.If no record is found, returns empty array.Person.destroy_by(id: 13)
Person.destroy_by(name: 'Spartacus', rating: 4)
Person.destroy_by("published_at < ?", 2.weeks.ago)Source:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 1099defdestroy_by(*args)where(*args).destroy_allendeager_loading?()LinkReturns true if relation needs eager loading.Source:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 1224defeager_loading?@should_eager_load||=eager_load_values.any?||includes_values.any?&&(joined_includes_values.any?||references_eager_loaded_tables?)endempty?()LinkReturns true if there are no records.Source:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 355defempty?returntrueif@noneifloaded?records.empty?else!exists?endendencode_with(coder)LinkSerializes the relation objectsArray.Source:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 341defencode_with(coder)coder.represent_seq(nil,records)endexplain(*options)LinkRuns EXPLAIN on the query or queries triggered by this relation and returns the result as a string. The string is formatted imitating the ones printed by the database shell.User.all.explain
# EXPLAIN SELECT `users`.* FROM `users`
# ...Note that this method actually runs the queries, since the results of some are needed by the next ones when eager loading is going on.To run EXPLAIN on queries created byfirst,pluckandcount, call these methods onexplain:User.all.explain.count
# EXPLAIN SELECT COUNT(*) FROM `users`
# ...The column name can be passed if required:User.all.explain.maximum(:id)
# EXPLAIN SELECT MAX(`users`.`id`) FROM `users`
# ...Please see further details in theActive Record Query Interface guide.Source:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 325defexplain(*options)ExplainProxy.new(self,options)endfind_or_create_by(attributes, &block)LinkFinds the first record with the given attributes, or creates a record with the attributes if one is not found:# Find the first user named "PenÃ©lope" or create a new one.
User.find_or_create_by(first_name: 'PenÃ©lope')
# => #<User id: 1, first_name: "PenÃ©lope", last_name: nil>

# Find the first user named "PenÃ©lope" or create a new one.
# We already have one so the existing record will be returned.
User.find_or_create_by(first_name: 'PenÃ©lope')
# => #<User id: 1, first_name: "PenÃ©lope", last_name: nil>

# Find the first user named "Scarlett" or create a new one with
# a particular last name.
User.create_with(last_name: 'Johansson').find_or_create_by(first_name: 'Scarlett')
# => #<User id: 2, first_name: "Scarlett", last_name: "Johansson">This method accepts a block, which is passed down tocreate. The last example above can be alternatively written this way:# Find the first user named "Scarlett" or create a new one with a
# particular last name.
User.find_or_create_by(first_name: 'Scarlett') do |user|
  user.last_name = 'Johansson'
end
# => #<User id: 2, first_name: "Scarlett", last_name: "Johansson">This method always returns a record, but if creation was attempted and failed due to validation errors it wonât be persisted, you get whatcreatereturns in such situation.If creation failed because of a unique constraint, this method will assume it encountered a race condition and will try finding the record once more. If somehow the second find still does not find a record because a concurrent DELETE happened, it will then raise anActiveRecord::RecordNotFoundexception.Please notethis method is not atomic, it runs first a SELECT, and if there are no results an INSERT is attempted. So if the table doesnât have a relevant unique constraint it could be the case that you end up with two or more similar records.Source:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 224deffind_or_create_by(attributes,&block)find_by(attributes)||create_or_find_by(attributes,&block)endfind_or_create_by!(attributes, &block)LinkLikefind_or_create_by, but callscreate!so an exception is raised if the created record is invalid.Source:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 231deffind_or_create_by!(attributes,&block)find_by(attributes)||create_or_find_by!(attributes,&block)endfind_or_initialize_by(attributes, &block)LinkLikefind_or_create_by, but calls new instead ofcreate.Source:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 295deffind_or_initialize_by(attributes,&block)find_by(attributes)||new(attributes,&block)endinitialize_copy(other)LinkSource:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 90definitialize_copy(other)@values=@values.dupresetendinsert(attributes, returning: nil, unique_by: nil, record_timestamps: nil)LinkInserts a single record into the database in a single SQL INSERT statement. It does not instantiate any models nor does it trigger Active Record callbacks or validations. Though passed values go through Active Recordâs type casting and serialization.Seeinsert_allfor documentation.Source:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 637definsert(attributes,returning:nil,unique_by:nil,record_timestamps:nil)insert_all([attributes],returning:returning,unique_by:unique_by,record_timestamps:record_timestamps)endinsert!(attributes, returning: nil, record_timestamps: nil)LinkInserts a single record into the database in a single SQL INSERT statement. It does not instantiate any models nor does it trigger Active Record callbacks or validations. Though passed values go through Active Recordâs type casting and serialization.Seeinsert_all!for more.Source:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 726definsert!(attributes,returning:nil,record_timestamps:nil)insert_all!([attributes],returning:returning,record_timestamps:record_timestamps)endinsert_all(attributes, returning: nil, unique_by: nil, record_timestamps: nil)LinkInserts multiple records into the database in a single SQL INSERT statement. It does not instantiate any models nor does it trigger Active Record callbacks or validations. Though passed values go through Active Recordâs type casting and serialization.Theattributesparameter is anArrayof Hashes. EveryHashdetermines the attributes for a single row and must have the same keys.Rows are considered to be unique by every unique index on the table. Any duplicate rows are skipped. Override with:unique_by(see below).Returns anActiveRecord::Resultwith its contents based on:returning(see below).Options:returning(PostgreSQL, SQLite3, and MariaDB only) An array of attributes to return for all successfully inserted records, which by default is the primary key. Passreturning: %w[ id name ]for both id and name orreturning: falseto omit the underlyingRETURNINGSQL clause entirely.You can also pass an SQL string if you need more control on the return values (for example,returning: Arel.sql("id, name as new_name")).:unique_by(PostgreSQL and SQLite only) By default rows are considered to be unique by every unique index on the table. Any duplicate rows are skipped.To skip rows according to just one unique index pass:unique_by.Consider a Book model where no duplicate ISBNs make sense, but if any row has an existing id, or is not unique by another unique index,ActiveRecord::RecordNotUniqueis raised.Unique indexes can be identified by columns or name:unique_by: :isbn
unique_by: %i[ author_id name ]
unique_by: :index_books_on_isbn:record_timestampsBy default, automatic setting of timestamp columns is controlled by the modelâsrecord_timestampsconfig, matching typical behavior.To override this and force automatic setting of timestamp columns one way or the other, pass:record_timestamps:record_timestamps: true  # Always set timestamps automatically
record_timestamps: false # Never set timestamps automaticallyBecause it relies on the index information from the database:unique_byis recommended to be paired with Active Recordâs schema_cache.Example# Insert records and skip inserting any duplicates.
# Here "Eloquent Ruby" is skipped because its id is not unique.

Book.insert_all([
  { id: 1, title: "Rework", author: "David" },
  { id: 1, title: "Eloquent Ruby", author: "Russ" }
])

# insert_all works on chained scopes, and you can use create_with
# to set default attributes for all inserted records.

author.books.create_with(created_at: Time.now).insert_all([
  { id: 1, title: "Rework" },
  { id: 2, title: "Eloquent Ruby" }
])Source:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 716definsert_all(attributes,returning:nil,unique_by:nil,record_timestamps:nil)InsertAll.execute(self,attributes,on_duplicate::skip,returning:returning,unique_by:unique_by,record_timestamps:record_timestamps)endinsert_all!(attributes, returning: nil, record_timestamps: nil)LinkInserts multiple records into the database in a single SQL INSERT statement. It does not instantiate any models nor does it trigger Active Record callbacks or validations. Though passed values go through Active Recordâs type casting and serialization.Theattributesparameter is anArrayof Hashes. EveryHashdetermines the attributes for a single row and must have the same keys.RaisesActiveRecord::RecordNotUniqueif any rows violate a unique index on the table. In that case, no rows are inserted.To skip duplicate rows, seeinsert_all. To replace them, seeupsert_all.Returns anActiveRecord::Resultwith its contents based on:returning(see below).Options:returning(PostgreSQL, SQLite3, and MariaDB only) An array of attributes to return for all successfully inserted records, which by default is the primary key. Passreturning: %w[ id name ]for both id and name orreturning: falseto omit the underlyingRETURNINGSQL clause entirely.You can also pass an SQL string if you need more control on the return values (for example,returning: Arel.sql("id, name as new_name")).:record_timestampsBy default, automatic setting of timestamp columns is controlled by the modelâsrecord_timestampsconfig, matching typical behavior.To override this and force automatic setting of timestamp columns one way or the other, pass:record_timestamps:record_timestamps: true  # Always set timestamps automatically
record_timestamps: false # Never set timestamps automaticallyExamples# Insert multiple records
Book.insert_all!([
  { title: "Rework", author: "David" },
  { title: "Eloquent Ruby", author: "Russ" }
])

# Raises ActiveRecord::RecordNotUnique because "Eloquent Ruby"
# does not have a unique id.
Book.insert_all!([
  { id: 1, title: "Rework", author: "David" },
  { id: 1, title: "Eloquent Ruby", author: "Russ" }
])Source:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 783definsert_all!(attributes,returning:nil,record_timestamps:nil)InsertAll.execute(self,attributes,on_duplicate::raise,returning:returning,record_timestamps:record_timestamps)endinspect()LinkSource:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 1272definspectsubject=loaded??records:annotate("loading for inspect")entries=subject.take([limit_value,11].compact.min).map!(&:inspect)entries[10] ="..."ifentries.size==11"#<#{self.class.name} [#{entries.join(', ')}]>"endjoined_includes_values()LinkJoins that are also marked for preloading. In which case we should just eager load them. Note that this is a naive implementation because we could have strings and symbols which represent the same association, but that arenât matched by this. Also, we could have nested hashes which partially match, e.g.{ a: :b } & { a: [:b, :c] }Source:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 1234defjoined_includes_valuesincludes_values&joins_valuesendload(&block)LinkCauses the records to be loaded from the database if they have not been loaded already. You can use this if for some reason you need to explicitly load some records before actually using them. The return value is the relation itself, not the records.Post.where(published: true).load # => #<ActiveRecord::Relation>Source:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 1165defload(&block)if!loaded?||scheduled?@records=exec_queries(&block)@loaded=trueendselfendload_async()LinkSchedule the query to be performed from a background thread pool.Post.where(published: true).load_async # => #<ActiveRecord::Relation>When theRelationis iterated, if the background query wasnât executed yet, it will be performed by the foreground thread.Note thatconfig.active_record.async_query_executormust be configured for queries to actually be executed concurrently. Otherwise it defaults to executing them in the foreground.load_asyncwill also fall back to executing in the foreground in the test environment when transactional fixtures are enabled.If the query was actually executed in the background, the Active Record logs will show it by prefixing the log line withASYNC:ASYNC Post Load (0.0ms) (db time 2ms)  SELECT "posts".* FROM "posts" LIMIT 100Source:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 1134defload_asyncwith_connectiondo|c|returnloadif!c.async_enabled?unlessloaded?result=exec_main_query(async:c.current_transaction.closed?)ifresult.is_a?(Array)@records=resultelse@future_result=resultend@loaded=trueendendselfendmany?()LinkReturns true if there is more than one record.Source:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 406defmany?returnfalseif@nonereturnsuperifblock_given?returnrecords.many?ifloaded?limited_count>1endnew(attributes = nil, &block)LinkInitializes new record from relation while maintaining the current scope.Expects arguments in the same format asActiveRecord::Base.new.users = User.where(name: 'DHH')
user = users.new # => #<User id: nil, name: "DHH", created_at: nil, updated_at: nil>You can also pass a block to new with the new record as argument:user = users.new { |user| user.name = 'Oscar' }
user.name # => OscarAlso aliased as:buildSource:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 118defnew(attributes=nil,&block)ifattributes.is_a?(Array)attributes.collect{|attr|new(attr,&block) }elseblock=current_scope_restoring_block(&block)scoping{_new(attributes,&block) }endendnone?(*args)LinkReturns true if there are no records.When a pattern argument is given, this method checks whether elements in theEnumerablematch the pattern via the case-equality operator (===).posts.none?(Comment) # => true or falseSource:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 371defnone?(*args)returntrueif@nonereturnsuperifargs.present?||block_given?empty?endone?(*args)LinkReturns true if there is exactly one record.When a pattern argument is given, this method checks whether elements in theEnumerablematch the pattern via the case-equality operator (===).posts.one?(Post) # => true or falseSource:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 397defone?(*args)returnfalseif@nonereturnsuperifargs.present?||block_given?returnrecords.one?ifloaded?limited_count==1endpretty_print(pp)LinkSource:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 1250defpretty_print(pp)subject=loaded??records:annotate("loading for pp")entries=subject.take([limit_value,11].compact.min)entries[10] ="..."ifentries.size==11pp.pp(entries)endreload()LinkForces reloading of relation.Source:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 1175defreloadresetloadendreset()LinkSource:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 1180defreset@future_result&.cancel@future_result=nil@delegate_to_klass=false@to_sql=@arel=@loaded=@should_eager_load=nil@offsets=@take=nil@cache_keys=nil@cache_versions=nil@records=nilselfendscheduled?()LinkReturnstrueif the relation was scheduled on the background thread pool.Source:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 1155defscheduled?!!@future_resultendscope_for_create()LinkSource:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 1217defscope_for_createhash=where_clause.to_h(klass.table_name,equality_only:true)create_with_value.each{|k,v|hash[k.to_s] =v}unlesscreate_with_value.empty?hashendscoping(all_queries: nil, &block)LinkScope all queries to the current scope.Comment.where(post_id: 1).scoping do
  Comment.first
end
# SELECT "comments".* FROM "comments" WHERE "comments"."post_id" = 1 ORDER BY "comments"."id" ASC LIMIT 1Ifall_queries: trueis passed, scoping will apply to all queries for the relation includingupdateanddeleteon instances. Onceall_queriesis set to true it cannot be set to false in a nested block.Please check unscoped if you want to remove all previous scopes (including the default_scope) during the execution of a block.Source:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 534defscoping(all_queries:nil,&block)registry=klass.scope_registryifglobal_scope?(registry)&&all_queries==falseraiseArgumentError,"Scoping is set to apply to all queries and cannot be unset in a nested block."elsifalready_in_scope?(registry)yieldelse_scoping(self,registry,all_queries,&block)endendsize()LinkReturns size of the records.Source:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 346defsizeifloaded?records.lengthelsecount(:all)endendto_a()LinkAlias for:to_aryto_ary()LinkConverts relation objects toArray.Also aliased as:to_aSource:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 330defto_aryrecords.dupendto_sql()LinkReturns sql statement for the relation.User.where(name: 'Oscar').to_sql
# SELECT "users".* FROM "users"  WHERE "users"."name" = 'Oscar'Source:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 1196defto_sql@to_sql||=ifeager_loading?apply_join_dependencydo|relation,join_dependency|relation=join_dependency.apply_column_aliases(relation)relation.to_sqlendelseklass.with_connectiondo|conn|conn.unprepared_statement{conn.to_sql(arel) }endendendtouch_all(*names, time: nil)LinkTouches all records in the current relation, setting theupdated_at/updated_onattributes to the current time or the time specified. It does not instantiate the involved models, and it does not trigger Active Record callbacks or validations. This method can be passed attribute names and an optional time argument. If attribute names are passed, they are updated along withupdated_at/updated_onattributes. If no time argument is passed, the current time is used as default.Examples# Touch all records
Person.all.touch_all
# => "UPDATE \"people\" SET \"updated_at\" = '2018-01-04 22:55:23.132670'"

# Touch multiple records with a custom attribute
Person.all.touch_all(:created_at)
# => "UPDATE \"people\" SET \"updated_at\" = '2018-01-04 22:55:23.132670', \"created_at\" = '2018-01-04 22:55:23.132670'"

# Touch multiple records with a specified time
Person.all.touch_all(time: Time.new(2020, 5, 16, 0, 0, 0))
# => "UPDATE \"people\" SET \"updated_at\" = '2020-05-16 00:00:00'"

# Touch records with scope
Person.where(name: 'David').touch_all
# => "UPDATE \"people\" SET \"updated_at\" = '2018-01-04 22:55:23.132670' WHERE \"people\".\"name\" = 'David'"Source:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 962deftouch_all(*names,time:nil)update_allklass.touch_attributes_with_time(*names,time:time)endupdate_all(updates)LinkUpdates all records in the current relation with details given. This method constructs a single SQL UPDATE statement and sends it straight to the database. It does not instantiate the involved models and it does not trigger Active Record callbacks or validations. However, values passed toupdate_allwill still go through Active Recordâs normal type casting and serialization. Returns the number of rows affected.Note: As Active Record callbacks are not triggered, this method will not automatically updateupdated_at/updated_oncolumns.Parametersupdates- A string, array, or hash representing the SET part of an SQL statement. Any strings provided will be type cast, unless you useArel.sql. (Donât pass user-provided values toArel.sql.)Examples# Update all customers with the given attributes
Customer.update_all wants_email: true

# Update all books with 'Rails' in their title
Book.where('title LIKE ?', '%Rails%').update_all(author: 'David')

# Update all books that match conditions, but limit it to 5 ordered by date
Book.where('title LIKE ?', '%Rails%').order(:created_at).limit(5).update_all(author: 'David')

# Update all invoices and set the number column to its id value.
Invoice.update_all('number = id')

# Update all books with 'Rails' in their title
Book.where('title LIKE ?', '%Rails%').update_all(title: Arel.sql("title + ' - volume 1'"))Source:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 581defupdate_all(updates)raiseArgumentError,"Empty list of attributes to change"ifupdates.blank?return0if@noneifupdates.is_a?(Hash)ifklass.locking_enabled?&&!updates.key?(klass.locking_column)&&!updates.key?(klass.locking_column.to_sym)attr=table[klass.locking_column]updates[attr.name] =_increment_attribute(attr)endvalues=_substitute_values(updates)elsevalues=Arel.sql(klass.sanitize_sql_for_assignment(updates,table.name))endklass.with_connectiondo|c|arel=eager_loading??apply_join_dependency.arel:build_arel(c)arel.source.left=tablegroup_values_arel_columns=arel_columns(group_values.uniq)having_clause_ast=having_clause.astunlesshaving_clause.empty?key=ifklass.composite_primary_key?primary_key.map{|pk|table[pk] }elsetable[primary_key]endstmt=arel.compile_update(values,key,having_clause_ast,group_values_arel_columns)c.update(stmt,"#{klass} Update All").tap{reset}endendupdate_counters(counters)LinkUpdates the counters of the records in the current relation.Parameterscounter- AHashcontaining the names of the fields to update as keys and the amount to update as values.:touchoption - Touch the timestamp columns when updating.If attributes names are passed, they are updated along with update_at/on attributes.Examples# For Posts by a given author increment the comment_count by 1.
Post.where(author_id: author.id).update_counters(comment_count: 1)Source:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 919defupdate_counters(counters)touch=counters.delete(:touch)updates= {}counters.eachdo|counter_name,value|attr=table[counter_name]updates[attr.name] =_increment_attribute(attr,value)endiftouchnames=touchiftouch!=truenames=Array.wrap(names)options=names.extract_options!touch_updates=klass.touch_attributes_with_time(*names,**options)updates.merge!(touch_updates)unlesstouch_updates.empty?endupdate_allupdatesendupsert(attributes, **kwargs)LinkUpdates or inserts (upserts) a single record into the database in a single SQL INSERT statement. It does not instantiate any models nor does it trigger Active Record callbacks or validations. Though passed values go through Active Recordâs type casting and serialization.Seeupsert_allfor documentation.Source:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 793defupsert(attributes,**kwargs)upsert_all([attributes],**kwargs)endupsert_all(attributes, on_duplicate: :update, update_only: nil, returning: nil, unique_by: nil, record_timestamps: nil)LinkUpdates or inserts (upserts) multiple records into the database in a single SQL INSERT statement. It does not instantiate any models nor does it trigger Active Record callbacks or validations. Though passed values go through Active Recordâs type casting and serialization.Theattributesparameter is anArrayof Hashes. EveryHashdetermines the attributes for a single row and must have the same keys.Returns anActiveRecord::Resultwith its contents based on:returning(see below).By default,upsert_allwill update all the columns that can be updated when there is a conflict. These are all the columns except primary keys, read-only columns, and columns covered by the optionalunique_by.Options:returning(PostgreSQL, SQLite3, and MariaDB only) An array of attributes to return for all successfully inserted records, which by default is the primary key. Passreturning: %w[ id name ]for both id and name orreturning: falseto omit the underlyingRETURNINGSQL clause entirely.You can also pass an SQL string if you need more control on the return values (for example,returning: Arel.sql("id, name as new_name")).:unique_by(PostgreSQL and SQLite only) By default rows are considered to be unique by every unique index on the table. Any duplicate rows are skipped.To skip rows according to just one unique index pass:unique_by.Consider a Book model where no duplicate ISBNs make sense, but if any row has an existing id, or is not unique by another unique index,ActiveRecord::RecordNotUniqueis raised.Unique indexes can be identified by columns or name:unique_by: :isbn
unique_by: %i[ author_id name ]
unique_by: :index_books_on_isbnBecause it relies on the index information from the database:unique_byis recommended to be paired with Active Recordâs schema_cache.:on_duplicateConfigure the SQL update sentence that will be used in case of conflict.NOTE: If you use this option you must provide all the columns you want to update by yourself.Example:Commodity.upsert_all(
  [
    { id: 2, name: "Copper", price: 4.84 },
    { id: 4, name: "Gold", price: 1380.87 },
    { id: 6, name: "Aluminium", price: 0.35 }
  ],
  on_duplicate: Arel.sql("price = GREATEST(commodities.price, EXCLUDED.price)")
)See the related:update_onlyoption. Both options canât be used at the same time.:update_onlyProvide a list of column names that will be updated in case of conflict. If not provided,upsert_allwill update all the columns that can be updated. These are all the columns except primary keys, read-only columns, and columns covered by the optionalunique_byExample:Commodity.upsert_all(
  [
    { id: 2, name: "Copper", price: 4.84 },
    { id: 4, name: "Gold", price: 1380.87 },
    { id: 6, name: "Aluminium", price: 0.35 }
  ],
  update_only: [:price] # Only prices will be updated
)See the related:on_duplicateoption. Both options canât be used at the same time.:record_timestampsBy default, automatic setting of timestamp columns is controlled by the modelâsrecord_timestampsconfig, matching typical behavior.To override this and force automatic setting of timestamp columns one way or the other, pass:record_timestamps:record_timestamps: true  # Always set timestamps automatically
record_timestamps: false # Never set timestamps automaticallyExamples# Inserts multiple records, performing an upsert when records have duplicate ISBNs.
# Here "Eloquent Ruby" overwrites "Rework" because its ISBN is duplicate.

Book.upsert_all([
  { title: "Rework", author: "David", isbn: "1" },
  { title: "Eloquent Ruby", author: "Russ", isbn: "1" }
], unique_by: :isbn)

Book.find_by(isbn: "1").title # => "Eloquent Ruby"Source:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 903defupsert_all(attributes,on_duplicate::update,update_only:nil,returning:nil,unique_by:nil,record_timestamps:nil)InsertAll.execute(self,attributes,on_duplicate:on_duplicate,update_only:update_only,returning:returning,unique_by:unique_by,record_timestamps:record_timestamps)endvalues()LinkSource:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 1264defvalues@values.dupendInstance Protected methodsload_records(records)LinkSource:show|on GitHub# File activerecord/lib/active_record/relation.rb, line 1313defload_records(records)@records=records.freeze@loaded=trueend