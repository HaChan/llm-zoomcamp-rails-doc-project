A 256-GCM cipher.By default it will use random initialization vectors. For deterministic encryption, it will use a SHA-256 hash of the text to encrypt and the secret.SeeEncryptorMethodsDdecryptEencryptIiv_lengthKkey_lengthNnewConstantsCIPHER_TYPE="aes-256-gcm"Class Public methodsiv_length()LinkSource:show|on GitHub# File activerecord/lib/active_record/encryption/cipher/aes256_gcm.rb, line 22defiv_lengthOpenSSL::Cipher.new(CIPHER_TYPE).iv_lenendkey_length()LinkSource:show|on GitHub# File activerecord/lib/active_record/encryption/cipher/aes256_gcm.rb, line 18defkey_lengthOpenSSL::Cipher.new(CIPHER_TYPE).key_lenendnew(secret, deterministic: false)LinkWhen iv not provided, it will generate a random iv on each encryption operation (default and recommended operation)Source:show|on GitHub# File activerecord/lib/active_record/encryption/cipher/aes256_gcm.rb, line 29definitialize(secret,deterministic:false)@secret=secret@deterministic=deterministicendInstance Public methodsdecrypt(encrypted_message)LinkSource:show|on GitHub# File activerecord/lib/active_record/encryption/cipher/aes256_gcm.rb, line 55defdecrypt(encrypted_message)encrypted_data=encrypted_message.payloadiv=encrypted_message.headers.ivauth_tag=encrypted_message.headers.auth_tag# Currently the OpenSSL bindings do not raise an error if auth_tag is# truncated, which would allow an attacker to easily forge it. See# https://github.com/ruby/openssl/issues/63raiseActiveRecord::Encryption::Errors::EncryptedContentIntegrityifauth_tag.nil?||auth_tag.bytes.length!=16cipher=OpenSSL::Cipher.new(CIPHER_TYPE)cipher.decryptcipher.key=@secretcipher.iv=ivcipher.auth_tag=auth_tagcipher.auth_data=""decrypted_data=encrypted_data.empty??encrypted_data:cipher.update(encrypted_data)decrypted_data<<cipher.finaldecrypted_datarescueOpenSSL::Cipher::CipherError,TypeError,ArgumentErrorraiseActiveRecord::Encryption::Errors::Decryptionendencrypt(clear_text)LinkSource:show|on GitHub# File activerecord/lib/active_record/encryption/cipher/aes256_gcm.rb, line 34defencrypt(clear_text)# This code is extracted from +ActiveSupport::MessageEncryptor+. Not using it directly because we want to control# the message format and only serialize things once at the +ActiveRecord::Encryption::Message+ level. Also, this# cipher is prepared to deal with deterministic/non deterministic encryption modes.cipher=OpenSSL::Cipher.new(CIPHER_TYPE)cipher.encryptcipher.key=@secretiv=generate_iv(cipher,clear_text)cipher.iv=ivencrypted_data=clear_text.empty??clear_text.dup:cipher.update(clear_text)encrypted_data<<cipher.finalActiveRecord::Encryption::Message.new(payload:encrypted_data).tapdo|message|message.headers.iv=ivmessage.headers.auth_tag=cipher.auth_tagendend