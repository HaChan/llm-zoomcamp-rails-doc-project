MethodsDdate,date=,date?Eetag=,etag?Llast_modified,last_modified=,last_modified?Sstrong_etag=,strong_etag?Wweak_etag=,weak_etag?ConstantsDATE="Date"DEFAULT_CACHE_CONTROL="max-age=0, private, must-revalidate"LAST_MODIFIED="Last-Modified"MUST_REVALIDATE="must-revalidate"NO_CACHE="no-cache"NO_STORE="no-store"PRIVATE="private"PUBLIC="public"SPECIAL_KEYS=Set.new(%w[extras no-store no-cache max-age public private must-revalidate])Attributes[R]cache_controlInstance Public methodsdate()LinkSource:show|on GitHub# File actionpack/lib/action_dispatch/http/cache.rb, line 70defdateifdate_header=get_header(DATE)Time.httpdate(date_header)endenddate=(utc_time)LinkSource:show|on GitHub# File actionpack/lib/action_dispatch/http/cache.rb, line 80defdate=(utc_time)set_headerDATE,utc_time.httpdateenddate?()LinkSource:show|on GitHub# File actionpack/lib/action_dispatch/http/cache.rb, line 76defdate?has_header?DATEendetag=(weak_validators)LinkThis method sets a weak ETag validator on the response so browsers and proxies may cache the response, keyed on the ETag. On subsequent requests, theIf-None-Matchheader is set to the cached ETag. If it matches the current ETag, we can return a304 Not Modifiedresponse with no body, letting the browser or proxy know that their cache is current. Big savings in request time and network bandwidth.Weak ETags are considered to be semantically equivalent but not byte-for-byte identical. This is perfect for browser caching of HTML pages where we donât care about exact equality, just what the user is viewing.Strong ETags are considered byte-for-byte identical. They allow a browser or proxy cache to supportRangerequests, useful for paging through a PDF file or scrubbing through a video. Some CDNs only support strong ETags and will ignore weak ETags entirely.Weak ETags are what we almost always need, so theyâre the default. Check outstrong_etag= to provide a strong ETag validator.Source:show|on GitHub# File actionpack/lib/action_dispatch/http/cache.rb, line 102defetag=(weak_validators)self.weak_etag=weak_validatorsendetag?()LinkSource:show|on GitHub# File actionpack/lib/action_dispatch/http/cache.rb, line 114defetag?;etag;endlast_modified()LinkSource:show|on GitHub# File actionpack/lib/action_dispatch/http/cache.rb, line 56deflast_modifiediflast=get_header(LAST_MODIFIED)Time.httpdate(last)endendlast_modified=(utc_time)LinkSource:show|on GitHub# File actionpack/lib/action_dispatch/http/cache.rb, line 66deflast_modified=(utc_time)set_headerLAST_MODIFIED,utc_time.httpdateendlast_modified?()LinkSource:show|on GitHub# File actionpack/lib/action_dispatch/http/cache.rb, line 62deflast_modified?has_header?LAST_MODIFIEDendstrong_etag=(strong_validators)LinkSource:show|on GitHub# File actionpack/lib/action_dispatch/http/cache.rb, line 110defstrong_etag=(strong_validators)set_header"ETag",generate_strong_etag(strong_validators)endstrong_etag?()LinkTrue if an ETag is set, and it isnât a weak validator (not preceded withW/).Source:show|on GitHub# File actionpack/lib/action_dispatch/http/cache.rb, line 123defstrong_etag?etag?&&!weak_etag?endweak_etag=(weak_validators)LinkSource:show|on GitHub# File actionpack/lib/action_dispatch/http/cache.rb, line 106defweak_etag=(weak_validators)set_header"ETag",generate_weak_etag(weak_validators)endweak_etag?()LinkTrue if an ETag is set, and itâs a weak validator (preceded withW/).Source:show|on GitHub# File actionpack/lib/action_dispatch/http/cache.rb, line 117defweak_etag?etag?&&etag.start_with?('W/"')end