Redis Cache StoreDeployment note: Take care to use adedicated Redis cacherather than pointing this at a persistent Redis server (for example, one used as an Active Job queue). Redis wonât cope well with mixed usage patterns and it wonât expire cache entries by default.Redis cache server setup guide:redis.io/topics/lru-cacheSupports vanilla Redis, hiredis, andRedis::Distributed.Supports Memcached-like sharding across Redises withRedis::Distributed.Fault tolerant. If the Redis server is unavailable, no exceptions are raised.Cachefetches are all misses and writes are dropped.Local cache. Hot in-memory primary cache within block/middleware scope.read_multiandwrite_multisupport for Redis mget/mset. UseRedis::Distributed4.0.1+ for distributed mget support.delete_matchedsupport for Redis KEYS globs.MethodsCcleanup,clearDdecrement,delete_matchedIincrement,inspectNnewRread_multiSstats,supports_cache_versioning?ConstantsDEFAULT_ERROR_HANDLER=-> (method:, returning:, exception:) do
if logger
logger.error { "RedisCacheStore: #{method} failed, returned #{returning.inspect}: #{exception.class}: #{exception.message}" }
end
ActiveSupport.error_reporter&.report(
exception,
severity: :warning,
source: "redis_cache_store.active_support",
)
endDEFAULT_REDIS_OPTIONS={
connect_timeout:    1,
read_timeout:       1,
write_timeout:      1,
}MAX_KEY_BYTESIZE=1024Keys are truncated with the Active Support digest if they exceed 1kBAttributes[R]max_key_bytesize[R]redisClass Public methodsnew(error_handler: DEFAULT_ERROR_HANDLER, **redis_options)LinkCreates a new Redis cache store.There are four ways to provide the Redis client used by the cache: the:redisparam can be a Redis instance or a block that returns a Redis instance, or the:urlparam can be a string or an array of strings which will be used to create a Redis instance or aRedis::Distributedinstance.Option  Class       Result
:redis  Proc    ->  options[:redis].call
:redis  Object  ->  options[:redis]
:url    String  ->  Redis.new(url: â¦)
:url    Array   ->  Redis::Distributed.new([{ url: â¦ }, { url: â¦ }, â¦])No namespace is set by default. Provide one if the Redis cache server is shared with other apps:namespace: 'myapp-cache'.Compression is enabled by default with a 1kB threshold, so cached values larger than 1kB are automatically compressed. Disable by passingcompress: falseor change the threshold by passingcompress_threshold: 4.kilobytes.No expiry is set on cache entries by default. Redis is expected to be configured with an eviction policy that automatically deletes least-recently or -frequently used keys when it reaches max memory. Seeredis.io/topics/lru-cachefor cache server setup.Race condition TTL is not set by default. This can be used to avoid âthundering herdâ cache writes when hot cache entries are expired. SeeActiveSupport::Cache::Store#fetchfor more.Settingskip_nil: truewill not cache nil results:cache.fetch('foo') { nil }
cache.fetch('bar', skip_nil: true) { nil }
cache.exist?('foo') # => true
cache.exist?('bar') # => falseSource:show|on GitHub# File activesupport/lib/active_support/cache/redis_cache_store.rb, line 149definitialize(error_handler:DEFAULT_ERROR_HANDLER,**redis_options)universal_options=redis_options.extract!(*UNIVERSAL_OPTIONS)ifpool_options=self.class.send(:retrieve_pool_options,redis_options)@redis=::ConnectionPool.new(pool_options) {self.class.build_redis(**redis_options) }else@redis=self.class.build_redis(**redis_options)end@max_key_bytesize=MAX_KEY_BYTESIZE@error_handler=error_handlersuper(universal_options)endsupports_cache_versioning?()LinkAdvertise cache versioning support.Source:show|on GitHub# File activesupport/lib/active_support/cache/redis_cache_store.rb, line 63defself.supports_cache_versioning?trueendInstance Public methodscleanup(options = nil)LinkCacheStoreAPI implementation.Removes expired entries. Handled natively by Redis least-recently-/ least-frequently-used expiry, so manual cleanup is not supported.Source:show|on GitHub# File activesupport/lib/active_support/cache/redis_cache_store.rb, line 279defcleanup(options=nil)superendclear(options = nil)LinkClear the entire cache on all Redis servers. Safe to use on shared servers if the cache is namespaced.Failsafe: Raises errors.Source:show|on GitHub# File activesupport/lib/active_support/cache/redis_cache_store.rb, line 287defclear(options=nil)failsafe:cleardoifnamespace=merged_options(options)[:namespace]delete_matched"*",namespace:namespaceelseredis.then{|c|c.flushdb}endendenddecrement(name, amount = 1, options = nil)LinkDecrement a cached integer value using the Redis decrby atomic operator. Returns the updated value.If the key is unset or has expired, it will be set to-amount:cache.decrement("foo") # => -1To set a specific value, callwritepassingraw: true:cache.write("baz", 5, raw: true)
cache.decrement("baz") # => 4Decrementing a non-numeric value, or a value written withoutraw: true, will fail and returnnil.Failsafe: Raises errors.Source:show|on GitHub# File activesupport/lib/active_support/cache/redis_cache_store.rb, line 264defdecrement(name,amount=1,options=nil)options=merged_options(options)key=normalize_key(name,options)instrument:decrement,key,amount:amountdofailsafe:decrementdochange_counter(key,-amount,options)endendenddelete_matched(matcher, options = nil)LinkCacheStoreAPI implementation.Supports Redis KEYS glob patterns:h?llo matches hello, hallo and hxllo
h*llo matches hllo and heeeello
h[ae]llo matches hello and hallo, but not hillo
h[^e]llo matches hallo, hbllo, ... but not hello
h[a-b]llo matches hallo and hblloUse \ to escape special characters if you want to match them verbatim.Seeredis.io/commands/KEYSfor more.Failsafe: Raises errors.Source:show|on GitHub# File activesupport/lib/active_support/cache/redis_cache_store.rb, line 198defdelete_matched(matcher,options=nil)unlessString===matcherraiseArgumentError,"Only Redis glob strings are supported: #{matcher.inspect}"endpattern=namespace_key(matcher,options)instrument:delete_matched,patterndoredis.thendo|c|cursor="0"# Fetch keys in batches using SCAN to avoid blocking the Redis server.nodes=c.respond_to?(:nodes)?c.nodes:[c]nodes.eachdo|node|begincursor,keys=node.scan(cursor,match:pattern,count:SCAN_BATCH_SIZE)node.del(*keys)unlesskeys.empty?enduntilcursor=="0"endendendendincrement(name, amount = 1, options = nil)LinkIncrement a cached integer value using the Redis incrby atomic operator. Returns the updated value.If the key is unset or has expired, it will be set toamount:cache.increment("foo") # => 1
cache.increment("bar", 100) # => 100To set a specific value, callwritepassingraw: true:cache.write("baz", 5, raw: true)
cache.increment("baz") # => 6Incrementing a non-numeric value, or a value written withoutraw: true, will fail and returnnil.Failsafe: Raises errors.Source:show|on GitHub# File activesupport/lib/active_support/cache/redis_cache_store.rb, line 237defincrement(name,amount=1,options=nil)options=merged_options(options)key=normalize_key(name,options)instrument:increment,key,amount:amountdofailsafe:incrementdochange_counter(key,amount,options)endendendinspect()LinkSource:show|on GitHub# File activesupport/lib/active_support/cache/redis_cache_store.rb, line 164definspect"#<#{self.class} options=#{options.inspect} redis=#{redis.inspect}>"endread_multi(*names)LinkCacheStoreAPI implementation.Read multiple values at once. Returns a hash of requested keys -> fetched values.Source:show|on GitHub# File activesupport/lib/active_support/cache/redis_cache_store.rb, line 172defread_multi(*names)return{}ifnames.empty?options=names.extract_options!instrument_multi(:read_multi,names,options)do|payload|read_multi_entries(names,**options).tapdo|results|payload[:hits] =results.keysendendendstats()LinkGet info from redis servers.Source:show|on GitHub# File activesupport/lib/active_support/cache/redis_cache_store.rb, line 298defstatsredis.then{|c|c.info}end