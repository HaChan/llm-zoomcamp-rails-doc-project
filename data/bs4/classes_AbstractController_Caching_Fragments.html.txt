Abstract ControllerCachingFragmentsFragment caching is used for caching various blocks within views without caching the entire action as a whole. This is useful when certain elements of an action change frequently or depend on complicated state while other parts rarely change or can be shared amongst multiple parties. The caching is done using thecachehelper available in the Action View. SeeActionView::Helpers::CacheHelperfor more information.While itâs strongly recommended that you use key-based cache expiration (see links in CacheHelper for more information), it is also possible to manually expire caches. For example:expire_fragment('name_of_cache')NamespaceMODULEAbstractController::Caching::Fragments::ClassMethodsMethodsCcombined_fragment_cache_keyEexpire_fragmentFfragment_exist?Rread_fragmentWwrite_fragmentInstance Public methodscombined_fragment_cache_key(key)LinkGiven a key (as described inexpire_fragment), returns a key array suitable for use in reading, writing, or expiring a cached fragment. All keys begin with:views, followed byENV["RAILS_CACHE_ID"]orENV["RAILS_APP_VERSION"]if set, followed by any controller-wide key prefix values, ending with the specifiedkeyvalue.Source:show|on GitHub# File actionpack/lib/abstract_controller/caching/fragments.rb, line 68defcombined_fragment_cache_key(key)head=self.class.fragment_cache_keys.map{|k|instance_exec(&k) }tail=key.is_a?(Hash)?url_for(key).split("://").last:keycache_key= [:views,ENV["RAILS_CACHE_ID"]||ENV["RAILS_APP_VERSION"],head,tail]cache_key.flatten!(1)cache_key.compact!cache_keyendexpire_fragment(key, options = nil)LinkRemoves fragments from the cache.keycan take one of three forms:String- This would normally take the form of a path, likepages/45/notes.Hash- Treated as an implicit call tourl_for, like{ controller: 'pages', action: 'notes', id: 45}Regexp- Will remove any fragment that matches, so%r{pages/\d*/notes}might remove all notes. Make sure you donât use anchors in the regex (^or$) because the actual filename matched looks like./cache/filename/path.cache. Note:Regexpexpiration is only supported on caches that can iterate over all keys (unlike memcached).optionsis passed through to the cache storeâsdeletemethod (ordelete_matched, forRegexpkeys).Source:show|on GitHub# File actionpack/lib/abstract_controller/caching/fragments.rb, line 131defexpire_fragment(key,options=nil)returnunlesscache_configured?key=combined_fragment_cache_key(key)unlesskey.is_a?(Regexp)instrument_fragment_cache:expire_fragment,keydoifkey.is_a?(Regexp)cache_store.delete_matched(key,options)elsecache_store.delete(key,options)endendendfragment_exist?(key, options = nil)LinkCheck if a cached fragment from the location signified bykeyexists (seeexpire_fragmentfor acceptable formats).Source:show|on GitHub# File actionpack/lib/abstract_controller/caching/fragments.rb, line 105deffragment_exist?(key,options=nil)returnunlesscache_configured?key=combined_fragment_cache_key(key)instrument_fragment_cache:exist_fragment?,keydocache_store.exist?(key,options)endendread_fragment(key, options = nil)LinkReads a cached fragment from the location signified bykey(seeexpire_fragmentfor acceptable formats).Source:show|on GitHub# File actionpack/lib/abstract_controller/caching/fragments.rb, line 93defread_fragment(key,options=nil)returnunlesscache_configured?key=combined_fragment_cache_key(key)instrument_fragment_cache:read_fragment,keydoresult=cache_store.read(key,options)result.respond_to?(:html_safe)?result.html_safe:resultendendwrite_fragment(key, content, options = nil)LinkWritescontentto the location signified bykey(seeexpire_fragmentfor acceptable formats).Source:show|on GitHub# File actionpack/lib/abstract_controller/caching/fragments.rb, line 80defwrite_fragment(key,content,options=nil)returncontentunlesscache_configured?key=combined_fragment_cache_key(key)instrument_fragment_cache:write_fragment,keydocontent=content.to_strcache_store.write(key,content,options)endcontentend