Hash With Indifferent AccessImplements a hash where keys:fooand"foo"are considered to be the same.rgb = ActiveSupport::HashWithIndifferentAccess.new

rgb[:black] = '#000000'
rgb[:black]  # => '#000000'
rgb['black'] # => '#000000'

rgb['white'] = '#FFFFFF'
rgb[:white]  # => '#FFFFFF'
rgb['white'] # => '#FFFFFF'Internally symbols are mapped to strings when used as keys in the entire writing interface (calling[]=,merge, etc). This mapping belongs to the public interface. For example, given:hash = ActiveSupport::HashWithIndifferentAccess.new(a: 1)You are guaranteed that the key is returned as a string:hash.keys # => ["a"]Technically other types of keys are accepted:hash = ActiveSupport::HashWithIndifferentAccess.new(a: 1)
hash[0] = 0
hash # => {"a"=>1, 0=>0}but this class is intended for use cases where strings or symbols are the expected keys and it is convenient to understand both as the same. For example theparamshash in Ruby on Rails.Note that core extensions defineHash#with_indifferent_access:rgb = { black: '#000000', white: '#FFFFFF' }.with_indifferent_accesswhich may be handy.To access this class outside of Rails, require the core extension with:require "active_support/core_ext/hash/indifferent_access"which will, in turn, require this file.Methods#[],[],[]=AassocCcompactDdeep_stringify_keys,deep_stringify_keys!,deep_symbolize_keys,default,delete,dig,dupEexcept,extractable_options?Ffetch,fetch_valuesHhas_key?Iinclude?Kkey?Mmember?,merge,merge!Nnested_under_indifferent_access,newRregular_update,regular_writer,reject,replace,reverse_merge,reverse_merge!Sselect,slice,slice!,store,stringify_keys,stringify_keys!,symbolize_keysTto_hash,to_options,to_options!,to_proc,transform_keys,transform_keys!,transform_valuesUupdateVvalues_atWwith_defaults,with_defaults!,with_indifferent_access,withoutClass Public methods[](*args)LinkSource:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 85defself.[](*args)new.merge!(Hash[*args])endnew(constructor = nil)LinkSource:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 70definitialize(constructor=nil)ifconstructor.respond_to?(:to_hash)super()update(constructor)hash=constructor.is_a?(Hash)?constructor:constructor.to_hashself.default=hash.defaultifhash.defaultself.default_proc=hash.default_procifhash.default_procelsifconstructor.nil?super()elsesuper(constructor)endendInstance Public methods[](key)LinkSame asHash#[]where the key passed as argument can be either a string or a symbol:counters = ActiveSupport::HashWithIndifferentAccess.new
counters[:foo] = 1

counters['foo'] # => 1
counters[:foo]  # => 1
counters[:zoo]  # => nilSource:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 168def[](key)super(convert_key(key))end[]=(key, value)LinkAssigns a new value to the hash:hash = ActiveSupport::HashWithIndifferentAccess.new
hash[:key] = 'value'This value can be later fetched using either:keyor'key'.Also aliased as:regular_writer,storeSource:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 98def[]=(key,value)regular_writer(convert_key(key),convert_value(value,conversion::assignment))endassoc(key)LinkSame asHash#assocwhere the key passed as argument can be either a string or a symbol:counters = ActiveSupport::HashWithIndifferentAccess.new
counters[:foo] = 1

counters.assoc('foo') # => ["foo", 1]
counters.assoc(:foo)  # => ["foo", 1]
counters.assoc(:zoo)  # => nilSource:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 181defassoc(key)super(convert_key(key))endcompact()LinkSource:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 375defcompactdup.tap(&:compact!)enddeep_stringify_keys()LinkSource:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 319defdeep_stringify_keys;dupenddeep_stringify_keys!()LinkSource:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 317defdeep_stringify_keys!;selfenddeep_symbolize_keys()LinkSource:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 324defdeep_symbolize_keys;to_hash.deep_symbolize_keys!enddefault(key = (no_key = true))LinkSame asHash#defaultwhere the key passed as argument can be either a string or a symbol:hash = ActiveSupport::HashWithIndifferentAccess.new(1)
hash.default                   # => 1

hash = ActiveSupport::HashWithIndifferentAccess.new { |hash, key| key }
hash.default                   # => nil
hash.default('foo')            # => 'foo'
hash.default(:foo)             # => 'foo'Source:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 223defdefault(key= (no_key=true))ifno_keysuper()elsesuper(convert_key(key))endenddelete(key)LinkRemoves the specified key from the hash.Source:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 303defdelete(key)super(convert_key(key))enddig(*args)LinkSame asHash#digwhere the key passed as argument can be either a string or a symbol:counters = ActiveSupport::HashWithIndifferentAccess.new
counters[:foo] = { bar: 1 }

counters.dig('foo', 'bar')     # => 1
counters.dig(:foo, :bar)       # => 1
counters.dig(:zoo)             # => nilSource:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 208defdig(*args)args[0] =convert_key(args[0])ifargs.size>0super(*args)enddup()LinkReturns a shallow copy of the hash.hash = ActiveSupport::HashWithIndifferentAccess.new({ a: { b: 'b' } })
dup  = hash.dup
dup[:a][:c] = 'c'

hash[:a][:c] # => "c"
dup[:a][:c]  # => "c"Source:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 264defdupself.class.new(self).tapdo|new_hash|set_defaults(new_hash)endendexcept(*keys)LinkReturns a hash with indifferent access that includes everything except given keys.hash = { a: "x", b: "y", c: 10 }.with_indifferent_access
hash.except(:a, "b") # => {c: 10}.with_indifferent_access
hash                 # => { a: "x", b: "y", c: 10 }.with_indifferent_accessAlso aliased as:withoutSource:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 311defexcept(*keys)dup.except!(*keys)endextractable_options?()LinkReturnstrueso thatArray#extract_options!finds members of this class.Source:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 58defextractable_options?trueendfetch(key, *extras)LinkSame asHash#fetchwhere the key passed as argument can be either a string or a symbol:counters = ActiveSupport::HashWithIndifferentAccess.new
counters[:foo] = 1

counters.fetch('foo')          # => 1
counters.fetch(:bar, 0)        # => 0
counters.fetch(:bar) { |key| 0 } # => 0
counters.fetch(:zoo)           # => KeyError: key not found: "zoo"Source:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 195deffetch(key,*extras)super(convert_key(key),*extras)endfetch_values(*indices, &block)LinkReturns an array of the values at the specified indices, but also raises an exception when one of the keys canât be found.hash = ActiveSupport::HashWithIndifferentAccess.new
hash[:a] = 'x'
hash[:b] = 'y'
hash.fetch_values('a', 'b') # => ["x", "y"]
hash.fetch_values('a', 'c') { |key| 'z' } # => ["x", "z"]
hash.fetch_values('a', 'c') # => KeyError: key not found: "c"Source:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 251deffetch_values(*indices,&block)indices.map!{|key|convert_key(key) }superendhas_key?(key)LinkAlias for:key?include?(key)LinkAlias for:key?key?(key)LinkChecks the hash for a key matching the argument passed in:hash = ActiveSupport::HashWithIndifferentAccess.new
hash['key'] = 'value'
hash.key?(:key)  # => true
hash.key?('key') # => trueAlso aliased as:include?,has_key?,member?Source:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 151defkey?(key)super(convert_key(key))endmember?(key)LinkAlias for:key?merge(*hashes, &block)LinkThis method has the same semantics ofupdate, except it does not modify the receiver but rather returns a new hash with indifferent access with the result of the merge.Source:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 273defmerge(*hashes,&block)dup.update(*hashes,&block)endmerge!(*other_hashes, &block)LinkAlias for:updatenested_under_indifferent_access()LinkSource:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 66defnested_under_indifferent_accessselfendregular_update(*other_hashes, &block)LinkAlias for:updateregular_writer(key, value)LinkAlias for:[]=reject(*args, &block)LinkSource:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 332defreject(*args,&block)returnto_enum(:reject)unlessblock_given?dup.tap{|hash|hash.reject!(*args,&block) }endreplace(other_hash)LinkReplaces the contents of this hash with other_hash.h = { "a" => 100, "b" => 200 }
h.replace({ "c" => 300, "d" => 400 }) # => {"c"=>300, "d"=>400}Source:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 298defreplace(other_hash)super(self.class.new(other_hash))endreverse_merge(other_hash)LinkLikemergebut the other way around: Merges the receiver into the argument and returns a new hash with indifferent access as result:hash = ActiveSupport::HashWithIndifferentAccess.new
hash['a'] = nil
hash.reverse_merge(a: 0, b: 1) # => {"a"=>nil, "b"=>1}Also aliased as:with_defaultsSource:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 283defreverse_merge(other_hash)super(self.class.new(other_hash))endreverse_merge!(other_hash)LinkSame semantics asreverse_mergebut modifies the receiver in-place.Also aliased as:with_defaults!Source:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 289defreverse_merge!(other_hash)super(self.class.new(other_hash))endselect(*args, &block)LinkSource:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 327defselect(*args,&block)returnto_enum(:select)unlessblock_given?dup.tap{|hash|hash.select!(*args,&block) }endslice(*keys)LinkSource:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 365defslice(*keys)keys.map!{|key|convert_key(key) }self.class.new(super)endslice!(*keys)LinkSource:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 370defslice!(*keys)keys.map!{|key|convert_key(key) }superendstore(key, value)LinkAlias for:[]=stringify_keys()LinkSource:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 318defstringify_keys;dupendstringify_keys!()LinkSource:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 316defstringify_keys!;selfendsymbolize_keys()LinkAlso aliased as:to_optionsSource:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 322defsymbolize_keys;to_hash.symbolize_keys!endto_hash()LinkConvert to a regular hash with string keys.Source:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 380defto_hash_new_hash=Hash.newset_defaults(_new_hash)eachdo|key,value|_new_hash[key] =convert_value(value,conversion::to_hash)end_new_hashendto_options()LinkAlias for:symbolize_keysto_options!()LinkSource:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 325defto_options!;selfendto_proc()LinkSource:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 390defto_procproc{|key|self[key] }endtransform_keys(hash = NOT_GIVEN, &block)LinkSource:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 344deftransform_keys(hash=NOT_GIVEN,&block)returnto_enum(:transform_keys)ifNOT_GIVEN.equal?(hash)&&!block_given?dup.tap{|h|h.transform_keys!(hash,&block) }endtransform_keys!(hash = NOT_GIVEN, &block)LinkSource:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 349deftransform_keys!(hash=NOT_GIVEN,&block)returnto_enum(:transform_keys!)ifNOT_GIVEN.equal?(hash)&&!block_given?ifhash.nil?superelsifNOT_GIVEN.equal?(hash)keys.each{|key|self[yield(key)] =delete(key) }elsifblock_given?keys.each{|key|self[hash[key]||yield(key)] =delete(key) }elsekeys.each{|key|self[hash[key]||key] =delete(key) }endselfendtransform_values(&block)LinkSource:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 337deftransform_values(&block)returnto_enum(:transform_values)unlessblock_given?dup.tap{|hash|hash.transform_values!(&block) }endupdate(*other_hashes, &block)LinkUpdates the receiver in-place, merging in the hashes passed as arguments:hash_1 = ActiveSupport::HashWithIndifferentAccess.new
hash_1[:key] = 'value'

hash_2 = ActiveSupport::HashWithIndifferentAccess.new
hash_2[:key] = 'New Value!'

hash_1.update(hash_2) # => {"key"=>"New Value!"}

hash = ActiveSupport::HashWithIndifferentAccess.new
hash.update({ "a" => 1 }, { "b" => 2 }) # => { "a" => 1, "b" => 2 }The arguments can be either anActiveSupport::HashWithIndifferentAccessor a regularHash. In either case the merge respects the semantics of indifferent access.If the argument is a regular hash with keys:keyand"key"only one of the values end up in the receiver, but which one is unspecified.When given a block, the value for duplicated keys will be determined by the result of invoking the block with the duplicated key, the value in the receiver, and the value inother_hash. The rules for duplicated keys follow the semantics of indifferent access:hash_1[:key] = 10
hash_2['key'] = 12
hash_1.update(hash_2) { |key, old, new| old + new } # => {"key"=>22}Also aliased as:regular_update,merge!Source:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 132defupdate(*other_hashes,&block)ifother_hashes.size==1update_with_single_argument(other_hashes.first,block)elseother_hashes.eachdo|other_hash|update_with_single_argument(other_hash,block)endendselfendvalues_at(*keys)LinkReturns an array of the values at the specified indices:hash = ActiveSupport::HashWithIndifferentAccess.new
hash[:a] = 'x'
hash[:b] = 'y'
hash.values_at('a', 'b') # => ["x", "y"]Source:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 237defvalues_at(*keys)keys.map!{|key|convert_key(key) }superendwith_defaults(other_hash)LinkAlias for:reverse_mergewith_defaults!(other_hash)LinkAlias for:reverse_merge!with_indifferent_access()LinkSource:show|on GitHub# File activesupport/lib/active_support/hash_with_indifferent_access.rb, line 62defwith_indifferent_accessdupendwithout(*keys)LinkAlias for:except